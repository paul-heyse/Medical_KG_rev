warning: The top-level linter settings are deprecated in favour of their counterparts in the `lint` section. Please update the following options in `pyproject.toml`:
  - 'extend-select' -> 'lint.extend-select'
  - 'ignore' -> 'lint.ignore'
  - 'isort' -> 'lint.isort'
warning: `incorrect-blank-line-before-class` (D203) and `no-blank-line-before-class` (D211) are incompatible. Ignoring `incorrect-blank-line-before-class`.
warning: `multi-line-summary-first-line` (D212) and `multi-line-summary-second-line` (D213) are incompatible. Ignoring `multi-line-summary-second-line`.
D103 Missing docstring in public function
  --> src/Medical_KG_rev/gateway/__init__.py:11:5
   |
11 | def create_app():
   |     ^^^^^^^^^^
12 |     from .app import create_app as _create_app
   |

D103 Missing docstring in public function
  --> src/Medical_KG_rev/gateway/__init__.py:17:5
   |
17 | def get_gateway_service():
   |     ^^^^^^^^^^^^^^^^^^^
18 |     from .services import get_gateway_service as _get_gateway_service
   |

D101 Missing docstring in public class
  --> src/Medical_KG_rev/gateway/app.py:38:7
   |
38 | class JSONAPIResponseMiddleware(BaseHTTPMiddleware):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^
39 |     async def dispatch(self, request: Request, call_next):  # type: ignore[override]
40 |         response = await call_next(request)
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/gateway/app.py:39:15
   |
38 | class JSONAPIResponseMiddleware(BaseHTTPMiddleware):
39 |     async def dispatch(self, request: Request, call_next):  # type: ignore[override]
   |               ^^^^^^^^
40 |         response = await call_next(request)
41 |         if response.media_type == "application/json":
   |

D101 Missing docstring in public class
  --> src/Medical_KG_rev/gateway/app.py:49:7
   |
49 | class SecurityHeadersMiddleware(BaseHTTPMiddleware):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^
50 |     def __init__(self, app: FastAPI, *, headers_config) -> None:  # type: ignore[override]
51 |         super().__init__(app)
   |

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/gateway/app.py:50:9
   |
49 | class SecurityHeadersMiddleware(BaseHTTPMiddleware):
50 |     def __init__(self, app: FastAPI, *, headers_config) -> None:  # type: ignore[override]
   |         ^^^^^^^^
51 |         super().__init__(app)
52 |         self._cfg = headers_config
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/gateway/app.py:54:15
   |
52 |         self._cfg = headers_config
53 |
54 |     async def dispatch(self, request: Request, call_next):  # type: ignore[override]
   |               ^^^^^^^^
55 |         if request.url.scheme != "https" and request.app.state.settings.security.enforce_https:
56 |             forwarded_proto = request.headers.get("x-forwarded-proto")
   |

D103 Missing docstring in public function
  --> src/Medical_KG_rev/gateway/app.py:70:5
   |
70 | def create_problem_response(detail: ProblemDetail) -> JSONResponse:
   |     ^^^^^^^^^^^^^^^^^^^^^^^
71 |     payload: dict[str, Any] = detail.model_dump(mode="json")
72 |     status = payload.get("status", 500)
   |

D103 Missing docstring in public function
  --> src/Medical_KG_rev/gateway/app.py:85:5
   |
85 | def create_app() -> FastAPI:
   |     ^^^^^^^^^^
86 |     settings = get_settings()
87 |     app = FastAPI(title="Medical KG Multi-Protocol Gateway", version="0.1.0")
   |

D101 Missing docstring in public class
  --> src/Medical_KG_rev/gateway/chunking.py:27:7
   |
26 | @dataclass(slots=True)
27 | class TranslatedChunkingError:
   |       ^^^^^^^^^^^^^^^^^^^^^^^
28 |     detail: ProblemDetail
29 |     failure_type: str
   |

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/gateway/chunking.py:36:9
   |
34 |     """Maps domain errors to protocol friendly responses and observability hooks."""
35 |
36 |     def __init__(
   |         ^^^^^^^^
37 |         self,
38 |         *,
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/gateway/chunking.py:45:9
   |
43 |         self._failure_recorder = failure_recorder
44 |
45 |     def translate(
   |         ^^^^^^^^^
46 |         self,
47 |         exc: Exception,
   |

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/gateway/chunking_errors.py:35:9
   |
33 |     """Map domain-specific chunking failures to `ProblemDetail` payloads."""
34 |
35 |     def __init__(self, *, strategies: Sequence[str], base_path: str = "/v1/chunk") -> None:
   |         ^^^^^^^^
36 |         self._strategies = tuple(strategies)
37 |         self._base_path = base_path.rstrip("/")
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/gateway/chunking_errors.py:39:9
   |
37 |         self._base_path = base_path.rstrip("/")
38 |
39 |     def translate(
   |         ^^^^^^^^^
40 |         self,
41 |         exc: Exception,
   |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/chunking_errors.py:162:9
    |
160 |         return None
161 |
162 |     def from_context(self, context: Mapping[str, Any]) -> ProblemDetail | None:
    |         ^^^^^^^^^^^^
163 |         problem = context.get("problem")
164 |         if isinstance(problem, ProblemDetail):
    |

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/gateway/coordinators/base.py:44:9
   |
42 |     """Raised when a coordinator operation fails after all guards."""
43 |
44 |     def __init__(self, message: str, *, context: Mapping[str, Any] | None = None) -> None:
   |         ^^^^^^^^
45 |         super().__init__(message)
46 |         self.context = context or {}
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/gateway/coordinators/base.py:59:9
   |
58 |     @classmethod
59 |     def create(cls, name: str) -> "CoordinatorMetrics":
   |         ^^^^^^
60 |         try:
61 |             return _METRICS_CACHE[name]
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/gateway/coordinators/base.py:96:9
   |
94 |     limiter: AsyncLimiter | None = None
95 |
96 |     def build_retrying(self) -> Retrying:
   |         ^^^^^^^^^^^^^^
97 |         return Retrying(
98 |             stop=stop_after_attempt(self.retry_attempts),
   |

D105 Missing docstring in magic method
   --> src/Medical_KG_rev/gateway/coordinators/base.py:114:9
    |
112 |     metrics: CoordinatorMetrics
113 |
114 |     def __post_init__(self) -> None:
    |         ^^^^^^^^^^^^^
115 |         self._retrying = self.config.build_retrying()
116 |         self._limiter = self.config.limiter
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/coordinators/base.py:119:9
    |
117 |         self._breaker = self.config.breaker
118 |
119 |     def __call__(self, request: _RequestT, /, **kwargs: Any) -> _ResultT:
    |         ^^^^^^^^
120 |         logger.debug(
121 |             "gateway.coordinator.invoke",
    |

invalid-syntax: Expected ',', found name
  --> src/Medical_KG_rev/gateway/coordinators/chunking.py:86:9
   |
84 |             options=dict(request.options or {}),
85 |         metadata = dict(self._metadata_without_text(request.options))
86 |         options = ChunkingOptions(
   |         ^^^^^^^
87 |             strategy=request.strategy,
88 |             max_tokens=request.chunk_size,
   |

invalid-syntax: Duplicate keyword argument "options"
  --> src/Medical_KG_rev/gateway/coordinators/chunking.py:86:9
   |
84 |               options=dict(request.options or {}),
85 |           metadata = dict(self._metadata_without_text(request.options))
86 | /         options = ChunkingOptions(
87 | |             strategy=request.strategy,
88 | |             max_tokens=request.chunk_size,
89 | |             overlap=request.overlap,
90 | |             metadata=metadata,
91 | |         )
   | |_________^
92 |
93 |           started = time.perf_counter()
   |

invalid-syntax: Expected ',', found name
  --> src/Medical_KG_rev/gateway/coordinators/chunking.py:93:9
   |
91 |         )
92 |
93 |         started = time.perf_counter()
   |         ^^^^^^^
94 |         try:
95 |             raw_chunks = self._chunker.chunk(command)
   |

invalid-syntax: Expected ')', found newline
  --> src/Medical_KG_rev/gateway/coordinators/chunking.py:93:38
   |
91 |         )
92 |
93 |         started = time.perf_counter()
   |                                      ^
94 |         try:
95 |             raw_chunks = self._chunker.chunk(command)
   |

invalid-syntax: Expected a statement
   --> src/Medical_KG_rev/gateway/coordinators/chunking.py:336:33
    |
334 |             stage="chunk",
335 |         )
336 |         request: ChunkingRequest,
    |                                 ^
337 |         detail: ProblemDetail,
338 |         exc: Exception,
    |

invalid-syntax: Expected a statement
   --> src/Medical_KG_rev/gateway/coordinators/chunking.py:336:34
    |
334 |             stage="chunk",
335 |         )
336 |         request: ChunkingRequest,
    |                                  ^
337 |         detail: ProblemDetail,
338 |         exc: Exception,
    |

invalid-syntax: Expected a statement
   --> src/Medical_KG_rev/gateway/coordinators/chunking.py:337:30
    |
335 |         )
336 |         request: ChunkingRequest,
337 |         detail: ProblemDetail,
    |                              ^
338 |         exc: Exception,
339 |     ) -> None:
    |

invalid-syntax: Expected a statement
   --> src/Medical_KG_rev/gateway/coordinators/chunking.py:337:31
    |
335 |         )
336 |         request: ChunkingRequest,
337 |         detail: ProblemDetail,
    |                               ^
338 |         exc: Exception,
339 |     ) -> None:
    |

invalid-syntax: Expected a statement
   --> src/Medical_KG_rev/gateway/coordinators/chunking.py:338:23
    |
336 |         request: ChunkingRequest,
337 |         detail: ProblemDetail,
338 |         exc: Exception,
    |                       ^
339 |     ) -> None:
340 |         profile = None
    |

invalid-syntax: Expected a statement
   --> src/Medical_KG_rev/gateway/coordinators/chunking.py:338:24
    |
336 |         request: ChunkingRequest,
337 |         detail: ProblemDetail,
338 |         exc: Exception,
    |                        ^
339 |     ) -> None:
340 |         profile = None
    |

invalid-syntax: Expected a statement
   --> src/Medical_KG_rev/gateway/coordinators/chunking.py:339:5
    |
337 |         detail: ProblemDetail,
338 |         exc: Exception,
339 |     ) -> None:
    |     ^
340 |         profile = None
341 |         if isinstance(request.options, Mapping):
    |

invalid-syntax: Expected a statement
   --> src/Medical_KG_rev/gateway/coordinators/chunking.py:339:7
    |
337 |         detail: ProblemDetail,
338 |         exc: Exception,
339 |     ) -> None:
    |       ^^
340 |         profile = None
341 |         if isinstance(request.options, Mapping):
    |

invalid-syntax: Invalid annotated assignment target
   --> src/Medical_KG_rev/gateway/coordinators/chunking.py:339:10
    |
337 |         detail: ProblemDetail,
338 |         exc: Exception,
339 |     ) -> None:
    |          ^^^^
340 |         profile = None
341 |         if isinstance(request.options, Mapping):
    |

invalid-syntax: Expected an expression
   --> src/Medical_KG_rev/gateway/coordinators/chunking.py:339:15
    |
337 |         detail: ProblemDetail,
338 |         exc: Exception,
339 |     ) -> None:
    |               ^
340 |         profile = None
341 |         if isinstance(request.options, Mapping):
    |

invalid-syntax: Unexpected indentation
   --> src/Medical_KG_rev/gateway/coordinators/chunking.py:340:1
    |
338 |         exc: Exception,
339 |     ) -> None:
340 |         profile = None
    | ^^^^^^^^
341 |         if isinstance(request.options, Mapping):
342 |             raw_profile = request.options.get("profile")
    |

invalid-syntax: Expected a statement
   --> src/Medical_KG_rev/gateway/coordinators/chunking.py:349:1
    |
349 | __all__ = [
    | ^
350 |     "ChunkingCoordinator",
351 |     "ChunkingRequest",
    |

D101 Missing docstring in public class
  --> src/Medical_KG_rev/gateway/coordinators/embedding.py:36:7
   |
35 | @dataclass
36 | class EmbeddingRequest(CoordinatorRequest):
   |       ^^^^^^^^^^^^^^^^
37 |     namespace: str
38 |     texts: Sequence[str]
   |

D101 Missing docstring in public class
  --> src/Medical_KG_rev/gateway/coordinators/embedding.py:43:7
   |
42 | @dataclass
43 | class EmbeddingResult(CoordinatorResult):
   |       ^^^^^^^^^^^^^^^
44 |     response: EmbeddingResponse | None = None
   |

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/gateway/coordinators/embedding.py:50:9
   |
48 |     """Coordinate embedding requests including persistence and telemetry."""
49 |
50 |     def __init__(
   |         ^^^^^^^^
51 |         self,
52 |         lifecycle: JobLifecycleManager,
   |

D105 Missing docstring in magic method
  --> src/Medical_KG_rev/gateway/coordinators/job_lifecycle.py:31:9
   |
29 |     _retrying: Retrying = field(init=False, repr=False)
30 |
31 |     def __post_init__(self) -> None:
   |         ^^^^^^^^^^^^^
32 |         self._retrying = Retrying(
33 |             stop=stop_after_attempt(self.retry_attempts),
   |

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/gateway/coordinators/job_lifecycle.py:52:9
   |
50 |         job_id: str | None = None,
51 |     ) -> str:
52 |         """Create a job entry and emit the initial SSE event."""
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
53 |
54 |         job_id = job_id or f"job-{uuid.uuid4().hex[:12]}"
   |
help: Remove blank line(s) after function docstring

D102 Missing docstring in public method
  --> src/Medical_KG_rev/gateway/coordinators/job_lifecycle.py:84:9
   |
82 |         return job_id
83 |
84 |     def idempotent_create(
   |         ^^^^^^^^^^^^^^^^^
85 |         self,
86 |         *,
   |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/coordinators/job_lifecycle.py:108:9
    |
106 |         )
107 |
108 |     def mark_completed(self, job_id: str, payload: Mapping[str, Any] | None = None) -> None:
    |         ^^^^^^^^^^^^^^
109 |         metadata = dict(payload or {})
110 |         logger.info("gateway.job.complete", job_id=job_id, metadata=metadata)
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/coordinators/job_lifecycle.py:116:9
    |
114 |         )
115 |
116 |     def update_metadata(self, job_id: str, metadata: Mapping[str, Any]) -> None:
    |         ^^^^^^^^^^^^^^^
117 |         logger.debug("gateway.job.metadata", job_id=job_id, metadata=dict(metadata))
118 |         self._call_ledger(self.ledger.update_metadata, job_id, dict(metadata))
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/coordinators/job_lifecycle.py:120:9
    |
118 |         self._call_ledger(self.ledger.update_metadata, job_id, dict(metadata))
119 |
120 |     def mark_failed(
    |         ^^^^^^^^^^^
121 |         self,
122 |         job_id: str,
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/coordinators/job_lifecycle.py:145:9
    |
143 |         self.events.publish(JobEvent(job_id=job_id, type="jobs.failed", payload=payload))
144 |
145 |     def cancel(
    |         ^^^^^^
146 |         self,
147 |         job_id: str,
    |

D104 Missing docstring in public package
--> src/Medical_KG_rev/gateway/graphql/__init__.py:1:1

D101 Missing docstring in public class
  --> src/Medical_KG_rev/gateway/graphql/context.py:16:7
   |
15 | @dataclass(slots=True)
16 | class GraphQLContext(BaseContext):
   |       ^^^^^^^^^^^^^^
17 |     service: GatewayService
18 |     loaders: GraphQLLoaders
   |

D105 Missing docstring in magic method
  --> src/Medical_KG_rev/gateway/graphql/context.py:22:9
   |
20 |     scopes: set[str]
21 |
22 |     def __getitem__(self, key: str) -> Any:  # pragma: no cover - strawberry compatibility
   |         ^^^^^^^^^^^
23 |         if key == "tenant_id":
24 |             return self.tenant_id
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/gateway/graphql/context.py:29:9
   |
27 |         raise KeyError(key)
28 |
29 |     def has_scope(self, scope: str) -> bool:
   |         ^^^^^^^^^
30 |         return scope in self.scopes
   |

D103 Missing docstring in public function
  --> src/Medical_KG_rev/gateway/graphql/context.py:33:11
   |
33 | async def build_context(service: GatewayService, request: Request) -> GraphQLContext:
   |           ^^^^^^^^^^^^^
34 |     security_context = getattr(request.state, "security_context", None)
35 |     validated = getattr(request.state, "validated_tenant_id", None)
   |

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/gateway/graphql/loaders.py:16:9
   |
14 |     """Collection of lazily evaluated loaders shared via context."""
15 |
16 |     def __init__(self, service: GatewayService) -> None:
   |         ^^^^^^^^
17 |         self.service = service
18 |         self.document_loader: DataLoader[str, DocumentSummary] = DataLoader(self._load_documents)
   |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:157:7
    |
156 | @strawberry.type
157 | class OperationStatusType:
    |       ^^^^^^^^^^^^^^^^^^^
158 |     job_id: str
159 |     status: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:165:7
    |
164 | @strawberry.type
165 | class BatchOperationType:
    |       ^^^^^^^^^^^^^^^^^^
166 |     total: int
167 |     operations: list[OperationStatusType]
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:171:7
    |
170 | @strawberry.type
171 | class AdapterMetadataType:
    |       ^^^^^^^^^^^^^^^^^^^
172 |     name: str
173 |     version: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:183:7
    |
182 | @strawberry.type
183 | class AdapterHealthType:
    |       ^^^^^^^^^^^^^^^^^
184 |     name: str
185 |     healthy: bool
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:189:7
    |
188 | @strawberry.type
189 | class OrganizationType:
    |       ^^^^^^^^^^^^^^^^
190 |     id: str
191 |     name: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:196:7
    |
195 | @strawberry.type
196 | class ClaimType:
    |       ^^^^^^^^^
197 |     id: str
198 |     predicate: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:203:7
    |
202 | @strawberry.type
203 | class DocumentType:
    |       ^^^^^^^^^^^^
204 |     id: str
205 |     title: str
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/graphql/schema.py:213:15
    |
212 |     @strawberry.field
213 |     async def organization(
    |               ^^^^^^^^^^^^
214 |         self, info: Info[GraphQLContext, None], id: str | None = None
215 |     ) -> OrganizationType:
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/graphql/schema.py:221:15
    |
220 |     @strawberry.field
221 |     async def claims(self, info: Info[GraphQLContext, None]) -> list[ClaimType]:
    |               ^^^^^^
222 |         # Return synthetic claims derived from document id
223 |         return [
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:229:7
    |
228 | @strawberry.type
229 | class RetrievalResultType:
    |       ^^^^^^^^^^^^^^^^^^^
230 |     query: str
231 |     total: int
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:243:7
    |
242 | @strawberry.type
243 | class ProblemDetailType:
    |       ^^^^^^^^^^^^^^^^^
244 |     type: str
245 |     title: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:252:7
    |
251 | @strawberry.type
252 | class EmbeddingVectorType:
    |       ^^^^^^^^^^^^^^^^^^^
253 |     id: str
254 |     model: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:264:7
    |
263 | @strawberry.type
264 | class EmbeddingMetadataType:
    |       ^^^^^^^^^^^^^^^^^^^^^
265 |     provider: str
266 |     dimension: int | None
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:272:7
    |
271 | @strawberry.type
272 | class EmbeddingResultType:
    |       ^^^^^^^^^^^^^^^^^^^
273 |     namespace: str
274 |     embeddings: list[EmbeddingVectorType]
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:279:7
    |
278 | @strawberry.type
279 | class DocumentChunkType:
    |       ^^^^^^^^^^^^^^^^^
280 |     document_id: str
281 |     chunk_index: int
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:288:7
    |
287 | @strawberry.type
288 | class ExtractionResultType:
    |       ^^^^^^^^^^^^^^^^^^^^
289 |     kind: str
290 |     document_id: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:295:7
    |
294 | @strawberry.type
295 | class KnowledgeGraphWriteResultType:
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
296 |     nodes_written: int
297 |     edges_written: int
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:302:7
    |
301 | @strawberry.type
302 | class NamespaceInfoType:
    |       ^^^^^^^^^^^^^^^^^
303 |     id: str
304 |     provider: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:314:7
    |
313 | @strawberry.input
314 | class PaginationInput:
    |       ^^^^^^^^^^^^^^^
315 |     after: str | None = None
316 |     first: int = 10
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:320:7
    |
319 | @strawberry.input
320 | class SearchInput:
    |       ^^^^^^^^^^^
321 |     query: str
322 |     filters: JSON = strawberry.field(default_factory=dict)
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:329:7
    |
328 | @strawberry.input
329 | class IngestionInput:
    |       ^^^^^^^^^^^^^^
330 |     tenant_id: str
331 |     items: JSON
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:338:7
    |
337 | @strawberry.input
338 | class ChunkInput:
    |       ^^^^^^^^^^
339 |     tenant_id: str
340 |     document_id: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:346:7
    |
345 | @strawberry.input
346 | class EmbedInput:
    |       ^^^^^^^^^^
347 |     tenant_id: str | None = None
348 |     namespace: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:354:7
    |
353 | @strawberry.input
354 | class EmbeddingOptionsInput:
    |       ^^^^^^^^^^^^^^^^^^^^^
355 |     normalize: bool = True
356 |     model: str | None = None
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:360:7
    |
359 | @strawberry.input
360 | class RetrieveInput:
    |       ^^^^^^^^^^^^^
361 |     tenant_id: str
362 |     query: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:377:7
    |
376 | @strawberry.input
377 | class EntityLinkInput:
    |       ^^^^^^^^^^^^^^^
378 |     tenant_id: str
379 |     mentions: list[str]
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:384:7
    |
383 | @strawberry.input
384 | class ExtractionInput:
    |       ^^^^^^^^^^^^^^^
385 |     tenant_id: str
386 |     document_id: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:391:7
    |
390 | @strawberry.input
391 | class KnowledgeGraphWriteInput:
    |       ^^^^^^^^^^^^^^^^^^^^^^^^
392 |     tenant_id: str
393 |     nodes: JSON = strawberry.field(default=None)
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:409:7
    |
408 | @strawberry.type
409 | class Query:
    |       ^^^^^
410 |     @strawberry.field
411 |     async def adapters(
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/graphql/schema.py:411:15
    |
409 | class Query:
410 |     @strawberry.field
411 |     async def adapters(
    |               ^^^^^^^^
412 |         self, info: Info[GraphQLContext, None], domain: str | None = None
413 |     ) -> list[AdapterMetadataType]:
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/graphql/schema.py:422:15
    |
421 |     @strawberry.field
422 |     async def adapter(
    |               ^^^^^^^
423 |         self, info: Info[GraphQLContext, None], name: str
424 |     ) -> AdapterMetadataType | None:
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/graphql/schema.py:432:15
    |
431 |     @strawberry.field
432 |     async def namespaces(
    |               ^^^^^^^^^^
433 |         self, info: Info[GraphQLContext, None], tenant_id: str | None = None
434 |     ) -> list[NamespaceInfoType]:
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/graphql/schema.py:441:15
    |
440 |     @strawberry.field
441 |     async def namespace(
    |               ^^^^^^^^^
442 |         self, info: Info[GraphQLContext, None], id: str, tenant_id: str | None = None
443 |     ) -> NamespaceInfoType | None:
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/graphql/schema.py:453:15
    |
452 |     @strawberry.field
453 |     async def adapter_health(
    |               ^^^^^^^^^^^^^^
454 |         self, info: Info[GraphQLContext, None], name: str
455 |     ) -> AdapterHealthType | None:
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/graphql/schema.py:463:15
    |
462 |     @strawberry.field
463 |     async def document(self, info: Info[GraphQLContext, None], id: ID) -> DocumentType:
    |               ^^^^^^^^
464 |         service = await _get_service(info)
465 |         doc = await info.context.loaders.document_loader.load(str(id))
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/graphql/schema.py:469:15
    |
468 |     @strawberry.field
469 |     async def organization(self, info: Info[GraphQLContext, None], id: str) -> OrganizationType:
    |               ^^^^^^^^^^^^
470 |         data = await info.context.loaders.organization_loader.load(id)
471 |         return OrganizationType(id=data["id"], name=data["name"], country=data["country"])
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/graphql/schema.py:474:15
    |
473 |     @strawberry.field
474 |     async def search(
    |               ^^^^^^
475 |         self, info: Info[GraphQLContext, None], arguments: SearchInput
476 |     ) -> RetrievalResultType:
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/graphql/schema.py:490:7
    |
489 | @strawberry.type
490 | class Mutation:
    |       ^^^^^^^^
491 |     @strawberry.mutation
492 |     async def ingest(
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/graphql/schema.py:492:15
    |
490 | class Mutation:
491 |     @strawberry.mutation
492 |     async def ingest(
    |               ^^^^^^
493 |         self, info: Info[GraphQLContext, None], dataset: str, input: IngestionInput
494 |     ) -> BatchOperationType:
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/graphql/schema.py:510:15
    |
509 |     @strawberry.mutation
510 |     async def chunk(
    |               ^^^^^
511 |         self, info: Info[GraphQLContext, None], input: ChunkInput
512 |     ) -> list[DocumentChunkType]:
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/graphql/schema.py:518:15
    |
517 |     @strawberry.mutation
518 |     async def embed(
    |               ^^^^^
519 |         self, info: Info[GraphQLContext, None], input: EmbedInput
520 |     ) -> EmbeddingResultType:
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/graphql/schema.py:538:15
    |
537 |     @strawberry.mutation
538 |     async def retrieve(
    |               ^^^^^^^^
539 |         self, info: Info[GraphQLContext, None], input: RetrieveInput
540 |     ) -> RetrievalResultType:
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/graphql/schema.py:547:15
    |
546 |     @strawberry.mutation
547 |     async def entity_link(
    |               ^^^^^^^^^^^
548 |         self, info: Info[GraphQLContext, None], input: EntityLinkInput
549 |     ) -> BatchOperationType:
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/graphql/schema.py:567:15
    |
566 |     @strawberry.mutation
567 |     async def extract(
    |               ^^^^^^^
568 |         self, info: Info[GraphQLContext, None], kind: str, input: ExtractionInput
569 |     ) -> ExtractionResultType:
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/graphql/schema.py:578:15
    |
577 |     @strawberry.mutation
578 |     async def write_kg(
    |               ^^^^^^^^
579 |         self,
580 |         info: Info[GraphQLContext, None],
    |

D103 Missing docstring in public function
   --> src/Medical_KG_rev/gateway/graphql/schema.py:604:11
    |
604 | async def get_context(request: Request) -> GraphQLContext:
    |           ^^^^^^^^^^^
605 |     service = get_gateway_service()
606 |     return await build_context(service, request)
    |

D104 Missing docstring in public package
--> src/Medical_KG_rev/gateway/grpc/__init__.py:1:1

D101 Missing docstring in public class
  --> src/Medical_KG_rev/gateway/grpc/server.py:74:7
   |
74 | class MineruService(mineru_pb2_grpc.MineruServiceServicer if mineru_pb2_grpc else object):
   |       ^^^^^^^^^^^^^
75 |     def __init__(self, service: GatewayService) -> None:
76 |         self.service = service
   |

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/gateway/grpc/server.py:75:9
   |
74 | class MineruService(mineru_pb2_grpc.MineruServiceServicer if mineru_pb2_grpc else object):
75 |     def __init__(self, service: GatewayService) -> None:
   |         ^^^^^^^^
76 |         self.service = service
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/gateway/grpc/server.py:78:15
   |
76 |         self.service = service
77 |
78 |     async def ProcessPdf(self, request, context):  # type: ignore[override]
   |               ^^^^^^^^^^
79 |         chunk_request = ChunkRequest(tenant_id=request.tenant_id, document_id=request.document_id)
80 |         chunks = self.service.chunk_document(chunk_request)
   |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/grpc/server.py:104:15
    |
102 |         return response
103 |
104 |     async def BatchProcessPdf(self, request, context):  # type: ignore[override]
    |               ^^^^^^^^^^^^^^^
105 |         if mineru_pb2 is None:
106 |             return None
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/grpc/server.py:119:7
    |
119 | class EmbeddingService(
    |       ^^^^^^^^^^^^^^^^
120 |     embedding_pb2_grpc.EmbeddingServiceServicer if embedding_pb2_grpc else object
121 | ):
    |

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/gateway/grpc/server.py:122:9
    |
120 |     embedding_pb2_grpc.EmbeddingServiceServicer if embedding_pb2_grpc else object
121 | ):
122 |     def __init__(self, service: GatewayService) -> None:
    |         ^^^^^^^^
123 |         self.service = service
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/grpc/server.py:125:15
    |
123 |         self.service = service
124 |
125 |     async def Embed(self, request, context):  # type: ignore[override]
    |               ^^^^^
126 |         embed_request = EmbedRequest(
127 |             tenant_id=request.tenant_id,
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/grpc/server.py:158:15
    |
156 |         return response
157 |
158 |     async def ListNamespaces(self, request, context):  # type: ignore[override]
    |               ^^^^^^^^^^^^^^
159 |         if embedding_pb2 is None:
160 |             return None
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/grpc/server.py:180:15
    |
178 |         return response
179 |
180 |     async def ValidateTexts(self, request, context):  # type: ignore[override]
    |               ^^^^^^^^^^^^^
181 |         if embedding_pb2 is None:
182 |             return None
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/grpc/server.py:201:7
    |
201 | class ExtractionService(
    |       ^^^^^^^^^^^^^^^^^
202 |     extraction_pb2_grpc.ExtractionServiceServicer if extraction_pb2_grpc else object
203 | ):
    |

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/gateway/grpc/server.py:204:9
    |
202 |     extraction_pb2_grpc.ExtractionServiceServicer if extraction_pb2_grpc else object
203 | ):
204 |     def __init__(self, service: GatewayService) -> None:
    |         ^^^^^^^^
205 |         self.service = service
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/grpc/server.py:207:15
    |
205 |         self.service = service
206 |
207 |     async def Extract(self, request, context):  # type: ignore[override]
    |               ^^^^^^^
208 |         extraction_request = ExtractionRequest(
209 |             tenant_id=request.tenant_id,
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/grpc/server.py:224:7
    |
224 | class IngestionService(
    |       ^^^^^^^^^^^^^^^^
225 |     ingestion_pb2_grpc.IngestionServiceServicer if ingestion_pb2_grpc else object
226 | ):
    |

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/gateway/grpc/server.py:227:9
    |
225 |     ingestion_pb2_grpc.IngestionServiceServicer if ingestion_pb2_grpc else object
226 | ):
227 |     def __init__(self, service: GatewayService) -> None:
    |         ^^^^^^^^
228 |         self.service = service
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/grpc/server.py:230:15
    |
228 |         self.service = service
229 |
230 |     async def Submit(self, request, context):  # type: ignore[override]
    |               ^^^^^^
231 |         options_payload: dict[str, Any] | None = None
232 |         if hasattr(request, "options") and request.HasField("options"):
    |

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/gateway/grpc/server.py:270:9
    |
268 |     """Wrapper that registers all gateway services with a grpc.aio server."""
269 |
270 |     def __init__(self, service: GatewayService | None = None) -> None:
    |         ^^^^^^^^
271 |         self.service = service or get_gateway_service()
272 |         self._server: grpc.aio.Server | None = None
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/grpc/server.py:274:15
    |
272 |         self._server: grpc.aio.Server | None = None
273 |
274 |     async def start(self, host: str = "0.0.0.0", port: int = 50051) -> None:
    |               ^^^^^
275 |         self._server = grpc.aio.server()
276 |         if mineru_pb2_grpc:
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/grpc/server.py:300:15
    |
298 |         await self._server.start()
299 |
300 |     async def wait_for_termination(self) -> None:
    |               ^^^^^^^^^^^^^^^^^^^^
301 |         if self._server is None:
302 |             return
    |

D103 Missing docstring in public function
   --> src/Medical_KG_rev/gateway/grpc/server.py:306:11
    |
306 | async def serve() -> None:
    |           ^^^^^
307 |     server = GatewayGrpcServer()
308 |     await server.start()
    |

D103 Missing docstring in public function
  --> src/Medical_KG_rev/gateway/main.py:46:5
   |
46 | def export_openapi() -> str:
   |     ^^^^^^^^^^^^^^
47 |     app = create_app()
48 |     openapi_schema: dict[str, Any] = app.openapi()
   |

D103 Missing docstring in public function
  --> src/Medical_KG_rev/gateway/main.py:52:5
   |
52 | def export_graphql() -> str:
   |     ^^^^^^^^^^^^^^
53 |     return schema.as_str()
   |

D103 Missing docstring in public function
  --> src/Medical_KG_rev/gateway/main.py:56:5
   |
56 | def export_asyncapi() -> str:
   |     ^^^^^^^^^^^^^^^
57 |     return ASYNCAPI_TEMPLATE
   |

D103 Missing docstring in public function
  --> src/Medical_KG_rev/gateway/main.py:60:5
   |
60 | def main() -> None:
   |     ^^^^
61 |     parser = argparse.ArgumentParser(description="Gateway helper utilities")
62 |     parser.add_argument("--export-openapi", action="store_true", help="Print OpenAPI document")
   |

D101 Missing docstring in public class
  --> src/Medical_KG_rev/gateway/middleware.py:18:7
   |
17 | @dataclass(frozen=True)
18 | class CachePolicy:
   |       ^^^^^^^^^^^
19 |     ttl: int = 300
20 |     scope: str = "private"
   |

D101 Missing docstring in public class
  --> src/Medical_KG_rev/gateway/middleware.py:27:7
   |
26 | @dataclass
27 | class CacheEntry:
   |       ^^^^^^^^^^
28 |     etag: str
29 |     expires_at: float
   |

D101 Missing docstring in public class
  --> src/Medical_KG_rev/gateway/middleware.py:33:7
   |
33 | class ResponseCache:
   |       ^^^^^^^^^^^^^
34 |     def __init__(self) -> None:
35 |         self._entries: MutableMapping[str, CacheEntry] = {}
   |

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/gateway/middleware.py:34:9
   |
33 | class ResponseCache:
34 |     def __init__(self) -> None:
   |         ^^^^^^^^
35 |         self._entries: MutableMapping[str, CacheEntry] = {}
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/gateway/middleware.py:37:9
   |
35 |         self._entries: MutableMapping[str, CacheEntry] = {}
36 |
37 |     def get(self, key: str) -> CacheEntry | None:
   |         ^^^
38 |         entry = self._entries.get(key)
39 |         if not entry:
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/gateway/middleware.py:46:9
   |
44 |         return entry
45 |
46 |     def set(self, key: str, entry: CacheEntry) -> None:
   |         ^^^
47 |         self._entries[key] = entry
   |

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/gateway/middleware.py:53:9
   |
51 |     """Implements ETag generation and cache headers for GET endpoints."""
52 |
53 |     def __init__(
   |         ^^^^^^^^
54 |         self,
55 |         app,
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/gateway/middleware.py:66:15
   |
64 |         self._cache = cache_backend or ResponseCache()
65 |
66 |     async def dispatch(self, request: Request, call_next):  # type: ignore[override]
   |               ^^^^^^^^
67 |         method = request.method.upper()
68 |         if method not in {"GET", "HEAD"}:
   |

D101 Missing docstring in public class
  --> src/Medical_KG_rev/gateway/models.py:28:7
   |
28 | class BatchError(BaseModel):
   |       ^^^^^^^^^^
29 |     code: str
30 |     message: str
   |

D101 Missing docstring in public class
  --> src/Medical_KG_rev/gateway/models.py:69:7
   |
69 | class AdapterHealthView(BaseModel):
   |       ^^^^^^^^^^^^^^^^^
70 |     name: str
71 |     healthy: bool
   |

D101 Missing docstring in public class
  --> src/Medical_KG_rev/gateway/models.py:74:7
   |
74 | class AdapterConfigSchemaView(BaseModel):
   |       ^^^^^^^^^^^^^^^^^^^^^^^
75 |     name: str
76 |     schema: dict[str, Any]
   |

D101 Missing docstring in public class
  --> src/Medical_KG_rev/gateway/models.py:79:7
   |
79 | class DocumentChunk(BaseModel):
   |       ^^^^^^^^^^^^^
80 |     document_id: str
81 |     chunk_index: int
   |

D101 Missing docstring in public class
  --> src/Medical_KG_rev/gateway/models.py:87:7
   |
87 | class EmbeddingVector(BaseModel):
   |       ^^^^^^^^^^^^^^^
88 |     id: str
89 |     model: str
   |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:98:7
    |
 98 | class DocumentSummary(BaseModel):
    |       ^^^^^^^^^^^^^^^
 99 |     id: str
100 |     title: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:108:7
    |
108 | class RetrievalResult(BaseModel):
    |       ^^^^^^^^^^^^^^^
109 |     query: str
110 |     documents: Sequence[DocumentSummary]
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:121:7
    |
121 | class EntityLinkResult(BaseModel):
    |       ^^^^^^^^^^^^^^^^
122 |     mention: str
123 |     entity_id: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:128:7
    |
128 | class ExtractionResult(BaseModel):
    |       ^^^^^^^^^^^^^^^^
129 |     kind: str
130 |     document_id: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:134:7
    |
134 | class KnowledgeGraphWriteResult(BaseModel):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^
135 |     nodes_written: int
136 |     edges_written: int
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:140:7
    |
140 | class GraphNode(BaseModel):
    |       ^^^^^^^^^
141 |     id: str
142 |     label: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:146:7
    |
146 | class GraphEdge(BaseModel):
    |       ^^^^^^^^^
147 |     type: str
148 |     start: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:153:7
    |
153 | class IngestionRequest(BaseModel):
    |       ^^^^^^^^^^^^^^^^
154 |     tenant_id: str
155 |     items: Sequence[dict[str, Any]]
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:162:7
    |
162 | class PipelineIngestionRequest(IngestionRequest):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^
163 |     dataset: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:166:7
    |
166 | class ChunkRequest(BaseModel):
    |       ^^^^^^^^^^^^
167 |     tenant_id: str
168 |     document_id: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:190:7
    |
190 | class EmbeddingOptions(BaseModel):
    |       ^^^^^^^^^^^^^^^^
191 |     normalize: bool = True
192 |     model: str | None = None
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:195:7
    |
195 | class EmbedRequest(BaseModel):
    |       ^^^^^^^^^^^^
196 |     tenant_id: str
197 |     texts: Sequence[str]
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:202:7
    |
202 | class EmbeddingMetadata(BaseModel):
    |       ^^^^^^^^^^^^^^^^^
203 |     provider: str
204 |     dimension: int | None = None
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:209:7
    |
209 | class EmbeddingResponse(BaseModel):
    |       ^^^^^^^^^^^^^^^^^
210 |     namespace: str
211 |     embeddings: Sequence[EmbeddingVector]
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:215:7
    |
215 | class NamespaceInfo(BaseModel):
    |       ^^^^^^^^^^^^^
216 |     id: str
217 |     provider: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:226:7
    |
226 | class NamespaceValidationResult(BaseModel):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^
227 |     text_index: int
228 |     token_count: int
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:233:7
    |
233 | class NamespaceValidationResponse(BaseModel):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
234 |     namespace: str
235 |     valid: bool
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:239:7
    |
239 | class NamespaceValidationRequest(BaseModel):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^
240 |     tenant_id: str
241 |     texts: Sequence[str] = Field(default_factory=list)
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:244:7
    |
244 | class NamespacePolicySettingsView(BaseModel):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
245 |     cache_ttl_seconds: float = Field(default=60.0, ge=0.0)
246 |     max_cache_entries: int = Field(default=512, ge=1)
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:250:7
    |
250 | class NamespacePolicyStatus(BaseModel):
    |       ^^^^^^^^^^^^^^^^^^^^^
251 |     settings: NamespacePolicySettingsView
252 |     stats: dict[str, Any] = Field(default_factory=dict)
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:256:7
    |
256 | class NamespacePolicyUpdateRequest(BaseModel):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
257 |     cache_ttl_seconds: float | None = Field(default=None, ge=0.0)
258 |     max_cache_entries: int | None = Field(default=None, ge=1)
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:262:7
    |
262 | class NamespacePolicyDiagnosticsView(BaseModel):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
263 |     settings: NamespacePolicySettingsView
264 |     cache_keys: list[str] = Field(default_factory=list)
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:268:7
    |
268 | class NamespacePolicyHealthView(BaseModel):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^
269 |     policy: str
270 |     evaluations: int
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:275:7
    |
275 | class NamespacePolicyMetricsView(BaseModel):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^
276 |     metrics: dict[str, Any] = Field(default_factory=dict)
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:279:7
    |
279 | class NamespacePolicyInvalidateRequest(BaseModel):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
280 |     namespace: str | None = None
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:283:7
    |
283 | class RetrieveRequest(BaseModel):
    |       ^^^^^^^^^^^^^^^
284 |     tenant_id: str
285 |     query: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:299:7
    |
299 | class PipelineQueryRequest(RetrieveRequest):
    |       ^^^^^^^^^^^^^^^^^^^^
300 |     profile: str | None = None
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:303:7
    |
303 | class EntityLinkRequest(BaseModel):
    |       ^^^^^^^^^^^^^^^^^
304 |     tenant_id: str
305 |     mentions: Sequence[str]
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:309:7
    |
309 | class ExtractionRequest(BaseModel):
    |       ^^^^^^^^^^^^^^^^^
310 |     tenant_id: str
311 |     document_id: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:315:7
    |
315 | class EvaluationRelevantDoc(BaseModel):
    |       ^^^^^^^^^^^^^^^^^^^^^
316 |     doc_id: str
317 |     grade: float = Field(ge=0.0, le=3.0)
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:320:7
    |
320 | class EvaluationQuery(BaseModel):
    |       ^^^^^^^^^^^^^^^
321 |     query_id: str
322 |     query_text: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:328:7
    |
328 | class EvaluationRequest(BaseModel):
    |       ^^^^^^^^^^^^^^^^^
329 |     tenant_id: str
330 |     test_set_name: str | None = None
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:350:7
    |
350 | class MetricSummaryView(BaseModel):
    |       ^^^^^^^^^^^^^^^^^
351 |     mean: float
352 |     median: float
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/models.py:358:9
    |
357 |     @classmethod
358 |     def from_metric(cls, summary: MetricSummary) -> "MetricSummaryView":
    |         ^^^^^^^^^^^
359 |         return cls(
360 |             mean=summary.mean,
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:368:7
    |
368 | class EvaluationResponse(BaseModel):
    |       ^^^^^^^^^^^^^^^^^^
369 |     dataset: str
370 |     test_set_version: str
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/models.py:379:9
    |
378 |     @classmethod
379 |     def from_result(cls, result: EvaluationResult) -> "EvaluationResponse":
    |         ^^^^^^^^^^^
380 |         metrics = {name: MetricSummaryView.from_metric(summary) for name, summary in result.metrics.items()}
381 |         latency = MetricSummaryView.from_metric(result.latency)
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:395:7
    |
395 | class KnowledgeGraphWriteRequest(BaseModel):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^
396 |     tenant_id: str
397 |     nodes: Sequence[GraphNode] = Field(default_factory=list)
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:402:7
    |
402 | class JobEvent(BaseModel):
    |       ^^^^^^^^
403 |     job_id: str
404 |     type: Literal[
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:414:7
    |
414 | class JobHistoryEntry(BaseModel):
    |       ^^^^^^^^^^^^^^^
415 |     from_status: str
416 |     to_status: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:422:7
    |
422 | class JobStatus(BaseModel):
    |       ^^^^^^^^^
423 |     job_id: str
424 |     doc_key: str
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/gateway/models.py:443:7
    |
443 | class SearchArguments(BaseModel):
    |       ^^^^^^^^^^^^^^^
444 |     query: str
445 |     filters: dict[str, Any] = Field(default_factory=dict)
    |

D103 Missing docstring in public function
   --> src/Medical_KG_rev/gateway/models.py:451:5
    |
451 | def build_batch_result(statuses: Iterable[OperationStatus]) -> BatchOperationResult:
    |     ^^^^^^^^^^^^^^^^^^
452 |     items = list(statuses)
453 |     succeeded = sum(
    |

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/gateway/presentation/dependencies.py:24:5
   |
23 | def get_response_presenter() -> ResponsePresenter:
24 |     """Return the default response presenter instance."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
25 |
26 |     settings = get_settings()
   |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/gateway/presentation/dependencies.py:32:5
   |
31 | def get_request_lifecycle(request: Request) -> RequestLifecycle:
32 |     """Expose the lifecycle tracker bound by the middleware."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
33 |
34 |     lifecycle = getattr(request.state, "lifecycle", None) or current_lifecycle()
   |
help: Remove blank line(s) after function docstring

D102 Missing docstring in public method
  --> src/Medical_KG_rev/gateway/presentation/errors.py:19:9
   |
17 |     meta: Mapping[str, Any] = field(default_factory=dict)
18 |
19 |     def as_json(self) -> dict[str, Any]:
   |         ^^^^^^^
20 |         payload = {
21 |             "status": str(self.status),
   |

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/gateway/presentation/jsonapi.py:36:9
   |
34 |     media_type = JSONAPI_CONTENT_TYPE
35 |
36 |     def __init__(self, *, correlation_header: str = "X-Correlation-ID") -> None:
   |         ^^^^^^^^
37 |         self._correlation_header = correlation_header
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/gateway/presentation/jsonapi.py:82:9
   |
80 |         return payload
81 |
82 |     def success(
   |         ^^^^^^^
83 |         self,
84 |         data: Any,
   |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/presentation/jsonapi.py:120:9
    |
118 |         )
119 |
120 |     def error(
    |         ^^^^^
121 |         self,
122 |         detail: Any,
    |

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/gateway/presentation/lifecycle.py:46:9
   |
45 |     def complete(self, status_code: int) -> None:
46 |         """Record a successful response if not already completed."""
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
47 |
48 |         if self.status_code is not None:
   |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/gateway/presentation/lifecycle.py:56:9
   |
55 |     def fail(self, exc: BaseException, *, status_code: int = 500) -> None:
56 |         """Record an error outcome for the request."""
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
57 |
58 |         self.error = str(exc)
   |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/gateway/presentation/lifecycle.py:63:9
   |
61 |     @property
62 |     def duration_seconds(self) -> float:
63 |         """Return the elapsed time since the lifecycle started."""
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
64 |
65 |         end = self.finished_at or perf_counter()
   |
help: Remove blank line(s) after function docstring

D102 Missing docstring in public method
  --> src/Medical_KG_rev/gateway/presentation/lifecycle.py:69:9
   |
68 |     @property
69 |     def duration_ms(self) -> float:
   |         ^^^^^^^^^^^
70 |         return self.duration_seconds * 1000
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/gateway/presentation/lifecycle.py:72:9
   |
70 |         return self.duration_seconds * 1000
71 |
72 |     def set_cache_control(self, value: str | None) -> None:
   |         ^^^^^^^^^^^^^^^^^
73 |         if value:
74 |             self.cache_control = value
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/gateway/presentation/lifecycle.py:76:9
   |
74 |             self.cache_control = value
75 |
76 |     def set_compression(self, encoding: str | None) -> None:
   |         ^^^^^^^^^^^^^^^
77 |         if encoding:
78 |             self.compression = encoding
   |

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/gateway/presentation/lifecycle.py:81:9
   |
80 |     def apply(self, response: Response, *, correlation_header: str | None) -> None:
81 |         """Apply lifecycle metadata to the outbound response headers."""
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
82 |
83 |         if correlation_header:
   |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/gateway/presentation/lifecycle.py:92:9
   |
91 |     def meta(self, extra: Mapping[str, object] | None = None) -> dict[str, object]:
92 |         """Return a metadata dictionary enriched with correlation details."""
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
93 |
94 |         payload: dict[str, object] = {
   |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
   --> src/Medical_KG_rev/gateway/presentation/lifecycle.py:104:5
    |
103 | def current_lifecycle() -> RequestLifecycle | None:
104 |     """Return the lifecycle bound to the current context, if any."""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
105 |
106 |     return _CURRENT_LIFECYCLE.get()
    |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
   --> src/Medical_KG_rev/gateway/presentation/lifecycle.py:110:5
    |
109 | def push_lifecycle(lifecycle: RequestLifecycle) -> Token:
110 |     """Bind a lifecycle object to the current context."""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
111 |
112 |     return _CURRENT_LIFECYCLE.set(lifecycle)
    |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
   --> src/Medical_KG_rev/gateway/presentation/lifecycle.py:116:5
    |
115 | def pop_lifecycle(token: Token) -> None:
116 |     """Reset the context variable token captured via :func:`push_lifecycle`."""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
117 |
118 |     _CURRENT_LIFECYCLE.reset(token)
    |
help: Remove blank line(s) after function docstring

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/gateway/presentation/lifecycle.py:124:9
    |
122 |     """FastAPI middleware that binds lifecycle information to each request."""
123 |
124 |     def __init__(self, app, *, correlation_header: str | None = None):  # type: ignore[override]
    |         ^^^^^^^^
125 |         super().__init__(app)
126 |         self._correlation_header = correlation_header or "X-Correlation-ID"
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/gateway/presentation/lifecycle.py:128:15
    |
126 |         self._correlation_header = correlation_header or "X-Correlation-ID"
127 |
128 |     async def dispatch(self, request: Request, call_next):  # type: ignore[override]
    |               ^^^^^^^^
129 |         provided = request.headers.get(self._correlation_header)
130 |         correlation_id = provided or getattr(request.state, "correlation_id", None)
    |

D101 Missing docstring in public class
  --> src/Medical_KG_rev/gateway/presentation/odata.py:12:7
   |
11 | @dataclass(slots=True)
12 | class ODataParams:
   |       ^^^^^^^^^^^
13 |     select: list[str] | None = None
14 |     expand: list[str] | None = None
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/gateway/presentation/odata.py:20:9
   |
19 |     @classmethod
20 |     def from_request(cls, request: Request) -> ODataParams:
   |         ^^^^^^^^^^^^
21 |         params: dict[str, Any] = {}
22 |         qp = request.query_params
   |

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/gateway/presentation/requests.py:20:5
   |
18 |     http_request: Request | None = None,
19 | ) -> TModel:
20 |     """Ensure request payloads inherit the authenticated tenant context."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
21 |
22 |     tenant_id = getattr(request_model, "tenant_id", None)
   |
help: Remove blank line(s) after function docstring

D104 Missing docstring in public package
--> src/Medical_KG_rev/gateway/rest/__init__.py:1:1

invalid-syntax: Parameter without a default cannot follow a parameter with a default
  --> src/Medical_KG_rev/gateway/rest/router.py:64:5
   |
62 |         secure_endpoint(scopes=[Scopes.ADAPTERS_READ], endpoint="GET /v1/adapters")
63 |     ),
64 |     presenter: PresenterDep,
   |     ^^^^^^^^^^^^^^^^^^^^^^^
65 |     lifecycle: LifecycleDep,
66 | ) -> Response:
   |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
  --> src/Medical_KG_rev/gateway/rest/router.py:65:5
   |
63 |     ),
64 |     presenter: PresenterDep,
65 |     lifecycle: LifecycleDep,
   |     ^^^^^^^^^^^^^^^^^^^^^^^
66 | ) -> Response:
67 |     try:
   |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
  --> src/Medical_KG_rev/gateway/rest/router.py:88:5
   |
86 |         secure_endpoint(scopes=[Scopes.ADAPTERS_READ], endpoint="GET /v1/adapters/{name}/metadata")
87 |     ),
88 |     presenter: PresenterDep,
   |     ^^^^^^^^^^^^^^^^^^^^^^^
89 |     lifecycle: LifecycleDep,
90 | ) -> Response:
   |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
  --> src/Medical_KG_rev/gateway/rest/router.py:89:5
   |
87 |     ),
88 |     presenter: PresenterDep,
89 |     lifecycle: LifecycleDep,
   |     ^^^^^^^^^^^^^^^^^^^^^^^
90 | ) -> Response:
91 |     metadata = service.get_adapter_metadata(name)
   |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:112:5
    |
110 |         secure_endpoint(scopes=[Scopes.ADAPTERS_READ], endpoint="GET /v1/adapters/{name}/health")
111 |     ),
112 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
113 |     lifecycle: LifecycleDep,
114 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:113:5
    |
111 |     ),
112 |     presenter: PresenterDep,
113 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
114 | ) -> Response:
115 |     health = service.get_adapter_health(name)
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:138:5
    |
136 |         )
137 |     ),
138 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
139 |     lifecycle: LifecycleDep,
140 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:139:5
    |
137 |     ),
138 |     presenter: PresenterDep,
139 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
140 | ) -> Response:
141 |     schema = service.get_adapter_config_schema(name)
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:192:5
    |
190 |     ),
191 |     service: GatewayService = Depends(get_gateway_service),
192 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
193 |     lifecycle: LifecycleDep,
194 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:193:5
    |
191 |     service: GatewayService = Depends(get_gateway_service),
192 |     presenter: PresenterDep,
193 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
194 | ) -> Response:
195 |     request = _apply_tenant(request, security, http_request)  # type: ignore[assignment]
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:215:5
    |
213 |     ),
214 |     service: GatewayService = Depends(get_gateway_service),
215 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
216 |     lifecycle: LifecycleDep,
217 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:216:5
    |
214 |     service: GatewayService = Depends(get_gateway_service),
215 |     presenter: PresenterDep,
216 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
217 | ) -> Response:
218 |     request = _apply_tenant(request, security, http_request)  # type: ignore[assignment]
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:249:5
    |
247 |     ),
248 |     service: GatewayService = Depends(get_gateway_service),
249 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
250 |     lifecycle: LifecycleDep,
251 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:250:5
    |
248 |     service: GatewayService = Depends(get_gateway_service),
249 |     presenter: PresenterDep,
250 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
251 | ) -> Response:
252 |     job = service.get_job(job_id, tenant_id=security.tenant_id)
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:300:5
    |
298 |     ),
299 |     service: GatewayService = Depends(get_gateway_service),
300 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
301 |     lifecycle: LifecycleDep,
302 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:301:5
    |
299 |     service: GatewayService = Depends(get_gateway_service),
300 |     presenter: PresenterDep,
301 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
302 | ) -> Response:
303 |     jobs = service.list_jobs(status=status, tenant_id=security.tenant_id)
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:315:5
    |
313 |     ),
314 |     service: GatewayService = Depends(get_gateway_service),
315 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
316 |     lifecycle: LifecycleDep,
317 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:316:5
    |
314 |     service: GatewayService = Depends(get_gateway_service),
315 |     presenter: PresenterDep,
316 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
317 | ) -> Response:
318 |     job = service.cancel_job(job_id, tenant_id=security.tenant_id, reason="client-request")
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:338:5
    |
336 |     ),
337 |     service: GatewayService = Depends(get_gateway_service),
338 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
339 |     lifecycle: LifecycleDep,
340 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:339:5
    |
337 |     service: GatewayService = Depends(get_gateway_service),
338 |     presenter: PresenterDep,
339 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
340 | ) -> Response:
341 |     return await ingest_dataset(
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:360:5
    |
358 |     ),
359 |     service: GatewayService = Depends(get_gateway_service),
360 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
361 |     lifecycle: LifecycleDep,
362 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:361:5
    |
359 |     service: GatewayService = Depends(get_gateway_service),
360 |     presenter: PresenterDep,
361 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
362 | ) -> Response:
363 |     return await ingest_dataset(
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:382:5
    |
380 |     ),
381 |     service: GatewayService = Depends(get_gateway_service),
382 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
383 |     lifecycle: LifecycleDep,
384 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:383:5
    |
381 |     service: GatewayService = Depends(get_gateway_service),
382 |     presenter: PresenterDep,
383 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
384 | ) -> Response:
385 |     return await ingest_dataset(
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:404:5
    |
402 |     ),
403 |     service: GatewayService = Depends(get_gateway_service),
404 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
405 |     lifecycle: LifecycleDep,
406 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:405:5
    |
403 |     service: GatewayService = Depends(get_gateway_service),
404 |     presenter: PresenterDep,
405 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
406 | ) -> Response:
407 |     request = _apply_tenant(request, security, http_request)  # type: ignore[assignment]
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:427:5
    |
425 |     ),
426 |     service: GatewayService = Depends(get_gateway_service),
427 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
428 |     lifecycle: LifecycleDep,
429 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:428:5
    |
426 |     service: GatewayService = Depends(get_gateway_service),
427 |     presenter: PresenterDep,
428 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
429 | ) -> Response:
430 |     request = _apply_tenant(request, security, http_request)  # type: ignore[assignment]
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:461:5
    |
459 |     ),
460 |     service: GatewayService = Depends(get_gateway_service),
461 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
462 |     lifecycle: LifecycleDep,
463 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:462:5
    |
460 |     service: GatewayService = Depends(get_gateway_service),
461 |     presenter: PresenterDep,
462 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
463 | ) -> Response:
464 |     odata = ODataParams.from_request(http_request)
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:490:5
    |
488 |     ),
489 |     service: GatewayService = Depends(get_gateway_service),
490 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
491 |     lifecycle: LifecycleDep,
492 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:491:5
    |
489 |     service: GatewayService = Depends(get_gateway_service),
490 |     presenter: PresenterDep,
491 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
492 | ) -> Response:
493 |     http_request.state.requested_tenant_id = security.tenant_id
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:504:5
    |
502 |     ),
503 |     service: GatewayService = Depends(get_gateway_service),
504 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
505 |     lifecycle: LifecycleDep,
506 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:505:5
    |
503 |     service: GatewayService = Depends(get_gateway_service),
504 |     presenter: PresenterDep,
505 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
506 | ) -> Response:
507 |     status = service.namespace_policy_status()
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:518:5
    |
516 |     ),
517 |     service: GatewayService = Depends(get_gateway_service),
518 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
519 |     lifecycle: LifecycleDep,
520 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:519:5
    |
517 |     service: GatewayService = Depends(get_gateway_service),
518 |     presenter: PresenterDep,
519 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
520 | ) -> Response:
521 |     try:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:536:5
    |
534 |     ),
535 |     service: GatewayService = Depends(get_gateway_service),
536 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
537 |     lifecycle: LifecycleDep,
538 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:537:5
    |
535 |     service: GatewayService = Depends(get_gateway_service),
536 |     presenter: PresenterDep,
537 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
538 | ) -> Response:
539 |     diagnostics = service.namespace_policy_diagnostics()
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:549:5
    |
547 |     ),
548 |     service: GatewayService = Depends(get_gateway_service),
549 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
550 |     lifecycle: LifecycleDep,
551 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:550:5
    |
548 |     service: GatewayService = Depends(get_gateway_service),
549 |     presenter: PresenterDep,
550 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
551 | ) -> Response:
552 |     health = service.namespace_policy_health()
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:564:5
    |
562 |     ),
563 |     service: GatewayService = Depends(get_gateway_service),
564 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
565 |     lifecycle: LifecycleDep,
566 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:565:5
    |
563 |     service: GatewayService = Depends(get_gateway_service),
564 |     presenter: PresenterDep,
565 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
566 | ) -> Response:
567 |     metrics = service.namespace_policy_metrics()
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:580:5
    |
578 |     ),
579 |     service: GatewayService = Depends(get_gateway_service),
580 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
581 |     lifecycle: LifecycleDep,
582 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:581:5
    |
579 |     service: GatewayService = Depends(get_gateway_service),
580 |     presenter: PresenterDep,
581 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
582 | ) -> Response:
583 |     service.invalidate_namespace_policy_cache(request.namespace)
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:597:5
    |
595 |     ),
596 |     service: GatewayService = Depends(get_gateway_service),
597 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
598 |     lifecycle: LifecycleDep,
599 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:598:5
    |
596 |     service: GatewayService = Depends(get_gateway_service),
597 |     presenter: PresenterDep,
598 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
599 | ) -> Response:
600 |     request = _apply_tenant(request, security, http_request)  # type: ignore[assignment]
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:617:5
    |
615 |     ),
616 |     service: GatewayService = Depends(get_gateway_service),
617 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
618 |     lifecycle: LifecycleDep,
619 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:618:5
    |
616 |     service: GatewayService = Depends(get_gateway_service),
617 |     presenter: PresenterDep,
618 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
619 | ) -> Response:
620 |     request = _apply_tenant(request, security, http_request)  # type: ignore[assignment]
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:638:5
    |
636 |     ),
637 |     service: GatewayService = Depends(get_gateway_service),
638 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
639 |     lifecycle: LifecycleDep,
640 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:639:5
    |
637 |     service: GatewayService = Depends(get_gateway_service),
638 |     presenter: PresenterDep,
639 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
640 | ) -> Response:
641 |     odata = ODataParams.from_request(http_request)
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:674:5
    |
672 |     ),
673 |     service: GatewayService = Depends(get_gateway_service),
674 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
675 |     lifecycle: LifecycleDep,
676 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:675:5
    |
673 |     service: GatewayService = Depends(get_gateway_service),
674 |     presenter: PresenterDep,
675 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
676 | ) -> Response:
677 |     request_model = RetrieveRequest(
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:714:5
    |
712 |     ),
713 |     service: GatewayService = Depends(get_gateway_service),
714 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
715 |     lifecycle: LifecycleDep,
716 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:715:5
    |
713 |     service: GatewayService = Depends(get_gateway_service),
714 |     presenter: PresenterDep,
715 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
716 | ) -> Response:
717 |     request = _apply_tenant(request, security, http_request)  # type: ignore[assignment]
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:761:5
    |
759 |     ),
760 |     service: GatewayService = Depends(get_gateway_service),
761 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
762 |     lifecycle: LifecycleDep,
763 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:762:5
    |
760 |     service: GatewayService = Depends(get_gateway_service),
761 |     presenter: PresenterDep,
762 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
763 | ) -> Response:
764 |     request = _apply_tenant(request, security, http_request)  # type: ignore[assignment]
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:781:5
    |
779 |         secure_endpoint(scopes=[Scopes.AUDIT_READ], endpoint="GET /v1/audit/logs")
780 |     ),
781 |     presenter: PresenterDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
782 |     lifecycle: LifecycleDep,
783 | ) -> Response:
    |

invalid-syntax: Parameter without a default cannot follow a parameter with a default
   --> src/Medical_KG_rev/gateway/rest/router.py:782:5
    |
780 |     ),
781 |     presenter: PresenterDep,
782 |     lifecycle: LifecycleDep,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
783 | ) -> Response:
784 |     logs = get_audit_trail().list(tenant_id=security.tenant_id, limit=limit)
    |

invalid-syntax: Expected an expression
   --> src/Medical_KG_rev/gateway/services.py:133:6
    |
131 |     pipeline_resource = create_default_pipeline_resource()
132 |     return build_stage_factory(adapter_manager, pipeline_resource, job_ledger)
133 |     *,
    |      ^
134 |     job_ledger: JobLedger | None = None,
135 | ) -> StageFactory:
    |

invalid-syntax: Expected a statement
   --> src/Medical_KG_rev/gateway/services.py:135:1
    |
133 |     *,
134 |     job_ledger: JobLedger | None = None,
135 | ) -> StageFactory:
    | ^
136 |     plugin_manager = create_stage_plugin_manager(
137 |         manager or get_plugin_manager(),
    |

invalid-syntax: Expected a statement
   --> src/Medical_KG_rev/gateway/services.py:135:3
    |
133 |     *,
134 |     job_ledger: JobLedger | None = None,
135 | ) -> StageFactory:
    |   ^^
136 |     plugin_manager = create_stage_plugin_manager(
137 |         manager or get_plugin_manager(),
    |

invalid-syntax: Expected an expression
   --> src/Medical_KG_rev/gateway/services.py:135:19
    |
133 |     *,
134 |     job_ledger: JobLedger | None = None,
135 | ) -> StageFactory:
    |                   ^
136 |     plugin_manager = create_stage_plugin_manager(
137 |         manager or get_plugin_manager(),
    |

invalid-syntax: Unexpected indentation
   --> src/Medical_KG_rev/gateway/services.py:136:1
    |
134 |     job_ledger: JobLedger | None = None,
135 | ) -> StageFactory:
136 |     plugin_manager = create_stage_plugin_manager(
    | ^^^^
137 |         manager or get_plugin_manager(),
138 |         job_ledger=job_ledger,
    |

invalid-syntax: Expected a statement
   --> src/Medical_KG_rev/gateway/services.py:143:1
    |
143 | @dataclass
    | ^
144 | class GatewayService:
145 |     """Coordinates business logic shared across protocols."""
    |

invalid-syntax: Expected ',', found name
   --> src/Medical_KG_rev/gateway/services.py:185:13
    |
183 |             self.chunking_errors = ChunkingErrorTranslator(
184 |                 strategies=self.chunker.available_strategies()
185 |             self.stage_factory = _build_stage_factory(self.adapter_manager, self.ledger)
    |             ^^^^
186 |             
187 |         if self.chunker is None:
    |

invalid-syntax: Expected 'else', found ':'
   --> src/Medical_KG_rev/gateway/services.py:187:32
    |
185 |             self.stage_factory = _build_stage_factory(self.adapter_manager, self.ledger)
186 |             
187 |         if self.chunker is None:
    |                                ^
188 |             self.chunker = ChunkingService(stage_factory=self.stage_factory)
189 |         if self.chunking_error_translator is None:
    |

invalid-syntax: Expected a parameter name
   --> src/Medical_KG_rev/gateway/services.py:188:13
    |
187 |         if self.chunker is None:
188 |             self.chunker = ChunkingService(stage_factory=self.stage_factory)
    |             ^^^^^^^^^^^^
189 |         if self.chunking_error_translator is None:
190 |             self.chunking_error_translator = ChunkingErrorTranslator(
    |

invalid-syntax: Duplicate keyword argument ""
   --> src/Medical_KG_rev/gateway/services.py:188:13
    |
187 |           if self.chunker is None:
188 | /             self.chunker = ChunkingService(stage_factory=self.stage_factory)
189 | |         if self.chunking_error_translator is None:
    | |_________________________________________________^
190 |               self.chunking_error_translator = ChunkingErrorTranslator(
191 |                   available_strategies=self.chunker.available_strategies,
    |

invalid-syntax: Expected 'else', found ':'
   --> src/Medical_KG_rev/gateway/services.py:189:50
    |
187 |         if self.chunker is None:
188 |             self.chunker = ChunkingService(stage_factory=self.stage_factory)
189 |         if self.chunking_error_translator is None:
    |                                                  ^
190 |             self.chunking_error_translator = ChunkingErrorTranslator(
191 |                 available_strategies=self.chunker.available_strategies,
    |

invalid-syntax: Expected a parameter name
   --> src/Medical_KG_rev/gateway/services.py:190:13
    |
188 |             self.chunker = ChunkingService(stage_factory=self.stage_factory)
189 |         if self.chunking_error_translator is None:
190 |             self.chunking_error_translator = ChunkingErrorTranslator(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
191 |                 available_strategies=self.chunker.available_strategies,
192 |             )
    |

invalid-syntax: Duplicate keyword argument ""
   --> src/Medical_KG_rev/gateway/services.py:190:13
    |
188 |               self.chunker = ChunkingService(stage_factory=self.stage_factory)
189 |           if self.chunking_error_translator is None:
190 | /             self.chunking_error_translator = ChunkingErrorTranslator(
191 | |                 available_strategies=self.chunker.available_strategies,
192 | |             )
193 | |         if self.namespace_registry is None:
    | |__________________________________________^
194 |               self.namespace_registry = self.embedding_registry.namespace_registry
195 |           if self.embedding_telemetry is None:
    |

invalid-syntax: Expected 'else', found ':'
   --> src/Medical_KG_rev/gateway/services.py:193:43
    |
191 |                 available_strategies=self.chunker.available_strategies,
192 |             )
193 |         if self.namespace_registry is None:
    |                                           ^
194 |             self.namespace_registry = self.embedding_registry.namespace_registry
195 |         if self.embedding_telemetry is None:
    |

invalid-syntax: Expected a parameter name
   --> src/Medical_KG_rev/gateway/services.py:194:13
    |
192 |             )
193 |         if self.namespace_registry is None:
194 |             self.namespace_registry = self.embedding_registry.namespace_registry
    |             ^^^^^^^^^^^^^^^^^^^^^^^
195 |         if self.embedding_telemetry is None:
196 |             self.embedding_telemetry = StandardEmbeddingTelemetry()
    |

invalid-syntax: Duplicate keyword argument ""
   --> src/Medical_KG_rev/gateway/services.py:194:13
    |
192 |               )
193 |           if self.namespace_registry is None:
194 | /             self.namespace_registry = self.embedding_registry.namespace_registry
195 | |         if self.embedding_telemetry is None:
    | |___________________________________________^
196 |               self.embedding_telemetry = StandardEmbeddingTelemetry()
197 |           if self.namespace_policy is None:
    |

invalid-syntax: Expected 'else', found ':'
   --> src/Medical_KG_rev/gateway/services.py:195:44
    |
193 |         if self.namespace_registry is None:
194 |             self.namespace_registry = self.embedding_registry.namespace_registry
195 |         if self.embedding_telemetry is None:
    |                                            ^
196 |             self.embedding_telemetry = StandardEmbeddingTelemetry()
197 |         if self.namespace_policy is None:
    |

invalid-syntax: Expected a parameter name
   --> src/Medical_KG_rev/gateway/services.py:196:13
    |
194 |             self.namespace_registry = self.embedding_registry.namespace_registry
195 |         if self.embedding_telemetry is None:
196 |             self.embedding_telemetry = StandardEmbeddingTelemetry()
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
197 |         if self.namespace_policy is None:
198 |             if self.namespace_policy_settings is None:
    |

invalid-syntax: Duplicate keyword argument ""
   --> src/Medical_KG_rev/gateway/services.py:196:13
    |
194 |               self.namespace_registry = self.embedding_registry.namespace_registry
195 |           if self.embedding_telemetry is None:
196 | /             self.embedding_telemetry = StandardEmbeddingTelemetry()
197 | |         if self.namespace_policy is None:
    | |________________________________________^
198 |               if self.namespace_policy_settings is None:
199 |                   self.namespace_policy_settings = NamespacePolicySettings()
    |

invalid-syntax: Expected 'else', found ':'
   --> src/Medical_KG_rev/gateway/services.py:197:41
    |
195 |         if self.embedding_telemetry is None:
196 |             self.embedding_telemetry = StandardEmbeddingTelemetry()
197 |         if self.namespace_policy is None:
    |                                         ^
198 |             if self.namespace_policy_settings is None:
199 |                 self.namespace_policy_settings = NamespacePolicySettings()
    |

invalid-syntax: Expected ')', found newline
   --> src/Medical_KG_rev/gateway/services.py:197:42
    |
195 |         if self.embedding_telemetry is None:
196 |             self.embedding_telemetry = StandardEmbeddingTelemetry()
197 |         if self.namespace_policy is None:
    |                                          ^
198 |             if self.namespace_policy_settings is None:
199 |                 self.namespace_policy_settings = NamespacePolicySettings()
    |

invalid-syntax: Unexpected indentation
   --> src/Medical_KG_rev/gateway/services.py:802:1
    |
800 |             raise RuntimeError("Embedding coordinator returned no response")
801 |         return result.response
802 |             records = embedder.embed_documents(adapter_request)
    | ^^^^^^^^^^^^
803 |         except Exception as exc:  # pragma: no cover - network/library error
804 |             detail = ProblemDetail(
    |

invalid-syntax: Expected a statement
   --> src/Medical_KG_rev/gateway/services.py:803:9
    |
801 |         return result.response
802 |             records = embedder.embed_documents(adapter_request)
803 |         except Exception as exc:  # pragma: no cover - network/library error
    |         ^^^^^^
804 |             detail = ProblemDetail(
805 |                 title="Embedding failed",
    |

invalid-syntax: Expected a statement
   --> src/Medical_KG_rev/gateway/services.py:803:26
    |
801 |         return result.response
802 |             records = embedder.embed_documents(adapter_request)
803 |         except Exception as exc:  # pragma: no cover - network/library error
    |                          ^^
804 |             detail = ProblemDetail(
805 |                 title="Embedding failed",
    |

invalid-syntax: Expected an expression
   --> src/Medical_KG_rev/gateway/services.py:803:77
    |
801 |         return result.response
802 |             records = embedder.embed_documents(adapter_request)
803 |         except Exception as exc:  # pragma: no cover - network/library error
    |                                                                             ^
804 |             detail = ProblemDetail(
805 |                 title="Embedding failed",
    |

invalid-syntax: Unexpected indentation
   --> src/Medical_KG_rev/gateway/services.py:804:1
    |
802 |             records = embedder.embed_documents(adapter_request)
803 |         except Exception as exc:  # pragma: no cover - network/library error
804 |             detail = ProblemDetail(
    | ^^^^^^^^^^^^
805 |                 title="Embedding failed",
806 |                 status=502,
    |

invalid-syntax: Expected a statement
   --> src/Medical_KG_rev/gateway/services.py:907:5
    |
905 |         )
906 |
907 |     def _storage_metadata(self, kind: str, tenant_id: str, namespace: str) -> dict[str, Any]:
    |     ^
908 |         sanitized_namespace = namespace.replace(".", "-")
909 |         if kind in {"single_vector", "multi_vector"}:
    |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/gateway/services.py:1455:1
     |
1455 | _service: GatewayService | None = None
     | ^
1456 | _ledger: JobLedger | None = None
1457 | _orchestrator: DagsterOrchestrator | None = None
     |

D104 Missing docstring in public package
--> src/Medical_KG_rev/gateway/soap/__init__.py:1:1

D103 Missing docstring in public function
  --> src/Medical_KG_rev/gateway/soap/routes.py:49:11
   |
48 | @router.get("/wsdl", include_in_schema=False)
49 | async def serve_wsdl() -> Response:
   |           ^^^^^^^^^^
50 |     return Response(content=WSDL_TEMPLATE, media_type="application/xml")
   |

D103 Missing docstring in public function
  --> src/Medical_KG_rev/gateway/soap/routes.py:62:11
   |
61 | @router.post("", include_in_schema=False)
62 | async def soap_entrypoint(
   |           ^^^^^^^^^^^^^^^
63 |     body: str = Body(..., media_type="text/xml"),
64 |     security: SecurityContext = Depends(get_security_context),
   |

D104 Missing docstring in public package
--> src/Medical_KG_rev/gateway/sse/__init__.py:1:1

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/gateway/sse/manager.py:19:9
   |
17 |     _HISTORY_LIMIT = 200
18 |
19 |     def __init__(self) -> None:
   |         ^^^^^^^^
20 |         self._subscribers: dict[str, list[asyncio.Queue[JobEvent]]] = defaultdict(list)
21 |         self._pending: dict[str, list[JobEvent]] = defaultdict(list)
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/gateway/sse/manager.py:27:15
   |
25 |         self._lock = asyncio.Lock()
26 |
27 |     async def subscribe(self, job_id: str) -> AsyncIterator[JobEvent]:
   |               ^^^^^^^^^
28 |         queue: asyncio.Queue[JobEvent] = asyncio.Queue()
29 |         async with self._lock:
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/gateway/sse/manager.py:45:9
   |
43 |                     self._subscribers.pop(job_id, None)
44 |
45 |     def publish(self, event: JobEvent) -> None:
   |         ^^^^^^^
46 |         self._history[event.job_id].append(event)
47 |         queues = list(self._subscribers.get(event.job_id, []))
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/gateway/sse/manager.py:54:9
   |
52 |             queue.put_nowait(event)
53 |
54 |     def history(self, job_id: str, *, since: datetime | None = None) -> list[JobEvent]:
   |         ^^^^^^^
55 |         events = list(self._history.get(job_id, []))
56 |         if since is not None:
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/gateway/sse/manager.py:68:15
   |
67 |     @asynccontextmanager
68 |     async def open_stream(self, job_id: str) -> AsyncIterator[AsyncIterator[JobEvent]]:
   |               ^^^^^^^^^^^
69 |         yield self.subscribe(job_id)
   |

D103 Missing docstring in public function
  --> src/Medical_KG_rev/gateway/sse/routes.py:37:11
   |
36 | @router.get("/jobs/{job_id}/events", response_class=StreamingResponse)
37 | async def stream_job_events(
   |           ^^^^^^^^^^^^^^^^^
38 |     job_id: str,
39 |     service: GatewayService = Depends(get_gateway_service),
   |

D101 Missing docstring in public class
  --> src/Medical_KG_rev/orchestration/dagster/configuration.py:41:7
   |
41 | class BackoffStrategy(str, Enum):
   |       ^^^^^^^^^^^^^^^
42 |     EXPONENTIAL = "exponential"
43 |     LINEAR = "linear"
   |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/dagster/configuration.py:202:9
    |
200 |     _circuit_breakers: dict[str, "CircuitBreaker"] = PrivateAttr(default_factory=dict)
201 |
202 |     def create_retry(self, stage: str, hooks: StageExecutionHooks | None = None):
    |         ^^^^^^^^^^^^
203 |         from tenacity import retry, stop_after_attempt
204 |         from tenacity import wait_none
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/dagster/configuration.py:237:9
    |
235 |         )
236 |
237 |     def create_circuit_breaker(self, stage: str):
    |         ^^^^^^^^^^^^^^^^^^^^^^
238 |         try:
239 |             from pybreaker import CircuitBreaker, CircuitBreakerListener
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/dagster/configuration.py:274:9
    |
272 |         return breaker
273 |
274 |     def get_rate_limiter(self) -> "AsyncLimiter | None":
    |         ^^^^^^^^^^^^^^^^
275 |         try:
276 |             from aiolimiter import AsyncLimiter
    |

D202 [*] No blank lines allowed after function docstring (found 1)
   --> src/Medical_KG_rev/orchestration/dagster/configuration.py:297:5
    |
295 |     stages: Sequence[StageDefinition],
296 | ) -> dict[str, set[str]]:
297 |     """Combine explicit and inferred dependencies for pipeline stages."""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
298 |
299 |     graph: dict[str, set[str]] = {stage.name: set(stage.depends_on) for stage in stages}
    |
help: Remove blank line(s) after function docstring

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/orchestration/dagster/configuration.py:396:9
    |
394 |     """Load and cache pipeline topology YAML files."""
395 |
396 |     def __init__(self, base_path: str | Path | None = None) -> None:
    |         ^^^^^^^^
397 |         self.base_path = Path(base_path or "config/orchestration/pipelines")
398 |         self._cache: dict[str, _CacheEntry] = {}
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/dagster/configuration.py:404:9
    |
402 |         self._stop_event = threading.Event()
403 |
404 |     def load(self, name: str, *, force: bool = False) -> PipelineTopologyConfig:
    |         ^^^^
405 |         path = self.base_path / f"{name}.yaml"
406 |         if not path.exists():
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/dagster/configuration.py:424:9
    |
422 |             return entry.config
423 |
424 |     def invalidate(self, name: str) -> None:
    |         ^^^^^^^^^^
425 |         with self._lock:
426 |             self._cache.pop(name, None)
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/dagster/configuration.py:428:9
    |
426 |             self._cache.pop(name, None)
427 |
428 |     def watch(self, callback: Callable[[str, PipelineTopologyConfig], None], *, interval: float = 2.0) -> None:
    |         ^^^^^
429 |         self._watchers.append(callback)
430 |         if self._watch_thread is None:
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/dagster/configuration.py:451:9
    |
449 |         self._watch_thread.start()
450 |
451 |     def close(self) -> None:
    |         ^^^^^
452 |         self._stop_event.set()
453 |         if self._watch_thread and self._watch_thread.is_alive():
    |

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/orchestration/dagster/configuration.py:460:9
    |
458 |     """Load resilience policy definitions and provide helper factories."""
459 |
460 |     def __init__(self, path: str | Path | None = None) -> None:
    |         ^^^^^^^^
461 |         self.path = Path(path or "config/orchestration/resilience.yaml")
462 |         self._policies: dict[str, ResiliencePolicy] = {}
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/dagster/configuration.py:469:9
    |
467 |         self._sync_limiters: dict[str, _SyncLimiter] = {}
468 |
469 |     def load(self, *, force: bool = False) -> dict[str, ResiliencePolicy]:
    |         ^^^^
470 |         if not self.path.exists():
471 |             raise FileNotFoundError(f"Resilience policy config not found at {self.path}")
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/dagster/configuration.py:490:9
    |
488 |             return dict(self._policies)
489 |
490 |     def get(self, name: str) -> ResiliencePolicy:
    |         ^^^
491 |         with self._lock:
492 |             if name not in self._policies:
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/dagster/configuration.py:499:9
    |
497 |                 raise KeyError(f"Unknown resilience policy '{name}'") from exc
498 |
499 |     def apply(
    |         ^^^^^
500 |         self,
501 |         name: str,
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/dagster/configuration.py:558:9
    |
556 |         return _wrapped
557 |
558 |     def watch(self, callback: Callable[[str, ResiliencePolicy], None], *, interval: float = 2.0) -> None:
    |         ^^^^^
559 |         self._watchers.append(callback)
560 |         if self._watch_thread is None:
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/dagster/configuration.py:580:9
    |
578 |         self._watch_thread.start()
579 |
580 |     def close(self) -> None:
    |         ^^^^^
581 |         self._stop_event.set()
582 |         if self._watch_thread and self._watch_thread.is_alive():
    |

D202 [*] No blank lines allowed after function docstring (found 1)
   --> src/Medical_KG_rev/orchestration/dagster/configuration.py:596:5
    |
595 | def export_pipeline_schema(path: str | Path) -> None:
596 |     """Write the JSON schema for pipeline topology configs to disk."""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
597 |
598 |     schema = PipelineTopologyConfig.model_json_schema(by_alias=True)
    |
help: Remove blank line(s) after function docstring

invalid-syntax: Expected ',', found name
   --> src/Medical_KG_rev/orchestration/dagster/runtime.py:109:5
    |
107 |     """Resolve orchestration stages through the plugin manager."""
108 |
109 |     plugin_manager: StagePluginManager
    |     ^^^^^^^^^^^^^^
110 |
111 |     def resolve(self, pipeline: str, stage: StageDefinition) -> object:
    |

invalid-syntax: Expected ',', found ':'
   --> src/Medical_KG_rev/orchestration/dagster/runtime.py:109:19
    |
107 |     """Resolve orchestration stages through the plugin manager."""
108 |
109 |     plugin_manager: StagePluginManager
    |                   ^
110 |
111 |     def resolve(self, pipeline: str, stage: StageDefinition) -> object:
    |

invalid-syntax: Expected ')', found newline
   --> src/Medical_KG_rev/orchestration/dagster/runtime.py:109:39
    |
107 |     """Resolve orchestration stages through the plugin manager."""
108 |
109 |     plugin_manager: StagePluginManager
    |                                       ^
110 |
111 |     def resolve(self, pipeline: str, stage: StageDefinition) -> object:
    |

invalid-syntax: Expected an indented block after `class` definition
   --> src/Medical_KG_rev/orchestration/dagster/stages.py:358:1
    |
357 | class CoreStagePlugin(StagePlugin):
358 | class CoreStagePlugin:
    | ^^^^^
359 |     """Register the built-in orchestration stage implementations."""
    |

invalid-syntax: Expected an indented block after function definition
   --> src/Medical_KG_rev/orchestration/dagster/stages.py:368:5
    |
367 |     def registrations(self, resources: StagePluginResources) -> Sequence[StagePluginRegistration]:
368 |     @hookimpl
    |     ^
369 |     def stage_builders(self, resources: StagePluginResources) -> Sequence[StagePluginRegistration]:
370 |         adapter_manager = resources.adapter_manager
    |

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/orchestration/events.py:19:13
   |
17 |         """Fallback CloudEvent implementation using a simple mapping."""
18 |
19 |         def __init__(self, attributes: dict[str, Any], data: dict[str, Any]) -> None:
   |             ^^^^^^^^
20 |             super().__init__({**attributes, "data": data})
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/orchestration/events.py:23:13
   |
22 |         @property
23 |         def data(self) -> dict[str, Any]:
   |             ^^^^
24 |             return self["data"]
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/orchestration/events.py:26:13
   |
24 |             return self["data"]
25 |
26 |         def get_data(self) -> dict[str, Any]:  # noqa: D401 - mirror cloudevents API
   |             ^^^^^^^^
27 |             return self.data
   |

D105 Missing docstring in magic method
  --> src/Medical_KG_rev/orchestration/events.py:29:13
   |
27 |             return self.data
28 |
29 |         def __getitem__(self, item: str) -> Any:  # type: ignore[override]
   |             ^^^^^^^^^^^
30 |             return super().__getitem__(item)
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/orchestration/events.py:32:13
   |
30 |             return super().__getitem__(item)
31 |
32 |         def to_dict(self) -> dict[str, Any]:  # noqa: D401 - convenience helper
   |             ^^^^^^^
33 |             return dict(self)
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/orchestration/events.py:64:9
   |
62 |         }
63 |
64 |     def stage_started(self, ctx: StageContext, stage: str, attempt: int) -> CloudEvent:
   |         ^^^^^^^^^^^^^
65 |         attributes = self._base_attributes("stage.started", ctx, stage)
66 |         data = {
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/orchestration/events.py:75:9
   |
73 |         return CloudEvent(attributes, data)
74 |
75 |     def stage_completed(
   |         ^^^^^^^^^^^^^^^
76 |         self,
77 |         ctx: StageContext,
   |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/events.py:99:9
    |
 97 |         return CloudEvent(attributes, data)
 98 |
 99 |     def stage_failed(
    |         ^^^^^^^^^^^^
100 |         self,
101 |         ctx: StageContext,
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/events.py:121:9
    |
119 |         return CloudEvent(attributes, data)
120 |
121 |     def stage_retrying(
    |         ^^^^^^^^^^^^^^
122 |         self,
123 |         ctx: StageContext,
    |

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/orchestration/events.py:146:9
    |
144 |     """Publish stage lifecycle CloudEvents to the orchestration topic."""
145 |
146 |     def __init__(
    |         ^^^^^^^^
147 |         self,
148 |         kafka: KafkaClient,
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/events.py:159:9
    |
158 |     @property
159 |     def topic(self) -> str:
    |         ^^^^^
160 |         return self._topic
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/events.py:162:9
    |
160 |         return self._topic
161 |
162 |     def emit_started(self, ctx: StageContext, stage: str, *, attempt: int) -> None:
    |         ^^^^^^^^^^^^
163 |         event = self._factory.stage_started(ctx, stage, attempt)
164 |         self._publish(event)
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/events.py:166:9
    |
164 |         self._publish(event)
165 |
166 |     def emit_completed(
    |         ^^^^^^^^^^^^^^
167 |         self,
168 |         ctx: StageContext,
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/events.py:186:9
    |
184 |         self._publish(event)
185 |
186 |     def emit_failed(
    |         ^^^^^^^^^^^
187 |         self,
188 |         ctx: StageContext,
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/events.py:204:9
    |
202 |         self._publish(event)
203 |
204 |     def emit_retrying(
    |         ^^^^^^^^^^^^^
205 |         self,
206 |         ctx: StageContext,
    |

D100 Missing docstring in public module
--> src/Medical_KG_rev/orchestration/haystack/components.py:1:1

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/orchestration/haystack/components.py:96:9
   |
94 |     """Convert IR documents into Haystack documents and split them."""
95 |
96 |     def __init__(
   |         ^^^^^^^^
97 |         self,
98 |         splitter: DocumentSplitter | None = None,
   |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/haystack/components.py:114:9
    |
112 |         self._granularity = granularity
113 |
114 |     def execute(self, ctx: StageContext, state: PipelineState) -> list[Chunk]:
    |         ^^^^^^^
115 |         document = state.require_document()
116 |         haystack_documents: list[HaystackDocument] = []
    |

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/orchestration/haystack/components.py:195:9
    |
193 |     """Generate SPLADE-style sparse vectors for retrieval expansion."""
194 |
195 |     def __init__(
    |         ^^^^^^^^
196 |         self,
197 |         component: Any | None = None,
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/haystack/components.py:209:9
    |
207 |         self._component = component
208 |
209 |     def expand(self, documents: Sequence[HaystackDocument]) -> Sequence[dict[str, float]]:
    |         ^^^^^^
210 |         result = self._component.run(documents=list(documents))
211 |         vectors = result.get("documents") if isinstance(result, dict) else result
    |

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/orchestration/haystack/components.py:224:9
    |
222 |     """Wrap the Haystack OpenAI embedder for dense vector generation."""
223 |
224 |     def __init__(
    |         ^^^^^^^^
225 |         self,
226 |         embedder: Any | None = None,
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/haystack/components.py:251:9
    |
249 |         self._sparse_expander = sparse_expander
250 |
251 |     def execute(self, ctx: StageContext, state: PipelineState) -> EmbeddingBatch:
    |         ^^^^^^^
252 |         chunks = list(state.require_chunks())
253 |         documents = [
    |

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/orchestration/haystack/components.py:303:9
    |
301 |     """Write embedding payloads to OpenSearch and FAISS in tandem."""
302 |
303 |     def __init__(
    |         ^^^^^^^^
304 |         self,
305 |         *,
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/haystack/components.py:328:9
    |
326 |         self._faiss_index = faiss_index
327 |
328 |     def execute(self, ctx: StageContext, state: PipelineState) -> IndexReceipt:
    |         ^^^^^^^
329 |         batch = state.require_embedding_batch()
330 |         if not batch.vectors:
    |

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/orchestration/haystack/components.py:377:9
    |
375 |     """Hybrid retriever combining lexical and dense search outputs."""
376 |
377 |     def __init__(
    |         ^^^^^^^^
378 |         self,
379 |         *,
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/haystack/components.py:418:9
    |
416 |         self._top_k = top_k
417 |
418 |     def retrieve(self, query: str, *, filters: dict[str, Any] | None = None) -> list[dict[str, Any]]:
    |         ^^^^^^^^
419 |         lexical = self._bm25.run(query=query, filters=filters or {})
420 |         dense = self._dense.run(query=query, filters=filters or {})
    |

D105 Missing docstring in magic method
  --> src/Medical_KG_rev/orchestration/kafka.py:25:9
   |
23 |     available_at: float = field(default_factory=lambda: time.time())
24 |
25 |     def __post_init__(self) -> None:
   |         ^^^^^^^^^^^^^
26 |         # Priority is encoded in headers under x-priority. Higher value == higher priority.
27 |         priority = int(self.headers.get("x-priority", "0"))
   |

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/orchestration/kafka.py:34:9
   |
32 |     """Small in-memory Kafka façade suitable for unit testing."""
33 |
34 |     def __init__(self) -> None:
   |         ^^^^^^^^
35 |         self._topics: dict[str, list[KafkaMessage]] = defaultdict(list)
36 |         self._health: dict[str, bool] = {"kafka": True, "zookeeper": True}
   |

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/orchestration/kafka.py:42:9
   |
40 |     # ------------------------------------------------------------------
41 |     def create_topics(self, topics: Iterable[str]) -> None:
42 |         """Ensure topics exist by initialising their queues."""
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
43 |
44 |         for topic in topics:
   |
help: Remove blank line(s) after function docstring

D102 Missing docstring in public method
  --> src/Medical_KG_rev/orchestration/kafka.py:51:9
   |
49 |     # Messaging
50 |     # ------------------------------------------------------------------
51 |     def publish(
   |         ^^^^^^^
52 |         self,
53 |         topic: str,
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/orchestration/kafka.py:76:9
   |
74 |         return message
75 |
76 |     def consume(self, topic: str, *, max_messages: int | None = None) -> Iterator[KafkaMessage]:
   |         ^^^^^^^
77 |         if topic not in self._topics:
78 |             raise ValueError(f"Topic '{topic}' has not been created")
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/orchestration/kafka.py:92:9
   |
90 |             heapq.heappush(self._topics[topic], item)
91 |
92 |     def pending(self, topic: str) -> int:
   |         ^^^^^^^
93 |         if topic not in self._topics:
94 |             raise ValueError(f"Topic '{topic}' has not been created")
   |

D202 [*] No blank lines allowed after function docstring (found 1)
   --> src/Medical_KG_rev/orchestration/kafka.py:98:9
    |
 97 |     def peek(self, topic: str) -> KafkaMessage | None:
 98 |         """Return the next message for a topic without consuming it."""
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 99 |
100 |         if topic not in self._topics:
    |
help: Remove blank line(s) after function docstring

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/kafka.py:106:9
    |
104 |         return self._topics[topic][0]
105 |
106 |     def discard(self, topic: str, *, key: str) -> int:
    |         ^^^^^^^
107 |         if topic not in self._topics:
108 |             raise ValueError(f"Topic '{topic}' has not been created")
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/kafka.py:124:9
    |
122 |     # Health
123 |     # ------------------------------------------------------------------
124 |     def set_health(self, *, kafka: bool | None = None, zookeeper: bool | None = None) -> None:
    |         ^^^^^^^^^^
125 |         if kafka is not None:
126 |             self._health["kafka"] = kafka
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/kafka.py:130:9
    |
128 |             self._health["zookeeper"] = zookeeper
129 |
130 |     def health(self) -> dict[str, bool]:
    |         ^^^^^^
131 |         return dict(self._health)
    |

D101 Missing docstring in public class
  --> src/Medical_KG_rev/orchestration/ledger.py:22:7
   |
21 | @dataclass
22 | class JobTransition:
   |       ^^^^^^^^^^^^^
23 |     from_status: str
24 |     to_status: str
   |

D101 Missing docstring in public class
  --> src/Medical_KG_rev/orchestration/ledger.py:31:7
   |
30 | @dataclass
31 | class JobLedgerEntry:
   |       ^^^^^^^^^^^^^^
32 |     job_id: str
33 |     doc_key: str
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/orchestration/ledger.py:53:9
   |
51 |     pdf_ir_ready: bool = False
52 |
53 |     def is_terminal(self) -> bool:
   |         ^^^^^^^^^^^
54 |         return self.status in TERMINAL_STATUSES
   |

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/orchestration/ledger.py:57:9
   |
56 |     def snapshot(self) -> JobLedgerEntry:
57 |         """Return a copy suitable for external consumption."""
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
58 |
59 |         return JobLedgerEntry(
   |
help: Remove blank line(s) after function docstring

D101 Missing docstring in public class
  --> src/Medical_KG_rev/orchestration/ledger.py:83:7
   |
83 | class JobLedgerError(RuntimeError):
   |       ^^^^^^^^^^^^^^
84 |     pass
   |

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/orchestration/ledger.py:90:9
   |
88 |     """In-memory ledger implementation with idempotency helpers."""
89 |
90 |     def __init__(self) -> None:
   |         ^^^^^^^^
91 |         self._entries: dict[str, JobLedgerEntry] = {}
92 |         self._doc_index: dict[str, str] = {}
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/orchestration/ledger.py:97:9
   |
95 |     # Creation & idempotency
96 |     # ------------------------------------------------------------------
97 |     def create(
   |         ^^^^^^
98 |         self,
99 |         *,
   |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/ledger.py:123:9
    |
121 |         return entry
122 |
123 |     def idempotent_create(
    |         ^^^^^^^^^^^^^^^^^
124 |         self,
125 |         *,
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/ledger.py:200:9
    |
198 |         return entry
199 |
200 |     def update_metadata(self, job_id: str, metadata: dict[str, object]) -> JobLedgerEntry:
    |         ^^^^^^^^^^^^^^^
201 |         return self._update(job_id, metadata=metadata)
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/ledger.py:203:9
    |
201 |         return self._update(job_id, metadata=metadata)
202 |
203 |     def mark_processing(self, job_id: str, stage: str) -> JobLedgerEntry:
    |         ^^^^^^^^^^^^^^^
204 |         entry = self._update(
205 |             job_id,
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/ledger.py:213:9
    |
211 |         return entry
212 |
213 |     def mark_stage_started(self, job_id: str, stage: str) -> JobLedgerEntry:
    |         ^^^^^^^^^^^^^^^^^^
214 |         entry = self.mark_processing(job_id, stage)
215 |         entry.retry_count_per_stage.setdefault(stage, 0)
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/ledger.py:218:9
    |
216 |         return entry
217 |
218 |     def mark_completed(
    |         ^^^^^^^^^^^^^^
219 |         self, job_id: str, *, metadata: dict[str, object] | None = None
220 |     ) -> JobLedgerEntry:
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/ledger.py:232:9
    |
230 |         return entry
231 |
232 |     def mark_failed(
    |         ^^^^^^^^^^^
233 |         self,
234 |         job_id: str,
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/ledger.py:253:9
    |
251 |         return entry
252 |
253 |     def mark_cancelled(self, job_id: str, *, reason: str | None = None) -> JobLedgerEntry:
    |         ^^^^^^^^^^^^^^
254 |         return self._update(
255 |             job_id,
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/ledger.py:262:9
    |
260 |         )
261 |
262 |     def increment_retry(self, job_id: str, stage: str) -> JobLedgerEntry:
    |         ^^^^^^^^^^^^^^^
263 |         if job_id not in self._entries:
264 |             raise JobLedgerError(f"Job {job_id} not found")
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/ledger.py:275:9
    |
273 |         return entry
274 |
275 |     def set_pdf_downloaded(self, job_id: str, value: bool = True) -> JobLedgerEntry:
    |         ^^^^^^^^^^^^^^^^^^
276 |         return self._update(job_id, pdf_downloaded=value)
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/ledger.py:278:9
    |
276 |         return self._update(job_id, pdf_downloaded=value)
277 |
278 |     def set_pdf_ir_ready(self, job_id: str, value: bool = True) -> JobLedgerEntry:
    |         ^^^^^^^^^^^^^^^^
279 |         return self._update(job_id, pdf_ir_ready=value)
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/ledger.py:281:9
    |
279 |         return self._update(job_id, pdf_ir_ready=value)
280 |
281 |     def record_attempt(self, job_id: str) -> int:
    |         ^^^^^^^^^^^^^^
282 |         if job_id not in self._entries:
283 |             raise JobLedgerError(f"Job {job_id} not found")
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/ledger.py:293:9
    |
291 |     # Query helpers
292 |     # ------------------------------------------------------------------
293 |     def get(self, job_id: str) -> JobLedgerEntry | None:
    |         ^^^
294 |         entry = self._entries.get(job_id)
295 |         return entry.snapshot() if entry else None
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/ledger.py:297:9
    |
295 |         return entry.snapshot() if entry else None
296 |
297 |     def list(self, *, status: str | None = None) -> builtins.list[JobLedgerEntry]:
    |         ^^^^
298 |         items = (
299 |             entry.snapshot()
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/ledger.py:305:9
    |
303 |         return sorted(items, key=lambda item: item.created_at)
304 |
305 |     def by_doc_key(self, doc_key: str) -> JobLedgerEntry | None:
    |         ^^^^^^^^^^
306 |         job_id = self._doc_index.get(doc_key)
307 |         return self.get(job_id) if job_id else None
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/ledger.py:309:9
    |
307 |         return self.get(job_id) if job_id else None
308 |
309 |     def all(self) -> Iterator[JobLedgerEntry]:
    |         ^^^
310 |         for entry in self._entries.values():
311 |             yield entry.snapshot()
    |

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/orchestration/openlineage.py:140:9
    |
138 |     """Emit OpenLineage-compatible run events with optional client delivery."""
139 |
140 |     def __init__(
    |         ^^^^^^^^
141 |         self,
142 |         client: Any | None = None,
    |

D202 [*] No blank lines allowed after function docstring (found 1)
   --> src/Medical_KG_rev/orchestration/openlineage.py:166:9
    |
164 |     @property
165 |     def events(self) -> Sequence[Mapping[str, Any]]:
166 |         """Expose emitted events for testing and diagnostics."""
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
167 |
168 |         return tuple(self._events)
    |
help: Remove blank line(s) after function docstring

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/openlineage.py:170:9
    |
168 |         return tuple(self._events)
169 |
170 |     def clear(self) -> None:
    |         ^^^^^
171 |         self._events.clear()
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/openlineage.py:176:9
    |
174 |     # Emission helpers
175 |     # ------------------------------------------------------------------
176 |     def emit_run_started(
    |         ^^^^^^^^^^^^^^^^
177 |         self,
178 |         pipeline: str,
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/openlineage.py:195:9
    |
193 |         )
194 |
195 |     def emit_run_completed(
    |         ^^^^^^^^^^^^^^^^^^
196 |         self,
197 |         pipeline: str,
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/openlineage.py:218:9
    |
216 |         )
217 |
218 |     def emit_run_failed(
    |         ^^^^^^^^^^^^^^^
219 |         self,
220 |         pipeline: str,
    |

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/orchestration/stages/__init__.py:13:9
   |
11 |     """Wrap a stage failure with retry metadata and RFC 7807 details."""
12 |
13 |     def __init__(
   |         ^^^^^^^^
14 |         self,
15 |         message: str,
   |

invalid-syntax: Expected ',', found '='
   --> src/Medical_KG_rev/orchestration/stages/contracts.py:905:57
    |
903 |         "parse": ("ingest",),
904 |         "ir-validation": ("parse",),
905 |     _DEPENDENCIES: ClassVar[dict[str, tuple[str, ...]]] = {
    |                                                         ^
906 |         "parse": ("ingest",),
907 |         "ir-validation": ("ingest", "parse"),
    |

invalid-syntax: Expected ':', found string
   --> src/Medical_KG_rev/orchestration/stages/contracts.py:916:9
    |
914 |         "gate": ("download",),
915 |     }
916 |         "pdf-download": ("ingest",),
    |         ^^^^^^^^^^^^^^
917 |         "pdf-gate": ("pdf-download",),
918 |     }
    |

invalid-syntax: Expected ',', found ':'
   --> src/Medical_KG_rev/orchestration/stages/contracts.py:916:23
    |
914 |         "gate": ("download",),
915 |     }
916 |         "pdf-download": ("ingest",),
    |                       ^
917 |         "pdf-gate": ("pdf-download",),
918 |     }
    |

invalid-syntax: Expected ':', found ','
   --> src/Medical_KG_rev/orchestration/stages/contracts.py:916:36
    |
914 |         "gate": ("download",),
915 |     }
916 |         "pdf-download": ("ingest",),
    |                                    ^
917 |         "pdf-gate": ("pdf-download",),
918 |     }
    |

invalid-syntax: Expected ')', found name
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1024:9
     |
1022 |         clone._serialised_cache = (
1023 |             copy.deepcopy(self._serialised_cache) if self._serialised_cache is not None else None
1024 |         clone.pdf_gate = PdfGateState(
     |         ^^^^^
1025 |             downloaded=self.pdf_gate.downloaded,
1026 |             ir_ready=self.pdf_gate.ir_ready,
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1029:9
     |
1027 |             metadata=copy.deepcopy(self.pdf_gate.metadata),
1028 |         )
1029 |         clone._dirty = self._dirty
     |         ^^^^^
1030 |         clone._cache = copy.deepcopy(self._cache)
1031 |         clone._checkpoints = {
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1030:9
     |
1028 |         )
1029 |         clone._dirty = self._dirty
1030 |         clone._cache = copy.deepcopy(self._cache)
     |         ^^^^^
1031 |         clone._checkpoints = {
1032 |             label: copy.deepcopy(snapshot) for label, snapshot in self._checkpoints.items()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1031:9
     |
1029 |         clone._dirty = self._dirty
1030 |         clone._cache = copy.deepcopy(self._cache)
1031 |         clone._checkpoints = {
     |         ^^^^^
1032 |             label: copy.deepcopy(snapshot) for label, snapshot in self._checkpoints.items()
1033 |         }
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1034:9
     |
1032 |             label: copy.deepcopy(snapshot) for label, snapshot in self._checkpoints.items()
1033 |         }
1034 |         return clone
     |         ^^^^^^
1035 |
1036 |     def register_lifecycle_hook(self, hook: PipelineStateLifecycleHook) -> None:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1036:5
     |
1034 |         return clone
1035 |
1036 |     def register_lifecycle_hook(self, hook: PipelineStateLifecycleHook) -> None:
     |     ^^^
1037 |         """Register a lifecycle hook that observes stage progress."""
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1039:9
     |
1037 |         """Register a lifecycle hook that observes stage progress."""
1038 |
1039 |         self._lifecycle_hooks.append(hook)
     |         ^^^^
1040 |
1041 |     def notify_stage_started(self, stage: str, stage_type: str) -> None:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1041:5
     |
1039 |         self._lifecycle_hooks.append(hook)
1040 |
1041 |     def notify_stage_started(self, stage: str, stage_type: str) -> None:
     |     ^^^
1042 |         for hook in self._lifecycle_hooks:
1043 |             if hook.on_started:
     |

invalid-syntax: Expected a simple statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1042:9
     |
1041 |     def notify_stage_started(self, stage: str, stage_type: str) -> None:
1042 |         for hook in self._lifecycle_hooks:
     |         ^^^
1043 |             if hook.on_started:
1044 |                 hook.on_started(self, stage, stage_type)
     |

invalid-syntax: Expected a simple statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1043:13
     |
1041 |     def notify_stage_started(self, stage: str, stage_type: str) -> None:
1042 |         for hook in self._lifecycle_hooks:
1043 |             if hook.on_started:
     |             ^^
1044 |                 hook.on_started(self, stage, stage_type)
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1046:5
     |
1044 |                 hook.on_started(self, stage, stage_type)
1045 |
1046 |     def notify_stage_completed(
     |     ^^^
1047 |         self,
1048 |         stage: str,
     |

invalid-syntax: Expected a simple statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1055:9
     |
1053 |         output_count: int,
1054 |     ) -> None:
1055 |         for hook in self._lifecycle_hooks:
     |         ^^^
1056 |             if hook.on_completed:
1057 |                 hook.on_completed(
     |

invalid-syntax: Expected a simple statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1056:13
     |
1054 |     ) -> None:
1055 |         for hook in self._lifecycle_hooks:
1056 |             if hook.on_completed:
     |             ^^
1057 |                 hook.on_completed(
1058 |                     self,
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1066:5
     |
1064 |                 )
1065 |
1066 |     def notify_stage_failed(self, stage: str, stage_type: str, error: BaseException) -> None:
     |     ^^^
1067 |         for hook in self._lifecycle_hooks:
1068 |             if hook.on_failed:
     |

invalid-syntax: Expected a simple statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1067:9
     |
1066 |     def notify_stage_failed(self, stage: str, stage_type: str, error: BaseException) -> None:
1067 |         for hook in self._lifecycle_hooks:
     |         ^^^
1068 |             if hook.on_failed:
1069 |                 hook.on_failed(self, stage, stage_type, error)
     |

invalid-syntax: Expected a simple statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1068:13
     |
1066 |     def notify_stage_failed(self, stage: str, stage_type: str, error: BaseException) -> None:
1067 |         for hook in self._lifecycle_hooks:
1068 |             if hook.on_failed:
     |             ^^
1069 |                 hook.on_failed(self, stage, stage_type, error)
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1071:5
     |
1069 |                 hook.on_failed(self, stage, stage_type, error)
1070 |
1071 |     def profiling_summary(self) -> dict[str, Any]:
     |     ^^^
1072 |         """Return aggregated profiling metrics recorded for the pipeline run."""
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1074:9
     |
1072 |         """Return aggregated profiling metrics recorded for the pipeline run."""
1073 |
1074 |         return self._profiler.summary()
     |         ^^^^^^
1075 |
1076 |     def profiling_samples(self) -> tuple[StagePerformanceSample, ...]:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1076:5
     |
1074 |         return self._profiler.summary()
1075 |
1076 |     def profiling_samples(self) -> tuple[StagePerformanceSample, ...]:
     |     ^^^
1077 |         return tuple(self._profiler.samples)
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1080:5
     |
1079 |     @property
1080 |     def tenant_id(self) -> str:
     |     ^^^
1081 |         """Return the tenant that owns the current state."""
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1083:9
     |
1081 |         """Return the tenant that owns the current state."""
1082 |
1083 |         return self._tenant_id
     |         ^^^^^^
1084 |
1085 |     @staticmethod
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1086:5
     |
1085 |     @staticmethod
1086 |     def _checkpoint_label(label: str | None) -> str:
     |     ^^^
1087 |         return label or "__default__"
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1089:5
     |
1087 |         return label or "__default__"
1088 |
1089 |     def create_checkpoint(
     |     ^^^
1090 |         self,
1091 |         label: str | None = None,
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1097:9
     |
1095 |         """Capture and store a checkpoint snapshot for later rollback."""
1096 |
1097 |         snapshot = self.snapshot(include_stage_results=include_stage_results)
     |         ^^^^^^^^
1098 |         self._checkpoints[self._checkpoint_label(label)] = snapshot
1099 |         logger.debug(
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1098:9
     |
1097 |         snapshot = self.snapshot(include_stage_results=include_stage_results)
1098 |         self._checkpoints[self._checkpoint_label(label)] = snapshot
     |         ^^^^
1099 |         logger.debug(
1100 |             "pipeline_state.checkpoint_created",
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1099:9
     |
1097 |         snapshot = self.snapshot(include_stage_results=include_stage_results)
1098 |         self._checkpoints[self._checkpoint_label(label)] = snapshot
1099 |         logger.debug(
     |         ^^^^^^
1100 |             "pipeline_state.checkpoint_created",
1101 |             label=self._checkpoint_label(label),
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1104:9
     |
1102 |             tenant_id=self._tenant_id,
1103 |         )
1104 |         return snapshot
     |         ^^^^^^
1105 |
1106 |     def get_checkpoint(self, label: str | None = None) -> PipelineStateSnapshot | None:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1106:5
     |
1104 |         return snapshot
1105 |
1106 |     def get_checkpoint(self, label: str | None = None) -> PipelineStateSnapshot | None:
     |     ^^^
1107 |         """Return a previously captured checkpoint snapshot if it exists."""
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1109:9
     |
1107 |         """Return a previously captured checkpoint snapshot if it exists."""
1108 |
1109 |         return self._checkpoints.get(self._checkpoint_label(label))
     |         ^^^^^^
1110 |
1111 |     def has_checkpoint(self, label: str | None = None) -> bool:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1111:5
     |
1109 |         return self._checkpoints.get(self._checkpoint_label(label))
1110 |
1111 |     def has_checkpoint(self, label: str | None = None) -> bool:
     |     ^^^
1112 |         return self._checkpoint_label(label) in self._checkpoints
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1114:5
     |
1112 |         return self._checkpoint_label(label) in self._checkpoints
1113 |
1114 |     def rollback_to(
     |     ^^^
1115 |         self,
1116 |         label: str | None = None,
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1122:9
     |
1120 |         """Restore the pipeline to a stored checkpoint if available."""
1121 |
1122 |         snapshot = self.get_checkpoint(label)
     |         ^^^^^^^^
1123 |         if snapshot is not None:
1124 |             self.restore(snapshot, restore_stage_results=restore_stage_results)
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1123:32
     |
1122 |         snapshot = self.get_checkpoint(label)
1123 |         if snapshot is not None:
     |                                ^
1124 |             self.restore(snapshot, restore_stage_results=restore_stage_results)
1125 |             logger.debug(
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1125:13
     |
1123 |         if snapshot is not None:
1124 |             self.restore(snapshot, restore_stage_results=restore_stage_results)
1125 |             logger.debug(
     |             ^^^^^^
1126 |                 "pipeline_state.checkpoint_restored",
1127 |                 label=self._checkpoint_label(label),
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1130:9
     |
1128 |                 tenant_id=self._tenant_id,
1129 |             )
1130 |         return snapshot
     |         ^^^^^^
1131 |
1132 |     def clear_checkpoint(self, label: str | None = None) -> None:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1132:5
     |
1130 |         return snapshot
1131 |
1132 |     def clear_checkpoint(self, label: str | None = None) -> None:
     |     ^^^
1133 |         """Drop a previously stored checkpoint."""
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1135:9
     |
1133 |         """Drop a previously stored checkpoint."""
1134 |
1135 |         self._checkpoints.pop(self._checkpoint_label(label), None)
     |         ^^^^
1136 |
1137 |     def clear_checkpoints(self) -> None:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1137:5
     |
1135 |         self._checkpoints.pop(self._checkpoint_label(label), None)
1136 |
1137 |     def clear_checkpoints(self) -> None:
     |     ^^^
1138 |         """Remove all stored checkpoints."""
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1140:9
     |
1138 |         """Remove all stored checkpoints."""
1139 |
1140 |         self._checkpoints.clear()
     |         ^^^^
1141 |
1142 |     def ensure_tenant_scope(self, tenant_id: str) -> None:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1142:5
     |
1140 |         self._checkpoints.clear()
1141 |
1142 |     def ensure_tenant_scope(self, tenant_id: str) -> None:
     |     ^^^
1143 |         """Validate that the state is being accessed by the owning tenant."""
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1143:9
     |
1142 |       def ensure_tenant_scope(self, tenant_id: str) -> None:
1143 | /         """Validate that the state is being accessed by the owning tenant."""
1144 | |
1145 | |         if tenant_id != self._tenant_id:
     | |_______________________________________^
1146 |               raise PipelineStateValidationError(
1147 |                   f"PipelineState initialised for tenant '{self._tenant_id}' cannot be reused for tenant '{tenant_id}'"
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1145:40
     |
1143 |         """Validate that the state is being accessed by the owning tenant."""
1144 |
1145 |         if tenant_id != self._tenant_id:
     |                                        ^
1146 |             raise PipelineStateValidationError(
1147 |                 f"PipelineState initialised for tenant '{self._tenant_id}' cannot be reused for tenant '{tenant_id}'"
     |

invalid-syntax: Expected an identifier, but found a keyword 'raise' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1146:13
     |
1145 |         if tenant_id != self._tenant_id:
1146 |             raise PipelineStateValidationError(
     |             ^^^^^
1147 |                 f"PipelineState initialised for tenant '{self._tenant_id}' cannot be reused for tenant '{tenant_id}'"
1148 |             )
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1146:19
     |
1145 |         if tenant_id != self._tenant_id:
1146 |             raise PipelineStateValidationError(
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1147 |                 f"PipelineState initialised for tenant '{self._tenant_id}' cannot be reused for tenant '{tenant_id}'"
1148 |             )
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1150:5
     |
1148 |             )
1149 |
1150 |     def get_payloads(self) -> tuple[RawPayload, ...]:
     |     ^^^
1151 |         return self.payloads
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1153:5
     |
1151 |         return self.payloads
1152 |
1153 |     def set_payloads(self, payloads: Sequence[RawPayload]) -> None:
     |     ^^^
1154 |         self.payloads = tuple(payloads)
1155 |         self._mark_dirty()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1155:9
     |
1153 |     def set_payloads(self, payloads: Sequence[RawPayload]) -> None:
1154 |         self.payloads = tuple(payloads)
1155 |         self._mark_dirty()
     |         ^^^^
1156 |
1157 |     def require_payloads(self) -> tuple[RawPayload, ...]:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1157:5
     |
1155 |         self._mark_dirty()
1156 |
1157 |     def require_payloads(self) -> tuple[RawPayload, ...]:
     |     ^^^
1158 |         if not self.payloads:
1159 |             raise ValueError("PipelineState requires payloads before parse stage execution")
     |

invalid-syntax: Expected a simple statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1158:9
     |
1157 |     def require_payloads(self) -> tuple[RawPayload, ...]:
1158 |         if not self.payloads:
     |         ^^
1159 |             raise ValueError("PipelineState requires payloads before parse stage execution")
1160 |         return self.payloads
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1160:9
     |
1158 |         if not self.payloads:
1159 |             raise ValueError("PipelineState requires payloads before parse stage execution")
1160 |         return self.payloads
     |         ^^^^^^
1161 |
1162 |     def has_document(self) -> bool:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1162:5
     |
1160 |         return self.payloads
1161 |
1162 |     def has_document(self) -> bool:
     |     ^^^
1163 |         return self.document is not None
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1165:5
     |
1163 |         return self.document is not None
1164 |
1165 |     def set_document(self, document: Document) -> None:
     |     ^^^
1166 |         self.document = document
1167 |         self._mark_dirty()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1167:9
     |
1165 |     def set_document(self, document: Document) -> None:
1166 |         self.document = document
1167 |         self._mark_dirty()
     |         ^^^^
1168 |
1169 |     def require_document(self) -> Document:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1169:5
     |
1167 |         self._mark_dirty()
1168 |
1169 |     def require_document(self) -> Document:
     |     ^^^
1170 |         if self.document is None:
1171 |             raise ValueError("PipelineState does not contain a parsed document")
     |

invalid-syntax: Expected a simple statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1170:9
     |
1169 |     def require_document(self) -> Document:
1170 |         if self.document is None:
     |         ^^
1171 |             raise ValueError("PipelineState does not contain a parsed document")
1172 |         return self.document
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1172:9
     |
1170 |         if self.document is None:
1171 |             raise ValueError("PipelineState does not contain a parsed document")
1172 |         return self.document
     |         ^^^^^^
1173 |
1174 |     def has_chunks(self) -> bool:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1174:5
     |
1172 |         return self.document
1173 |
1174 |     def has_chunks(self) -> bool:
     |     ^^^
1175 |         return bool(self.chunks)
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1177:5
     |
1175 |         return bool(self.chunks)
1176 |
1177 |     def set_chunks(self, chunks: Sequence[Chunk]) -> None:
     |     ^^^
1178 |         self.chunks = tuple(chunks)
1179 |         self._mark_dirty()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1179:9
     |
1177 |     def set_chunks(self, chunks: Sequence[Chunk]) -> None:
1178 |         self.chunks = tuple(chunks)
1179 |         self._mark_dirty()
     |         ^^^^
1180 |
1181 |     def require_chunks(self) -> tuple[Chunk, ...]:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1181:5
     |
1179 |         self._mark_dirty()
1180 |
1181 |     def require_chunks(self) -> tuple[Chunk, ...]:
     |     ^^^
1182 |         if not self.chunks:
1183 |             raise ValueError("PipelineState does not contain document chunks")
     |

invalid-syntax: Expected a simple statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1182:9
     |
1181 |     def require_chunks(self) -> tuple[Chunk, ...]:
1182 |         if not self.chunks:
     |         ^^
1183 |             raise ValueError("PipelineState does not contain document chunks")
1184 |         return self.chunks
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1184:9
     |
1182 |         if not self.chunks:
1183 |             raise ValueError("PipelineState does not contain document chunks")
1184 |         return self.chunks
     |         ^^^^^^
1185 |
1186 |     def has_embeddings(self) -> bool:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1186:5
     |
1184 |         return self.chunks
1185 |
1186 |     def has_embeddings(self) -> bool:
     |     ^^^
1187 |         return self.embedding_batch is not None and bool(self.embedding_batch.vectors)
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1189:5
     |
1187 |         return self.embedding_batch is not None and bool(self.embedding_batch.vectors)
1188 |
1189 |     def set_embedding_batch(self, batch: EmbeddingBatch) -> None:
     |     ^^^
1190 |         self.embedding_batch = batch
1191 |         self._mark_dirty()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1191:9
     |
1189 |     def set_embedding_batch(self, batch: EmbeddingBatch) -> None:
1190 |         self.embedding_batch = batch
1191 |         self._mark_dirty()
     |         ^^^^
1192 |
1193 |     def require_embedding_batch(self) -> EmbeddingBatch:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1193:5
     |
1191 |         self._mark_dirty()
1192 |
1193 |     def require_embedding_batch(self) -> EmbeddingBatch:
     |     ^^^
1194 |         if self.embedding_batch is None:
1195 |             raise ValueError("PipelineState does not contain embedding results")
     |

invalid-syntax: Expected a simple statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1194:9
     |
1193 |     def require_embedding_batch(self) -> EmbeddingBatch:
1194 |         if self.embedding_batch is None:
     |         ^^
1195 |             raise ValueError("PipelineState does not contain embedding results")
1196 |         return self.embedding_batch
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1196:9
     |
1194 |         if self.embedding_batch is None:
1195 |             raise ValueError("PipelineState does not contain embedding results")
1196 |         return self.embedding_batch
     |         ^^^^^^
1197 |
1198 |     def set_entities_and_claims(
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1198:5
     |
1196 |         return self.embedding_batch
1197 |
1198 |     def set_entities_and_claims(
     |     ^^^
1199 |         self,
1200 |         entities: Sequence[Entity],
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1204:9
     |
1202 |     ) -> None:
1203 |         self.entities = tuple(entities)
1204 |         self.claims = tuple(claims)
     |         ^^^^
1205 |         self._mark_dirty()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1205:9
     |
1203 |         self.entities = tuple(entities)
1204 |         self.claims = tuple(claims)
1205 |         self._mark_dirty()
     |         ^^^^
1206 |
1207 |     def has_entities(self) -> bool:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1207:5
     |
1205 |         self._mark_dirty()
1206 |
1207 |     def has_entities(self) -> bool:
     |     ^^^
1208 |         return bool(self.entities)
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1210:5
     |
1208 |         return bool(self.entities)
1209 |
1210 |     def has_claims(self) -> bool:
     |     ^^^
1211 |         return bool(self.claims)
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1213:5
     |
1211 |         return bool(self.claims)
1212 |
1213 |     def require_entities(self) -> tuple[Entity, ...]:
     |     ^^^
1214 |         if not self.entities:
1215 |             raise ValueError("PipelineState does not contain extracted entities")
     |

invalid-syntax: Expected a simple statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1214:9
     |
1213 |     def require_entities(self) -> tuple[Entity, ...]:
1214 |         if not self.entities:
     |         ^^
1215 |             raise ValueError("PipelineState does not contain extracted entities")
1216 |         return self.entities
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1216:9
     |
1214 |         if not self.entities:
1215 |             raise ValueError("PipelineState does not contain extracted entities")
1216 |         return self.entities
     |         ^^^^^^
1217 |
1218 |     def require_claims(self) -> tuple[Claim, ...]:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1218:5
     |
1216 |         return self.entities
1217 |
1218 |     def require_claims(self) -> tuple[Claim, ...]:
     |     ^^^
1219 |         if not self.claims:
1220 |             raise ValueError("PipelineState does not contain extracted claims")
     |

invalid-syntax: Expected a simple statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1219:9
     |
1218 |     def require_claims(self) -> tuple[Claim, ...]:
1219 |         if not self.claims:
     |         ^^
1220 |             raise ValueError("PipelineState does not contain extracted claims")
1221 |         return self.claims
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1221:9
     |
1219 |         if not self.claims:
1220 |             raise ValueError("PipelineState does not contain extracted claims")
1221 |         return self.claims
     |         ^^^^^^
1222 |
1223 |     def set_index_receipt(self, receipt: IndexReceipt) -> None:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1223:5
     |
1221 |         return self.claims
1222 |
1223 |     def set_index_receipt(self, receipt: IndexReceipt) -> None:
     |     ^^^
1224 |         self.index_receipt = receipt
1225 |         self._mark_dirty()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1225:9
     |
1223 |     def set_index_receipt(self, receipt: IndexReceipt) -> None:
1224 |         self.index_receipt = receipt
1225 |         self._mark_dirty()
     |         ^^^^
1226 |
1227 |     def set_graph_receipt(self, receipt: GraphWriteReceipt) -> None:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1227:5
     |
1225 |         self._mark_dirty()
1226 |
1227 |     def set_graph_receipt(self, receipt: GraphWriteReceipt) -> None:
     |     ^^^
1228 |         self.graph_receipt = receipt
1229 |         self._mark_dirty()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1229:9
     |
1227 |     def set_graph_receipt(self, receipt: GraphWriteReceipt) -> None:
1228 |         self.graph_receipt = receipt
1229 |         self._mark_dirty()
     |         ^^^^
1230 |
1231 |     def set_downloads(self, artifacts: Sequence[DownloadArtifact]) -> None:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1231:5
     |
1229 |         self._mark_dirty()
1230 |
1231 |     def set_downloads(self, artifacts: Sequence[DownloadArtifact]) -> None:
     |     ^^^
1232 |         self.downloads = tuple(artifacts)
1233 |         self._mark_dirty()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1233:9
     |
1231 |     def set_downloads(self, artifacts: Sequence[DownloadArtifact]) -> None:
1232 |         self.downloads = tuple(artifacts)
1233 |         self._mark_dirty()
     |         ^^^^
1234 |
1235 |     def require_downloads(self) -> tuple[DownloadArtifact, ...]:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1235:5
     |
1233 |         self._mark_dirty()
1234 |
1235 |     def require_downloads(self) -> tuple[DownloadArtifact, ...]:
     |     ^^^
1236 |         if not self.downloads:
1237 |             raise ValueError("PipelineState does not contain download artefacts")
     |

invalid-syntax: Expected a simple statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1236:9
     |
1235 |     def require_downloads(self) -> tuple[DownloadArtifact, ...]:
1236 |         if not self.downloads:
     |         ^^
1237 |             raise ValueError("PipelineState does not contain download artefacts")
1238 |         return self.downloads
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1238:9
     |
1236 |         if not self.downloads:
1237 |             raise ValueError("PipelineState does not contain download artefacts")
1238 |         return self.downloads
     |         ^^^^^^
1239 |
1240 |     def record_gate_decision(self, decision: GateDecision) -> None:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1240:5
     |
1238 |         return self.downloads
1239 |
1240 |     def record_gate_decision(self, decision: GateDecision) -> None:
     |     ^^^
1241 |         self.gate_decisions[decision.name] = decision
1242 |         self._mark_dirty()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1242:9
     |
1240 |     def record_gate_decision(self, decision: GateDecision) -> None:
1241 |         self.gate_decisions[decision.name] = decision
1242 |         self._mark_dirty()
     |         ^^^^
1243 |
1244 |     def get_gate_decision(self, name: str) -> GateDecision | None:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1244:5
     |
1242 |         self._mark_dirty()
1243 |
1244 |     def get_gate_decision(self, name: str) -> GateDecision | None:
     |     ^^^
1245 |         return self.gate_decisions.get(name)
1246 |     def has_pdf_assets(self) -> bool:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1246:5
     |
1244 |     def get_gate_decision(self, name: str) -> GateDecision | None:
1245 |         return self.gate_decisions.get(name)
1246 |     def has_pdf_assets(self) -> bool:
     |     ^^^
1247 |         return bool(self.pdf_assets)
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1249:5
     |
1247 |         return bool(self.pdf_assets)
1248 |
1249 |     def set_pdf_assets(self, assets: Sequence[PdfAsset | Mapping[str, Any]]) -> None:
     |     ^^^
1250 |         converted: list[PdfAsset] = []
1251 |         for asset in assets:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1251:9
     |
1249 |     def set_pdf_assets(self, assets: Sequence[PdfAsset | Mapping[str, Any]]) -> None:
1250 |         converted: list[PdfAsset] = []
1251 |         for asset in assets:
     |         ^^^
1252 |             if isinstance(asset, PdfAsset):
1253 |                 converted.append(asset)
     |

invalid-syntax: Expected a simple statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1252:13
     |
1250 |         converted: list[PdfAsset] = []
1251 |         for asset in assets:
1252 |             if isinstance(asset, PdfAsset):
     |             ^^
1253 |                 converted.append(asset)
1254 |             elif isinstance(asset, Mapping):
     |

invalid-syntax: Expected newline, found 'elif'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1254:13
     |
1252 |             if isinstance(asset, PdfAsset):
1253 |                 converted.append(asset)
1254 |             elif isinstance(asset, Mapping):
     |             ^^^^
1255 |                 model = PdfAssetModel.model_validate(asset)
1256 |                 converted.append(
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1256:17
     |
1254 |             elif isinstance(asset, Mapping):
1255 |                 model = PdfAssetModel.model_validate(asset)
1256 |                 converted.append(
     |                 ^^^^^^^^^
1257 |                     PdfAsset(
1258 |                         asset_id=model.asset_id,
     |

invalid-syntax: Expected newline, found 'else'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1264:13
     |
1262 |                     )
1263 |                 )
1264 |             else:
     |             ^^^^
1265 |                 raise TypeError("PDF assets must be PdfAsset instances or mappings")
1266 |         self.pdf_assets = tuple(converted)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1266:9
     |
1264 |             else:
1265 |                 raise TypeError("PDF assets must be PdfAsset instances or mappings")
1266 |         self.pdf_assets = tuple(converted)
     |         ^^^^
1267 |         self.metadata.setdefault("pdf", {})["assets"] = [
1268 |             attr_asdict(asset) for asset in converted
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1267:9
     |
1265 |                 raise TypeError("PDF assets must be PdfAsset instances or mappings")
1266 |         self.pdf_assets = tuple(converted)
1267 |         self.metadata.setdefault("pdf", {})["assets"] = [
     |         ^^^^
1268 |             attr_asdict(asset) for asset in converted
1269 |         ]
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1270:9
     |
1268 |             attr_asdict(asset) for asset in converted
1269 |         ]
1270 |         self._mark_dirty()
     |         ^^^^
1271 |         _state_logger.debug("pipeline_state.pdf_assets.set", count=len(converted))
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1271:9
     |
1269 |         ]
1270 |         self._mark_dirty()
1271 |         _state_logger.debug("pipeline_state.pdf_assets.set", count=len(converted))
     |         ^^^^^^^^^^^^^
1272 |
1273 |     @property
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1274:5
     |
1273 |     @property
1274 |     def is_pdf_ready(self) -> bool:
     |     ^^^
1275 |         return any(self.gate_status.values())
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1277:5
     |
1275 |         return any(self.gate_status.values())
1276 |
1277 |     def record_gate_status(self, stage_name: str, ready: bool) -> None:
     |     ^^^
1278 |         self.gate_status[stage_name] = ready
1279 |         gates = self.metadata.setdefault("gates", {})
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1279:9
     |
1277 |     def record_gate_status(self, stage_name: str, ready: bool) -> None:
1278 |         self.gate_status[stage_name] = ready
1279 |         gates = self.metadata.setdefault("gates", {})
     |         ^^^^^
1280 |         gates[stage_name] = {"ready": ready, "timestamp": time.time()}
1281 |         self._mark_dirty()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1280:9
     |
1278 |         self.gate_status[stage_name] = ready
1279 |         gates = self.metadata.setdefault("gates", {})
1280 |         gates[stage_name] = {"ready": ready, "timestamp": time.time()}
     |         ^^^^^
1281 |         self._mark_dirty()
1282 |         _state_logger.debug("pipeline_state.gate.recorded", stage=stage_name, ready=ready)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1281:9
     |
1279 |         gates = self.metadata.setdefault("gates", {})
1280 |         gates[stage_name] = {"ready": ready, "timestamp": time.time()}
1281 |         self._mark_dirty()
     |         ^^^^
1282 |         _state_logger.debug("pipeline_state.gate.recorded", stage=stage_name, ready=ready)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1282:9
     |
1280 |         gates[stage_name] = {"ready": ready, "timestamp": time.time()}
1281 |         self._mark_dirty()
1282 |         _state_logger.debug("pipeline_state.gate.recorded", stage=stage_name, ready=ready)
     |         ^^^^^^^^^^^^^
1283 |
1284 |     def ensure_ready_for(self, stage_type: str) -> None:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1284:5
     |
1282 |         _state_logger.debug("pipeline_state.gate.recorded", stage=stage_name, ready=ready)
1283 |
1284 |     def ensure_ready_for(self, stage_type: str) -> None:
     |     ^^^
1285 |         """Validate preconditions required by the requested stage type."""
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1285:9
     |
1284 |       def ensure_ready_for(self, stage_type: str) -> None:
1285 | /         """Validate preconditions required by the requested stage type."""
1286 | |
1287 | |         if stage_type in {"parse", "ir-validation"}:
     | |___________________________________________________^
1288 |               self.require_payloads()
1289 |           elif stage_type == "download":
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1287:52
     |
1285 |         """Validate preconditions required by the requested stage type."""
1286 |
1287 |         if stage_type in {"parse", "ir-validation"}:
     |                                                    ^
1288 |             self.require_payloads()
1289 |         elif stage_type == "download":
     |

invalid-syntax: Expected newline, found 'elif'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1289:9
     |
1287 |         if stage_type in {"parse", "ir-validation"}:
1288 |             self.require_payloads()
1289 |         elif stage_type == "download":
     |         ^^^^
1290 |             self.require_payloads()
1291 |         elif stage_type == "chunk":
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1289:14
     |
1287 |         if stage_type in {"parse", "ir-validation"}:
1288 |             self.require_payloads()
1289 |         elif stage_type == "download":
     |              ^^^^^^^^^^^^^^^^^^^^^^^^
1290 |             self.require_payloads()
1291 |         elif stage_type == "chunk":
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1291:9
     |
1289 |         elif stage_type == "download":
1290 |             self.require_payloads()
1291 |         elif stage_type == "chunk":
     |         ^^^^
1292 |             self.require_document()
1293 |         elif stage_type == "embed":
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1291:14
     |
1289 |         elif stage_type == "download":
1290 |             self.require_payloads()
1291 |         elif stage_type == "chunk":
     |              ^^^^^^^^^^^^^^^^^^^^^
1292 |             self.require_document()
1293 |         elif stage_type == "embed":
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1293:9
     |
1291 |         elif stage_type == "chunk":
1292 |             self.require_document()
1293 |         elif stage_type == "embed":
     |         ^^^^
1294 |             self.require_chunks()
1295 |         elif stage_type == "index":
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1293:14
     |
1291 |         elif stage_type == "chunk":
1292 |             self.require_document()
1293 |         elif stage_type == "embed":
     |              ^^^^^^^^^^^^^^^^^^^^^
1294 |             self.require_chunks()
1295 |         elif stage_type == "index":
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1295:9
     |
1293 |         elif stage_type == "embed":
1294 |             self.require_chunks()
1295 |         elif stage_type == "index":
     |         ^^^^
1296 |             self.require_embedding_batch()
1297 |         elif stage_type == "extract":
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1295:14
     |
1293 |         elif stage_type == "embed":
1294 |             self.require_chunks()
1295 |         elif stage_type == "index":
     |              ^^^^^^^^^^^^^^^^^^^^^
1296 |             self.require_embedding_batch()
1297 |         elif stage_type == "extract":
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1297:9
     |
1295 |         elif stage_type == "index":
1296 |             self.require_embedding_batch()
1297 |         elif stage_type == "extract":
     |         ^^^^
1298 |             self.require_document()
1299 |         elif stage_type == "knowledge-graph":
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1297:14
     |
1295 |         elif stage_type == "index":
1296 |             self.require_embedding_batch()
1297 |         elif stage_type == "extract":
     |              ^^^^^^^^^^^^^^^^^^^^^^^
1298 |             self.require_document()
1299 |         elif stage_type == "knowledge-graph":
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1299:9
     |
1297 |         elif stage_type == "extract":
1298 |             self.require_document()
1299 |         elif stage_type == "knowledge-graph":
     |         ^^^^
1300 |             # Extraction stages may legitimately produce empty collections but the
1301 |             # state must contain the tuple marker.
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1299:14
     |
1297 |         elif stage_type == "extract":
1298 |             self.require_document()
1299 |         elif stage_type == "knowledge-graph":
     |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1300 |             # Extraction stages may legitimately produce empty collections but the
1301 |             # state must contain the tuple marker.
     |

invalid-syntax: Expected an identifier, but found a keyword 'if' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1302:13
     |
1300 |             # Extraction stages may legitimately produce empty collections but the
1301 |             # state must contain the tuple marker.
1302 |             if self.entities is None or self.claims is None:
     |             ^^
1303 |                 raise ValueError("PipelineState requires extraction outputs before KG stage")
1304 |         elif stage_type == "pdf-gate":
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1302:16
     |
1300 |             # Extraction stages may legitimately produce empty collections but the
1301 |             # state must contain the tuple marker.
1302 |             if self.entities is None or self.claims is None:
     |                ^^^^
1303 |                 raise ValueError("PipelineState requires extraction outputs before KG stage")
1304 |         elif stage_type == "pdf-gate":
     |

invalid-syntax: Expected an identifier, but found a keyword 'raise' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1303:17
     |
1301 |             # state must contain the tuple marker.
1302 |             if self.entities is None or self.claims is None:
1303 |                 raise ValueError("PipelineState requires extraction outputs before KG stage")
     |                 ^^^^^
1304 |         elif stage_type == "pdf-gate":
1305 |             if not self.pdf_tracker.downloads:
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1303:23
     |
1301 |             # state must contain the tuple marker.
1302 |             if self.entities is None or self.claims is None:
1303 |                 raise ValueError("PipelineState requires extraction outputs before KG stage")
     |                       ^^^^^^^^^^
1304 |         elif stage_type == "pdf-gate":
1305 |             if not self.pdf_tracker.downloads:
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1304:9
     |
1302 |             if self.entities is None or self.claims is None:
1303 |                 raise ValueError("PipelineState requires extraction outputs before KG stage")
1304 |         elif stage_type == "pdf-gate":
     |         ^^^^
1305 |             if not self.pdf_tracker.downloads:
1306 |                 raise ValueError("PDF gate cannot run before any downloads are recorded")
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1304:14
     |
1302 |             if self.entities is None or self.claims is None:
1303 |                 raise ValueError("PipelineState requires extraction outputs before KG stage")
1304 |         elif stage_type == "pdf-gate":
     |              ^^^^^^^^^^^^^^^^^^^^^^^^
1305 |             if not self.pdf_tracker.downloads:
1306 |                 raise ValueError("PDF gate cannot run before any downloads are recorded")
     |

invalid-syntax: Expected an identifier, but found a keyword 'if' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1305:13
     |
1303 |                 raise ValueError("PipelineState requires extraction outputs before KG stage")
1304 |         elif stage_type == "pdf-gate":
1305 |             if not self.pdf_tracker.downloads:
     |             ^^
1306 |                 raise ValueError("PDF gate cannot run before any downloads are recorded")
1307 |         elif stage_type == "gate":
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1305:16
     |
1303 |                 raise ValueError("PipelineState requires extraction outputs before KG stage")
1304 |         elif stage_type == "pdf-gate":
1305 |             if not self.pdf_tracker.downloads:
     |                ^^^
1306 |                 raise ValueError("PDF gate cannot run before any downloads are recorded")
1307 |         elif stage_type == "gate":
     |

invalid-syntax: Expected an identifier, but found a keyword 'raise' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1306:17
     |
1304 |         elif stage_type == "pdf-gate":
1305 |             if not self.pdf_tracker.downloads:
1306 |                 raise ValueError("PDF gate cannot run before any downloads are recorded")
     |                 ^^^^^
1307 |         elif stage_type == "gate":
1308 |             self.require_downloads()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1306:23
     |
1304 |         elif stage_type == "pdf-gate":
1305 |             if not self.pdf_tracker.downloads:
1306 |                 raise ValueError("PDF gate cannot run before any downloads are recorded")
     |                       ^^^^^^^^^^
1307 |         elif stage_type == "gate":
1308 |             self.require_downloads()
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1307:9
     |
1305 |             if not self.pdf_tracker.downloads:
1306 |                 raise ValueError("PDF gate cannot run before any downloads are recorded")
1307 |         elif stage_type == "gate":
     |         ^^^^
1308 |             self.require_downloads()
1309 |         elif stage_type == "download":
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1307:14
     |
1305 |             if not self.pdf_tracker.downloads:
1306 |                 raise ValueError("PDF gate cannot run before any downloads are recorded")
1307 |         elif stage_type == "gate":
     |              ^^^^^^^^^^^^^^^^^^^^
1308 |             self.require_downloads()
1309 |         elif stage_type == "download":
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1309:9
     |
1307 |         elif stage_type == "gate":
1308 |             self.require_downloads()
1309 |         elif stage_type == "download":
     |         ^^^^
1310 |             self.require_document()
1311 |         elif stage_type == "gate":
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1309:14
     |
1307 |         elif stage_type == "gate":
1308 |             self.require_downloads()
1309 |         elif stage_type == "download":
     |              ^^^^^^^^^^^^^^^^^^^^^^^^
1310 |             self.require_document()
1311 |         elif stage_type == "gate":
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1311:9
     |
1309 |         elif stage_type == "download":
1310 |             self.require_document()
1311 |         elif stage_type == "gate":
     |         ^^^^
1312 |             if not self.pdf_assets:
1313 |                 raise ValueError("PipelineState requires PDF assets before gate stage")
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1311:14
     |
1309 |         elif stage_type == "download":
1310 |             self.require_document()
1311 |         elif stage_type == "gate":
     |              ^^^^^^^^^^^^^^^^^^^^
1312 |             if not self.pdf_assets:
1313 |                 raise ValueError("PipelineState requires PDF assets before gate stage")
     |

invalid-syntax: Expected an identifier, but found a keyword 'if' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1312:13
     |
1310 |             self.require_document()
1311 |         elif stage_type == "gate":
1312 |             if not self.pdf_assets:
     |             ^^
1313 |                 raise ValueError("PipelineState requires PDF assets before gate stage")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1312:16
     |
1310 |             self.require_document()
1311 |         elif stage_type == "gate":
1312 |             if not self.pdf_assets:
     |                ^^^
1313 |                 raise ValueError("PipelineState requires PDF assets before gate stage")
     |

invalid-syntax: Expected an identifier, but found a keyword 'raise' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1313:17
     |
1311 |         elif stage_type == "gate":
1312 |             if not self.pdf_assets:
1313 |                 raise ValueError("PipelineState requires PDF assets before gate stage")
     |                 ^^^^^
1314 |
1315 |     # ------------------------------------------------------------------
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1313:23
     |
1311 |         elif stage_type == "gate":
1312 |             if not self.pdf_assets:
1313 |                 raise ValueError("PipelineState requires PDF assets before gate stage")
     |                       ^^^^^^^^^^
1314 |
1315 |     # ------------------------------------------------------------------
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1319:5
     |
1317 |     # ------------------------------------------------------------------
1318 |     @staticmethod
1319 |     def _stage_state_key(stage_type: str) -> str:
     |     ^^^
1320 |         return {
1321 |             "ingest": "payloads",
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1337:5
     |
1335 |         }.get(stage_type, stage_type)
1336 |
1337 |     def apply_stage_output(self, stage_type: str, stage_name: str, output: Any) -> None:
     |     ^^^
1338 |         """Persist a stage output onto the typed state structure."""
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1340:9
     |
1338 |         """Persist a stage output onto the typed state structure."""
1339 |
1340 |         key = self._stage_state_key(stage_type)
     |         ^^^
1341 |         if stage_type == "ingest":
1342 |             values = output or []
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1341:34
     |
1340 |         key = self._stage_state_key(stage_type)
1341 |         if stage_type == "ingest":
     |                                  ^
1342 |             values = output or []
1343 |             if not isinstance(values, Sequence):
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1343:48
     |
1341 |         if stage_type == "ingest":
1342 |             values = output or []
1343 |             if not isinstance(values, Sequence):
     |                                                ^
1344 |                 raise TypeError("Ingest stage must return a sequence of payloads")
1345 |             self.set_payloads(values)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1345:13
     |
1343 |             if not isinstance(values, Sequence):
1344 |                 raise TypeError("Ingest stage must return a sequence of payloads")
1345 |             self.set_payloads(values)
     |             ^^^^
1346 |         elif stage_type in {"parse", "ir-validation"}:
1347 |             if not isinstance(output, Document):
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1346:9
     |
1344 |                 raise TypeError("Ingest stage must return a sequence of payloads")
1345 |             self.set_payloads(values)
1346 |         elif stage_type in {"parse", "ir-validation"}:
     |         ^^^^
1347 |             if not isinstance(output, Document):
1348 |                 raise TypeError("Parse stages must return a Document instance")
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1346:14
     |
1344 |                 raise TypeError("Ingest stage must return a sequence of payloads")
1345 |             self.set_payloads(values)
1346 |         elif stage_type in {"parse", "ir-validation"}:
     |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1347 |             if not isinstance(output, Document):
1348 |                 raise TypeError("Parse stages must return a Document instance")
     |

invalid-syntax: Expected an identifier, but found a keyword 'if' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1347:13
     |
1345 |             self.set_payloads(values)
1346 |         elif stage_type in {"parse", "ir-validation"}:
1347 |             if not isinstance(output, Document):
     |             ^^
1348 |                 raise TypeError("Parse stages must return a Document instance")
1349 |             self.set_document(output)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1347:16
     |
1345 |             self.set_payloads(values)
1346 |         elif stage_type in {"parse", "ir-validation"}:
1347 |             if not isinstance(output, Document):
     |                ^^^
1348 |                 raise TypeError("Parse stages must return a Document instance")
1349 |             self.set_document(output)
     |

invalid-syntax: Expected an identifier, but found a keyword 'raise' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1348:17
     |
1346 |         elif stage_type in {"parse", "ir-validation"}:
1347 |             if not isinstance(output, Document):
1348 |                 raise TypeError("Parse stages must return a Document instance")
     |                 ^^^^^
1349 |             self.set_document(output)
1350 |         elif stage_type == "chunk":
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1348:23
     |
1346 |         elif stage_type in {"parse", "ir-validation"}:
1347 |             if not isinstance(output, Document):
1348 |                 raise TypeError("Parse stages must return a Document instance")
     |                       ^^^^^^^^^
1349 |             self.set_document(output)
1350 |         elif stage_type == "chunk":
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1349:13
     |
1347 |             if not isinstance(output, Document):
1348 |                 raise TypeError("Parse stages must return a Document instance")
1349 |             self.set_document(output)
     |             ^^^^
1350 |         elif stage_type == "chunk":
1351 |             if not isinstance(output, Sequence):
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1350:9
     |
1348 |                 raise TypeError("Parse stages must return a Document instance")
1349 |             self.set_document(output)
1350 |         elif stage_type == "chunk":
     |         ^^^^
1351 |             if not isinstance(output, Sequence):
1352 |                 raise TypeError("Chunk stage must return a sequence of Chunk instances")
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1350:14
     |
1348 |                 raise TypeError("Parse stages must return a Document instance")
1349 |             self.set_document(output)
1350 |         elif stage_type == "chunk":
     |              ^^^^^^^^^^^^^^^^^^^^^
1351 |             if not isinstance(output, Sequence):
1352 |                 raise TypeError("Chunk stage must return a sequence of Chunk instances")
     |

invalid-syntax: Expected an identifier, but found a keyword 'if' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1351:13
     |
1349 |             self.set_document(output)
1350 |         elif stage_type == "chunk":
1351 |             if not isinstance(output, Sequence):
     |             ^^
1352 |                 raise TypeError("Chunk stage must return a sequence of Chunk instances")
1353 |             self.set_chunks(output)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1351:16
     |
1349 |             self.set_document(output)
1350 |         elif stage_type == "chunk":
1351 |             if not isinstance(output, Sequence):
     |                ^^^
1352 |                 raise TypeError("Chunk stage must return a sequence of Chunk instances")
1353 |             self.set_chunks(output)
     |

invalid-syntax: Expected an identifier, but found a keyword 'raise' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1352:17
     |
1350 |         elif stage_type == "chunk":
1351 |             if not isinstance(output, Sequence):
1352 |                 raise TypeError("Chunk stage must return a sequence of Chunk instances")
     |                 ^^^^^
1353 |             self.set_chunks(output)
1354 |         elif stage_type == "embed":
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1352:23
     |
1350 |         elif stage_type == "chunk":
1351 |             if not isinstance(output, Sequence):
1352 |                 raise TypeError("Chunk stage must return a sequence of Chunk instances")
     |                       ^^^^^^^^^
1353 |             self.set_chunks(output)
1354 |         elif stage_type == "embed":
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1353:13
     |
1351 |             if not isinstance(output, Sequence):
1352 |                 raise TypeError("Chunk stage must return a sequence of Chunk instances")
1353 |             self.set_chunks(output)
     |             ^^^^
1354 |         elif stage_type == "embed":
1355 |             if not isinstance(output, EmbeddingBatch):
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1354:9
     |
1352 |                 raise TypeError("Chunk stage must return a sequence of Chunk instances")
1353 |             self.set_chunks(output)
1354 |         elif stage_type == "embed":
     |         ^^^^
1355 |             if not isinstance(output, EmbeddingBatch):
1356 |                 raise TypeError("Embed stage must return an EmbeddingBatch")
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1354:14
     |
1352 |                 raise TypeError("Chunk stage must return a sequence of Chunk instances")
1353 |             self.set_chunks(output)
1354 |         elif stage_type == "embed":
     |              ^^^^^^^^^^^^^^^^^^^^^
1355 |             if not isinstance(output, EmbeddingBatch):
1356 |                 raise TypeError("Embed stage must return an EmbeddingBatch")
     |

invalid-syntax: Expected an identifier, but found a keyword 'if' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1355:13
     |
1353 |             self.set_chunks(output)
1354 |         elif stage_type == "embed":
1355 |             if not isinstance(output, EmbeddingBatch):
     |             ^^
1356 |                 raise TypeError("Embed stage must return an EmbeddingBatch")
1357 |             self.set_embedding_batch(output)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1355:16
     |
1353 |             self.set_chunks(output)
1354 |         elif stage_type == "embed":
1355 |             if not isinstance(output, EmbeddingBatch):
     |                ^^^
1356 |                 raise TypeError("Embed stage must return an EmbeddingBatch")
1357 |             self.set_embedding_batch(output)
     |

invalid-syntax: Expected an identifier, but found a keyword 'raise' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1356:17
     |
1354 |         elif stage_type == "embed":
1355 |             if not isinstance(output, EmbeddingBatch):
1356 |                 raise TypeError("Embed stage must return an EmbeddingBatch")
     |                 ^^^^^
1357 |             self.set_embedding_batch(output)
1358 |         elif stage_type == "index":
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1356:23
     |
1354 |         elif stage_type == "embed":
1355 |             if not isinstance(output, EmbeddingBatch):
1356 |                 raise TypeError("Embed stage must return an EmbeddingBatch")
     |                       ^^^^^^^^^
1357 |             self.set_embedding_batch(output)
1358 |         elif stage_type == "index":
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1357:13
     |
1355 |             if not isinstance(output, EmbeddingBatch):
1356 |                 raise TypeError("Embed stage must return an EmbeddingBatch")
1357 |             self.set_embedding_batch(output)
     |             ^^^^
1358 |         elif stage_type == "index":
1359 |             if not isinstance(output, IndexReceipt):
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1358:9
     |
1356 |                 raise TypeError("Embed stage must return an EmbeddingBatch")
1357 |             self.set_embedding_batch(output)
1358 |         elif stage_type == "index":
     |         ^^^^
1359 |             if not isinstance(output, IndexReceipt):
1360 |                 raise TypeError("Index stage must return an IndexReceipt")
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1358:14
     |
1356 |                 raise TypeError("Embed stage must return an EmbeddingBatch")
1357 |             self.set_embedding_batch(output)
1358 |         elif stage_type == "index":
     |              ^^^^^^^^^^^^^^^^^^^^^
1359 |             if not isinstance(output, IndexReceipt):
1360 |                 raise TypeError("Index stage must return an IndexReceipt")
     |

invalid-syntax: Expected an identifier, but found a keyword 'if' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1359:13
     |
1357 |             self.set_embedding_batch(output)
1358 |         elif stage_type == "index":
1359 |             if not isinstance(output, IndexReceipt):
     |             ^^
1360 |                 raise TypeError("Index stage must return an IndexReceipt")
1361 |             self.set_index_receipt(output)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1359:16
     |
1357 |             self.set_embedding_batch(output)
1358 |         elif stage_type == "index":
1359 |             if not isinstance(output, IndexReceipt):
     |                ^^^
1360 |                 raise TypeError("Index stage must return an IndexReceipt")
1361 |             self.set_index_receipt(output)
     |

invalid-syntax: Expected an identifier, but found a keyword 'raise' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1360:17
     |
1358 |         elif stage_type == "index":
1359 |             if not isinstance(output, IndexReceipt):
1360 |                 raise TypeError("Index stage must return an IndexReceipt")
     |                 ^^^^^
1361 |             self.set_index_receipt(output)
1362 |         elif stage_type == "extract":
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1360:23
     |
1358 |         elif stage_type == "index":
1359 |             if not isinstance(output, IndexReceipt):
1360 |                 raise TypeError("Index stage must return an IndexReceipt")
     |                       ^^^^^^^^^
1361 |             self.set_index_receipt(output)
1362 |         elif stage_type == "extract":
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1361:13
     |
1359 |             if not isinstance(output, IndexReceipt):
1360 |                 raise TypeError("Index stage must return an IndexReceipt")
1361 |             self.set_index_receipt(output)
     |             ^^^^
1362 |         elif stage_type == "extract":
1363 |             if (
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1362:9
     |
1360 |                 raise TypeError("Index stage must return an IndexReceipt")
1361 |             self.set_index_receipt(output)
1362 |         elif stage_type == "extract":
     |         ^^^^
1363 |             if (
1364 |                 not isinstance(output, tuple)
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1362:14
     |
1360 |                 raise TypeError("Index stage must return an IndexReceipt")
1361 |             self.set_index_receipt(output)
1362 |         elif stage_type == "extract":
     |              ^^^^^^^^^^^^^^^^^^^^^^^
1363 |             if (
1364 |                 not isinstance(output, tuple)
     |

invalid-syntax: Expected an identifier, but found a keyword 'if' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1363:13
     |
1361 |             self.set_index_receipt(output)
1362 |         elif stage_type == "extract":
1363 |             if (
     |             ^^
1364 |                 not isinstance(output, tuple)
1365 |                 or len(output) != 2
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1368:14
     |
1366 |                 or not isinstance(output[0], Sequence)
1367 |                 or not isinstance(output[1], Sequence)
1368 |             ):
     |              ^
1369 |                 raise TypeError("Extract stage must return a tuple of entity and claim sequences")
1370 |             entities, claims = output
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1370:13
     |
1368 |             ):
1369 |                 raise TypeError("Extract stage must return a tuple of entity and claim sequences")
1370 |             entities, claims = output
     |             ^^^^^^^^
1371 |             self.set_entities_and_claims(entities, claims)
1372 |         elif stage_type == "knowledge-graph":
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1371:13
     |
1369 |                 raise TypeError("Extract stage must return a tuple of entity and claim sequences")
1370 |             entities, claims = output
1371 |             self.set_entities_and_claims(entities, claims)
     |             ^^^^
1372 |         elif stage_type == "knowledge-graph":
1373 |             if not isinstance(output, GraphWriteReceipt):
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1372:9
     |
1370 |             entities, claims = output
1371 |             self.set_entities_and_claims(entities, claims)
1372 |         elif stage_type == "knowledge-graph":
     |         ^^^^
1373 |             if not isinstance(output, GraphWriteReceipt):
1374 |                 raise TypeError("Knowledge graph stage must return a GraphWriteReceipt")
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1372:14
     |
1370 |             entities, claims = output
1371 |             self.set_entities_and_claims(entities, claims)
1372 |         elif stage_type == "knowledge-graph":
     |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1373 |             if not isinstance(output, GraphWriteReceipt):
1374 |                 raise TypeError("Knowledge graph stage must return a GraphWriteReceipt")
     |

invalid-syntax: Expected an identifier, but found a keyword 'if' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1373:13
     |
1371 |             self.set_entities_and_claims(entities, claims)
1372 |         elif stage_type == "knowledge-graph":
1373 |             if not isinstance(output, GraphWriteReceipt):
     |             ^^
1374 |                 raise TypeError("Knowledge graph stage must return a GraphWriteReceipt")
1375 |             self.set_graph_receipt(output)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1373:16
     |
1371 |             self.set_entities_and_claims(entities, claims)
1372 |         elif stage_type == "knowledge-graph":
1373 |             if not isinstance(output, GraphWriteReceipt):
     |                ^^^
1374 |                 raise TypeError("Knowledge graph stage must return a GraphWriteReceipt")
1375 |             self.set_graph_receipt(output)
     |

invalid-syntax: Expected an identifier, but found a keyword 'raise' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1374:17
     |
1372 |         elif stage_type == "knowledge-graph":
1373 |             if not isinstance(output, GraphWriteReceipt):
1374 |                 raise TypeError("Knowledge graph stage must return a GraphWriteReceipt")
     |                 ^^^^^
1375 |             self.set_graph_receipt(output)
1376 |         elif stage_type == "pdf-download":
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1374:23
     |
1372 |         elif stage_type == "knowledge-graph":
1373 |             if not isinstance(output, GraphWriteReceipt):
1374 |                 raise TypeError("Knowledge graph stage must return a GraphWriteReceipt")
     |                       ^^^^^^^^^
1375 |             self.set_graph_receipt(output)
1376 |         elif stage_type == "pdf-download":
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1375:13
     |
1373 |             if not isinstance(output, GraphWriteReceipt):
1374 |                 raise TypeError("Knowledge graph stage must return a GraphWriteReceipt")
1375 |             self.set_graph_receipt(output)
     |             ^^^^
1376 |         elif stage_type == "pdf-download":
1377 |             assets = output or ()
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1376:9
     |
1374 |                 raise TypeError("Knowledge graph stage must return a GraphWriteReceipt")
1375 |             self.set_graph_receipt(output)
1376 |         elif stage_type == "pdf-download":
     |         ^^^^
1377 |             assets = output or ()
1378 |             if isinstance(assets, Sequence) and not isinstance(assets, (str, bytes)):
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1376:14
     |
1374 |                 raise TypeError("Knowledge graph stage must return a GraphWriteReceipt")
1375 |             self.set_graph_receipt(output)
1376 |         elif stage_type == "pdf-download":
     |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1377 |             assets = output or ()
1378 |             if isinstance(assets, Sequence) and not isinstance(assets, (str, bytes)):
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1378:85
     |
1376 |         elif stage_type == "pdf-download":
1377 |             assets = output or ()
1378 |             if isinstance(assets, Sequence) and not isinstance(assets, (str, bytes)):
     |                                                                                     ^
1379 |                 for asset in assets:
1380 |                     self.pdf_tracker.record_download(str(asset))
     |

invalid-syntax: Expected newline, found 'else'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1381:13
     |
1379 |                 for asset in assets:
1380 |                     self.pdf_tracker.record_download(str(asset))
1381 |             else:
     |             ^^^^
1382 |                 self.pdf_tracker.record_download(str(assets))
1383 |             self._mark_dirty()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1383:13
     |
1381 |             else:
1382 |                 self.pdf_tracker.record_download(str(assets))
1383 |             self._mark_dirty()
     |             ^^^^
1384 |         elif stage_type == "pdf-gate":
1385 |             decision = getattr(output, "allowed", None)
     |

invalid-syntax: Expected newline, found 'elif'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1384:9
     |
1382 |                 self.pdf_tracker.record_download(str(assets))
1383 |             self._mark_dirty()
1384 |         elif stage_type == "pdf-gate":
     |         ^^^^
1385 |             decision = getattr(output, "allowed", None)
1386 |             if decision is None:
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1384:14
     |
1382 |                 self.pdf_tracker.record_download(str(assets))
1383 |             self._mark_dirty()
1384 |         elif stage_type == "pdf-gate":
     |              ^^^^^^^^^^^^^^^^^^^^^^^^
1385 |             decision = getattr(output, "allowed", None)
1386 |             if decision is None:
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1386:32
     |
1384 |         elif stage_type == "pdf-gate":
1385 |             decision = getattr(output, "allowed", None)
1386 |             if decision is None:
     |                                ^
1387 |                 decision = bool(output)
1388 |             reason = getattr(output, "reason", None)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1388:13
     |
1386 |             if decision is None:
1387 |                 decision = bool(output)
1388 |             reason = getattr(output, "reason", None)
     |             ^^^^^^
1389 |             self.pdf_tracker.mark_gate(opened=bool(decision), reason=reason)
1390 |             reference = getattr(output, "ledger_reference", None)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1389:13
     |
1387 |                 decision = bool(output)
1388 |             reason = getattr(output, "reason", None)
1389 |             self.pdf_tracker.mark_gate(opened=bool(decision), reason=reason)
     |             ^^^^
1390 |             reference = getattr(output, "ledger_reference", None)
1391 |             if reference is not None:
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1390:13
     |
1388 |             reason = getattr(output, "reason", None)
1389 |             self.pdf_tracker.mark_gate(opened=bool(decision), reason=reason)
1390 |             reference = getattr(output, "ledger_reference", None)
     |             ^^^^^^^^^
1391 |             if reference is not None:
1392 |                 self.pdf_tracker.set_ledger_reference(str(reference))
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1391:37
     |
1389 |             self.pdf_tracker.mark_gate(opened=bool(decision), reason=reason)
1390 |             reference = getattr(output, "ledger_reference", None)
1391 |             if reference is not None:
     |                                     ^
1392 |                 self.pdf_tracker.set_ledger_reference(str(reference))
1393 |             self._mark_dirty()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1393:13
     |
1391 |             if reference is not None:
1392 |                 self.pdf_tracker.set_ledger_reference(str(reference))
1393 |             self._mark_dirty()
     |             ^^^^
1394 |         elif stage_type == "download":
1395 |             if not isinstance(output, Sequence) or not all(
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1394:9
     |
1392 |                 self.pdf_tracker.set_ledger_reference(str(reference))
1393 |             self._mark_dirty()
1394 |         elif stage_type == "download":
     |         ^^^^
1395 |             if not isinstance(output, Sequence) or not all(
1396 |                 isinstance(item, DownloadArtifact) for item in output
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1394:14
     |
1392 |                 self.pdf_tracker.set_ledger_reference(str(reference))
1393 |             self._mark_dirty()
1394 |         elif stage_type == "download":
     |              ^^^^^^^^^^^^^^^^^^^^^^^^
1395 |             if not isinstance(output, Sequence) or not all(
1396 |                 isinstance(item, DownloadArtifact) for item in output
     |

invalid-syntax: Expected an identifier, but found a keyword 'if' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1395:13
     |
1393 |             self._mark_dirty()
1394 |         elif stage_type == "download":
1395 |             if not isinstance(output, Sequence) or not all(
     |             ^^
1396 |                 isinstance(item, DownloadArtifact) for item in output
1397 |             ):
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1395:16
     |
1393 |             self._mark_dirty()
1394 |         elif stage_type == "download":
1395 |             if not isinstance(output, Sequence) or not all(
     |                ^^^
1396 |                 isinstance(item, DownloadArtifact) for item in output
1397 |             ):
     |

invalid-syntax: Expected an identifier, but found a keyword 'raise' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1398:17
     |
1396 |                 isinstance(item, DownloadArtifact) for item in output
1397 |             ):
1398 |                 raise TypeError("Download stage must return DownloadArtifact instances")
     |                 ^^^^^
1399 |             self.set_downloads(output)
1400 |         elif stage_type == "gate":
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1398:23
     |
1396 |                 isinstance(item, DownloadArtifact) for item in output
1397 |             ):
1398 |                 raise TypeError("Download stage must return DownloadArtifact instances")
     |                       ^^^^^^^^^
1399 |             self.set_downloads(output)
1400 |         elif stage_type == "gate":
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1399:13
     |
1397 |             ):
1398 |                 raise TypeError("Download stage must return DownloadArtifact instances")
1399 |             self.set_downloads(output)
     |             ^^^^
1400 |         elif stage_type == "gate":
1401 |             if not isinstance(output, GateDecision):
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1400:9
     |
1398 |                 raise TypeError("Download stage must return DownloadArtifact instances")
1399 |             self.set_downloads(output)
1400 |         elif stage_type == "gate":
     |         ^^^^
1401 |             if not isinstance(output, GateDecision):
1402 |                 raise TypeError("Gate stage must return a GateDecision")
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1400:14
     |
1398 |                 raise TypeError("Download stage must return DownloadArtifact instances")
1399 |             self.set_downloads(output)
1400 |         elif stage_type == "gate":
     |              ^^^^^^^^^^^^^^^^^^^^
1401 |             if not isinstance(output, GateDecision):
1402 |                 raise TypeError("Gate stage must return a GateDecision")
     |

invalid-syntax: Expected an identifier, but found a keyword 'if' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1401:13
     |
1399 |             self.set_downloads(output)
1400 |         elif stage_type == "gate":
1401 |             if not isinstance(output, GateDecision):
     |             ^^
1402 |                 raise TypeError("Gate stage must return a GateDecision")
1403 |             self.record_gate_decision(output)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1401:16
     |
1399 |             self.set_downloads(output)
1400 |         elif stage_type == "gate":
1401 |             if not isinstance(output, GateDecision):
     |                ^^^
1402 |                 raise TypeError("Gate stage must return a GateDecision")
1403 |             self.record_gate_decision(output)
     |

invalid-syntax: Expected an identifier, but found a keyword 'raise' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1402:17
     |
1400 |         elif stage_type == "gate":
1401 |             if not isinstance(output, GateDecision):
1402 |                 raise TypeError("Gate stage must return a GateDecision")
     |                 ^^^^^
1403 |             self.record_gate_decision(output)
1404 |         elif stage_type == "pdf-download":
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1402:23
     |
1400 |         elif stage_type == "gate":
1401 |             if not isinstance(output, GateDecision):
1402 |                 raise TypeError("Gate stage must return a GateDecision")
     |                       ^^^^^^^^^
1403 |             self.record_gate_decision(output)
1404 |         elif stage_type == "pdf-download":
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1403:13
     |
1401 |             if not isinstance(output, GateDecision):
1402 |                 raise TypeError("Gate stage must return a GateDecision")
1403 |             self.record_gate_decision(output)
     |             ^^^^
1404 |         elif stage_type == "pdf-download":
1405 |             metadata = output if isinstance(output, Mapping) else None
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1404:9
     |
1402 |                 raise TypeError("Gate stage must return a GateDecision")
1403 |             self.record_gate_decision(output)
1404 |         elif stage_type == "pdf-download":
     |         ^^^^
1405 |             metadata = output if isinstance(output, Mapping) else None
1406 |             self.mark_pdf_downloaded(metadata=metadata)
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1404:14
     |
1402 |                 raise TypeError("Gate stage must return a GateDecision")
1403 |             self.record_gate_decision(output)
1404 |         elif stage_type == "pdf-download":
     |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1405 |             metadata = output if isinstance(output, Mapping) else None
1406 |             self.mark_pdf_downloaded(metadata=metadata)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1406:13
     |
1404 |         elif stage_type == "pdf-download":
1405 |             metadata = output if isinstance(output, Mapping) else None
1406 |             self.mark_pdf_downloaded(metadata=metadata)
     |             ^^^^
1407 |         elif stage_type == "pdf-ir-gate":
1408 |             metadata = output if isinstance(output, Mapping) else None
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1407:9
     |
1405 |             metadata = output if isinstance(output, Mapping) else None
1406 |             self.mark_pdf_downloaded(metadata=metadata)
1407 |         elif stage_type == "pdf-ir-gate":
     |         ^^^^
1408 |             metadata = output if isinstance(output, Mapping) else None
1409 |             self.mark_pdf_ir_ready(metadata=metadata)
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1407:14
     |
1405 |             metadata = output if isinstance(output, Mapping) else None
1406 |             self.mark_pdf_downloaded(metadata=metadata)
1407 |         elif stage_type == "pdf-ir-gate":
     |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
1408 |             metadata = output if isinstance(output, Mapping) else None
1409 |             self.mark_pdf_ir_ready(metadata=metadata)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1409:13
     |
1407 |         elif stage_type == "pdf-ir-gate":
1408 |             metadata = output if isinstance(output, Mapping) else None
1409 |             self.mark_pdf_ir_ready(metadata=metadata)
     |             ^^^^
1410 |         elif stage_type == "download":
1411 |             if not isinstance(output, Sequence):
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1410:9
     |
1408 |             metadata = output if isinstance(output, Mapping) else None
1409 |             self.mark_pdf_ir_ready(metadata=metadata)
1410 |         elif stage_type == "download":
     |         ^^^^
1411 |             if not isinstance(output, Sequence):
1412 |                 raise TypeError("Download stage must return a sequence of PDF assets")
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1410:14
     |
1408 |             metadata = output if isinstance(output, Mapping) else None
1409 |             self.mark_pdf_ir_ready(metadata=metadata)
1410 |         elif stage_type == "download":
     |              ^^^^^^^^^^^^^^^^^^^^^^^^
1411 |             if not isinstance(output, Sequence):
1412 |                 raise TypeError("Download stage must return a sequence of PDF assets")
     |

invalid-syntax: Expected an identifier, but found a keyword 'if' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1411:13
     |
1409 |             self.mark_pdf_ir_ready(metadata=metadata)
1410 |         elif stage_type == "download":
1411 |             if not isinstance(output, Sequence):
     |             ^^
1412 |                 raise TypeError("Download stage must return a sequence of PDF assets")
1413 |             self.set_pdf_assets(output)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1411:16
     |
1409 |             self.mark_pdf_ir_ready(metadata=metadata)
1410 |         elif stage_type == "download":
1411 |             if not isinstance(output, Sequence):
     |                ^^^
1412 |                 raise TypeError("Download stage must return a sequence of PDF assets")
1413 |             self.set_pdf_assets(output)
     |

invalid-syntax: Expected an identifier, but found a keyword 'raise' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1412:17
     |
1410 |         elif stage_type == "download":
1411 |             if not isinstance(output, Sequence):
1412 |                 raise TypeError("Download stage must return a sequence of PDF assets")
     |                 ^^^^^
1413 |             self.set_pdf_assets(output)
1414 |         elif stage_type == "gate":
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1412:23
     |
1410 |         elif stage_type == "download":
1411 |             if not isinstance(output, Sequence):
1412 |                 raise TypeError("Download stage must return a sequence of PDF assets")
     |                       ^^^^^^^^^
1413 |             self.set_pdf_assets(output)
1414 |         elif stage_type == "gate":
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1413:13
     |
1411 |             if not isinstance(output, Sequence):
1412 |                 raise TypeError("Download stage must return a sequence of PDF assets")
1413 |             self.set_pdf_assets(output)
     |             ^^^^
1414 |         elif stage_type == "gate":
1415 |             if not isinstance(output, bool):
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1414:9
     |
1412 |                 raise TypeError("Download stage must return a sequence of PDF assets")
1413 |             self.set_pdf_assets(output)
1414 |         elif stage_type == "gate":
     |         ^^^^
1415 |             if not isinstance(output, bool):
1416 |                 raise TypeError("Gate stage must return a boolean readiness flag")
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1414:14
     |
1412 |                 raise TypeError("Download stage must return a sequence of PDF assets")
1413 |             self.set_pdf_assets(output)
1414 |         elif stage_type == "gate":
     |              ^^^^^^^^^^^^^^^^^^^^
1415 |             if not isinstance(output, bool):
1416 |                 raise TypeError("Gate stage must return a boolean readiness flag")
     |

invalid-syntax: Expected an identifier, but found a keyword 'if' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1415:13
     |
1413 |             self.set_pdf_assets(output)
1414 |         elif stage_type == "gate":
1415 |             if not isinstance(output, bool):
     |             ^^
1416 |                 raise TypeError("Gate stage must return a boolean readiness flag")
1417 |             self.record_gate_status(stage_name, output)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1415:16
     |
1413 |             self.set_pdf_assets(output)
1414 |         elif stage_type == "gate":
1415 |             if not isinstance(output, bool):
     |                ^^^
1416 |                 raise TypeError("Gate stage must return a boolean readiness flag")
1417 |             self.record_gate_status(stage_name, output)
     |

invalid-syntax: Expected an identifier, but found a keyword 'raise' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1416:17
     |
1414 |         elif stage_type == "gate":
1415 |             if not isinstance(output, bool):
1416 |                 raise TypeError("Gate stage must return a boolean readiness flag")
     |                 ^^^^^
1417 |             self.record_gate_status(stage_name, output)
1418 |         else:
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1416:23
     |
1414 |         elif stage_type == "gate":
1415 |             if not isinstance(output, bool):
1416 |                 raise TypeError("Gate stage must return a boolean readiness flag")
     |                       ^^^^^^^^^
1417 |             self.record_gate_status(stage_name, output)
1418 |         else:
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1417:13
     |
1415 |             if not isinstance(output, bool):
1416 |                 raise TypeError("Gate stage must return a boolean readiness flag")
1417 |             self.record_gate_status(stage_name, output)
     |             ^^^^
1418 |         else:
1419 |             self.metadata[key] = output
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1418:9
     |
1416 |                 raise TypeError("Gate stage must return a boolean readiness flag")
1417 |             self.record_gate_status(stage_name, output)
1418 |         else:
     |         ^^^^
1419 |             self.metadata[key] = output
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1418:13
     |
1416 |                 raise TypeError("Gate stage must return a boolean readiness flag")
1417 |             self.record_gate_status(stage_name, output)
1418 |         else:
     |             ^
1419 |             self.metadata[key] = output
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1421:9
     |
1419 |             self.metadata[key] = output
1420 |
1421 |         self.stage_results[stage_name] = StageResultSnapshot(stage=stage_name, stage_type=stage_type)
     |         ^^^^
1422 |         self._mark_dirty()
1423 |         _state_logger.debug(
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1422:9
     |
1421 |         self.stage_results[stage_name] = StageResultSnapshot(stage=stage_name, stage_type=stage_type)
1422 |         self._mark_dirty()
     |         ^^^^
1423 |         _state_logger.debug(
1424 |             "pipeline_state.stage_applied",
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1423:9
     |
1421 |         self.stage_results[stage_name] = StageResultSnapshot(stage=stage_name, stage_type=stage_type)
1422 |         self._mark_dirty()
1423 |         _state_logger.debug(
     |         ^^^^^^^^^^^^^
1424 |             "pipeline_state.stage_applied",
1425 |         logger.debug(
     |

invalid-syntax: Expected ')', found NonLogicalNewline
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1430:10
     |
1428 |             stage_type=stage_type,
1429 |             tenant_id=self._tenant_id,
1430 |         )
     |          ^
1431 |
1432 |     def infer_output_count(self, stage_type: str, output: Any) -> int:
     |

invalid-syntax: Expected a simple statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1433:9
     |
1432 |     def infer_output_count(self, stage_type: str, output: Any) -> int:
1433 |         if output is None:
     |         ^^
1434 |             return 0
1435 |         if stage_type in {"ingest", "chunk"} and isinstance(output, Sequence):
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1435:78
     |
1433 |         if output is None:
1434 |             return 0
1435 |         if stage_type in {"ingest", "chunk"} and isinstance(output, Sequence):
     |                                                                              ^
1436 |             return len(output)
1437 |         if stage_type in {"parse", "ir-validation"}:
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1437:52
     |
1435 |         if stage_type in {"ingest", "chunk"} and isinstance(output, Sequence):
1436 |             return len(output)
1437 |         if stage_type in {"parse", "ir-validation"}:
     |                                                    ^
1438 |             return 1
1439 |         if stage_type == "embed" and isinstance(output, EmbeddingBatch):
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1439:72
     |
1437 |         if stage_type in {"parse", "ir-validation"}:
1438 |             return 1
1439 |         if stage_type == "embed" and isinstance(output, EmbeddingBatch):
     |                                                                        ^
1440 |             return len(output.vectors)
1441 |         if stage_type == "index" and isinstance(output, IndexReceipt):
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1441:70
     |
1439 |         if stage_type == "embed" and isinstance(output, EmbeddingBatch):
1440 |             return len(output.vectors)
1441 |         if stage_type == "index" and isinstance(output, IndexReceipt):
     |                                                                      ^
1442 |             return output.chunks_indexed
1443 |         if stage_type == "extract" and isinstance(output, tuple) and len(output) == 2:
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1443:86
     |
1441 |         if stage_type == "index" and isinstance(output, IndexReceipt):
1442 |             return output.chunks_indexed
1443 |         if stage_type == "extract" and isinstance(output, tuple) and len(output) == 2:
     |                                                                                      ^
1444 |             entities, claims = output
1445 |             entity_count = len(entities) if isinstance(entities, Sequence) else 0
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1445:13
     |
1443 |         if stage_type == "extract" and isinstance(output, tuple) and len(output) == 2:
1444 |             entities, claims = output
1445 |             entity_count = len(entities) if isinstance(entities, Sequence) else 0
     |             ^^^^^^^^^^^^
1446 |             claim_count = len(claims) if isinstance(claims, Sequence) else 0
1447 |             return entity_count + claim_count
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1446:13
     |
1444 |             entities, claims = output
1445 |             entity_count = len(entities) if isinstance(entities, Sequence) else 0
1446 |             claim_count = len(claims) if isinstance(claims, Sequence) else 0
     |             ^^^^^^^^^^^
1447 |             return entity_count + claim_count
1448 |         if stage_type == "knowledge-graph" and isinstance(output, GraphWriteReceipt):
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1447:13
     |
1445 |             entity_count = len(entities) if isinstance(entities, Sequence) else 0
1446 |             claim_count = len(claims) if isinstance(claims, Sequence) else 0
1447 |             return entity_count + claim_count
     |             ^^^^^^
1448 |         if stage_type == "knowledge-graph" and isinstance(output, GraphWriteReceipt):
1449 |             return output.nodes_written
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1448:85
     |
1446 |             claim_count = len(claims) if isinstance(claims, Sequence) else 0
1447 |             return entity_count + claim_count
1448 |         if stage_type == "knowledge-graph" and isinstance(output, GraphWriteReceipt):
     |                                                                                     ^
1449 |             return output.nodes_written
1450 |         if stage_type == "download" and isinstance(output, Sequence):
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1450:69
     |
1448 |         if stage_type == "knowledge-graph" and isinstance(output, GraphWriteReceipt):
1449 |             return output.nodes_written
1450 |         if stage_type == "download" and isinstance(output, Sequence):
     |                                                                     ^
1451 |             return len(output)
1452 |         if stage_type == "pdf-download" and isinstance(output, Sequence):
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1452:73
     |
1450 |         if stage_type == "download" and isinstance(output, Sequence):
1451 |             return len(output)
1452 |         if stage_type == "pdf-download" and isinstance(output, Sequence):
     |                                                                         ^
1453 |             return len(tuple(output))
1454 |         if stage_type == "download" and isinstance(output, Sequence):
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1454:69
     |
1452 |         if stage_type == "pdf-download" and isinstance(output, Sequence):
1453 |             return len(tuple(output))
1454 |         if stage_type == "download" and isinstance(output, Sequence):
     |                                                                     ^
1455 |             return len(output)
1456 |         if stage_type == "gate" and isinstance(output, GateDecision):
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1456:69
     |
1454 |         if stage_type == "download" and isinstance(output, Sequence):
1455 |             return len(output)
1456 |         if stage_type == "gate" and isinstance(output, GateDecision):
     |                                                                     ^
1457 |             return int(output.ready)
1458 |         if stage_type == "gate" and isinstance(output, bool):
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1458:61
     |
1456 |         if stage_type == "gate" and isinstance(output, GateDecision):
1457 |             return int(output.ready)
1458 |         if stage_type == "gate" and isinstance(output, bool):
     |                                                             ^
1459 |             return 1
1460 |         return 1
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1460:9
     |
1458 |         if stage_type == "gate" and isinstance(output, bool):
1459 |             return 1
1460 |         return 1
     |         ^^^^^^
1461 |
1462 |     def record_stage_metrics(
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1462:5
     |
1460 |         return 1
1461 |
1462 |     def record_stage_metrics(
     |     ^^^
1463 |         self,
1464 |         stage_name: str,
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1476:22
     |
1474 |             StageResultSnapshot(stage=stage_name, stage_type="unknown"),
1475 |         )
1476 |         if stage_type:
     |                      ^
1477 |             snapshot.stage_type = stage_type
1478 |         snapshot.attempts = attempts
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1478:9
     |
1476 |         if stage_type:
1477 |             snapshot.stage_type = stage_type
1478 |         snapshot.attempts = attempts
     |         ^^^^^^^^
1479 |         snapshot.duration_ms = duration_ms
1480 |         snapshot.output_count = output_count
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1479:9
     |
1477 |             snapshot.stage_type = stage_type
1478 |         snapshot.attempts = attempts
1479 |         snapshot.duration_ms = duration_ms
     |         ^^^^^^^^
1480 |         snapshot.output_count = output_count
1481 |         snapshot.error = error
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1480:9
     |
1478 |         snapshot.attempts = attempts
1479 |         snapshot.duration_ms = duration_ms
1480 |         snapshot.output_count = output_count
     |         ^^^^^^^^
1481 |         snapshot.error = error
1482 |         record_stage_metrics(
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1481:9
     |
1479 |         snapshot.duration_ms = duration_ms
1480 |         snapshot.output_count = output_count
1481 |         snapshot.error = error
     |         ^^^^^^^^
1482 |         record_stage_metrics(
1483 |             pipeline=self.context.pipeline_name,
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1482:9
     |
1480 |         snapshot.output_count = output_count
1481 |         snapshot.error = error
1482 |         record_stage_metrics(
     |         ^^^^^^^^^^^^^^^^^^^^
1483 |             pipeline=self.context.pipeline_name,
1484 |             stage=stage_name,
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1490:9
     |
1488 |             error=error,
1489 |         )
1490 |         self._mark_dirty()
     |         ^^^^
1491 |         _state_logger.debug(
1492 |             "pipeline_state.stage_metrics_recorded",
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1491:9
     |
1489 |         )
1490 |         self._mark_dirty()
1491 |         _state_logger.debug(
     |         ^^^^^^^^^^^^^
1492 |             "pipeline_state.stage_metrics_recorded",
1493 |             stage=stage_name,
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1501:5
     |
1499 |         )
1500 |
1501 |     def mark_stage_failed(
     |     ^^^
1502 |         self,
1503 |         stage_name: str,
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1510:9
     |
1508 |         """Record failure metadata for a stage."""
1509 |
1510 |         self.record_stage_metrics(
     |         ^^^^
1511 |             stage_name,
1512 |             stage_type=stage_type,
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1519:5
     |
1517 |         )
1518 |
1519 |     def cleanup_stage(self, stage_type: str) -> None:
     |     ^^^
1520 |         """Drop large stage outputs to allow garbage collection."""
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1522:9
     |
1520 |         """Drop large stage outputs to allow garbage collection."""
1521 |
1522 |         key = self._stage_state_key(stage_type)
     |         ^^^
1523 |         if key == "payloads":
1524 |             self.payloads = ()
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1523:29
     |
1522 |         key = self._stage_state_key(stage_type)
1523 |         if key == "payloads":
     |                             ^
1524 |             self.payloads = ()
1525 |         elif key == "document":
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1525:9
     |
1523 |         if key == "payloads":
1524 |             self.payloads = ()
1525 |         elif key == "document":
     |         ^^^^
1526 |             self.document = None
1527 |         elif key == "chunks":
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1525:14
     |
1523 |         if key == "payloads":
1524 |             self.payloads = ()
1525 |         elif key == "document":
     |              ^^^^^^^^^^^^^^^^^
1526 |             self.document = None
1527 |         elif key == "chunks":
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1527:9
     |
1525 |         elif key == "document":
1526 |             self.document = None
1527 |         elif key == "chunks":
     |         ^^^^
1528 |             self.chunks = ()
1529 |         elif key == "embedding_batch":
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1527:14
     |
1525 |         elif key == "document":
1526 |             self.document = None
1527 |         elif key == "chunks":
     |              ^^^^^^^^^^^^^^^
1528 |             self.chunks = ()
1529 |         elif key == "embedding_batch":
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1529:9
     |
1527 |         elif key == "chunks":
1528 |             self.chunks = ()
1529 |         elif key == "embedding_batch":
     |         ^^^^
1530 |             self.embedding_batch = None
1531 |         elif key == "index_receipt":
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1529:14
     |
1527 |         elif key == "chunks":
1528 |             self.chunks = ()
1529 |         elif key == "embedding_batch":
     |              ^^^^^^^^^^^^^^^^^^^^^^^^
1530 |             self.embedding_batch = None
1531 |         elif key == "index_receipt":
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1531:9
     |
1529 |         elif key == "embedding_batch":
1530 |             self.embedding_batch = None
1531 |         elif key == "index_receipt":
     |         ^^^^
1532 |             self.index_receipt = None
1533 |         elif key == "extraction":
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1531:14
     |
1529 |         elif key == "embedding_batch":
1530 |             self.embedding_batch = None
1531 |         elif key == "index_receipt":
     |              ^^^^^^^^^^^^^^^^^^^^^^
1532 |             self.index_receipt = None
1533 |         elif key == "extraction":
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1533:9
     |
1531 |         elif key == "index_receipt":
1532 |             self.index_receipt = None
1533 |         elif key == "extraction":
     |         ^^^^
1534 |             self.entities = ()
1535 |             self.claims = ()
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1533:14
     |
1531 |         elif key == "index_receipt":
1532 |             self.index_receipt = None
1533 |         elif key == "extraction":
     |              ^^^^^^^^^^^^^^^^^^^
1534 |             self.entities = ()
1535 |             self.claims = ()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1535:13
     |
1533 |         elif key == "extraction":
1534 |             self.entities = ()
1535 |             self.claims = ()
     |             ^^^^
1536 |         elif key == "graph_receipt":
1537 |             self.graph_receipt = None
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1536:9
     |
1534 |             self.entities = ()
1535 |             self.claims = ()
1536 |         elif key == "graph_receipt":
     |         ^^^^
1537 |             self.graph_receipt = None
1538 |         else:
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1536:14
     |
1534 |             self.entities = ()
1535 |             self.claims = ()
1536 |         elif key == "graph_receipt":
     |              ^^^^^^^^^^^^^^^^^^^^^^
1537 |             self.graph_receipt = None
1538 |         else:
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1538:9
     |
1536 |         elif key == "graph_receipt":
1537 |             self.graph_receipt = None
1538 |         else:
     |         ^^^^
1539 |             self.metadata.pop(key, None)
1540 |         self._mark_dirty()
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1538:13
     |
1536 |         elif key == "graph_receipt":
1537 |             self.graph_receipt = None
1538 |         else:
     |             ^
1539 |             self.metadata.pop(key, None)
1540 |         self._mark_dirty()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1540:9
     |
1538 |         else:
1539 |             self.metadata.pop(key, None)
1540 |         self._mark_dirty()
     |         ^^^^
1541 |
1542 |     def dependencies_satisfied(self, dependencies: Sequence[str]) -> bool:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1542:5
     |
1540 |         self._mark_dirty()
1541 |
1542 |     def dependencies_satisfied(self, dependencies: Sequence[str]) -> bool:
     |     ^^^
1543 |         """Return True when all dependency stages have completed successfully."""
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1545:9
     |
1543 |         """Return True when all dependency stages have completed successfully."""
1544 |
1545 |         for dependency in dependencies:
     |         ^^^
1546 |             snapshot = self.stage_results.get(dependency)
1547 |             if snapshot is None or snapshot.error:
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1547:50
     |
1545 |         for dependency in dependencies:
1546 |             snapshot = self.stage_results.get(dependency)
1547 |             if snapshot is None or snapshot.error:
     |                                                  ^
1548 |                 return False
1549 |         return True
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1549:9
     |
1547 |             if snapshot is None or snapshot.error:
1548 |                 return False
1549 |         return True
     |         ^^^^^^
1550 |
1551 |     def ensure_dependencies(self, stage_name: str, dependencies: Sequence[str]) -> None:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1551:5
     |
1549 |         return True
1550 |
1551 |     def ensure_dependencies(self, stage_name: str, dependencies: Sequence[str]) -> None:
     |     ^^^
1552 |         """Raise if any dependency is missing or failed."""
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1554:9
     |
1552 |         """Raise if any dependency is missing or failed."""
1553 |
1554 |         unmet: list[str] = []
     |         ^^^^^
1555 |         for dependency in dependencies:
1556 |             snapshot = self.stage_results.get(dependency)
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1555:9
     |
1554 |         unmet: list[str] = []
1555 |         for dependency in dependencies:
     |         ^^^
1556 |             snapshot = self.stage_results.get(dependency)
1557 |             if snapshot is None:
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1557:32
     |
1555 |         for dependency in dependencies:
1556 |             snapshot = self.stage_results.get(dependency)
1557 |             if snapshot is None:
     |                                ^
1558 |                 unmet.append(dependency)
1559 |             elif snapshot.error:
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1559:13
     |
1557 |             if snapshot is None:
1558 |                 unmet.append(dependency)
1559 |             elif snapshot.error:
     |             ^^^^
1560 |                 unmet.append(f"{dependency} (failed)")
1561 |         if unmet:
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1561:17
     |
1559 |             elif snapshot.error:
1560 |                 unmet.append(f"{dependency} (failed)")
1561 |         if unmet:
     |                 ^
1562 |             dependency_list = ", ".join(sorted(unmet))
1563 |             raise ValueError(
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1563:13
     |
1561 |         if unmet:
1562 |             dependency_list = ", ".join(sorted(unmet))
1563 |             raise ValueError(
     |             ^^^^^
1564 |                 f"Stage '{stage_name}' cannot execute until dependencies are satisfied: {dependency_list}"
1565 |             )
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1567:5
     |
1565 |             )
1566 |
1567 |     def mark_pdf_downloaded(self, *, metadata: Mapping[str, Any] | None = None) -> None:
     |     ^^^
1568 |         """Flag the PDF gate as downloaded and merge metadata."""
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1570:9
     |
1568 |         """Flag the PDF gate as downloaded and merge metadata."""
1569 |
1570 |         self.pdf_gate.downloaded = True
     |         ^^^^
1571 |         self.pdf_gate.merge_metadata(metadata)
1572 |         self.metadata.setdefault("pdf", {})["downloaded"] = True
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1571:9
     |
1570 |         self.pdf_gate.downloaded = True
1571 |         self.pdf_gate.merge_metadata(metadata)
     |         ^^^^
1572 |         self.metadata.setdefault("pdf", {})["downloaded"] = True
1573 |         self._mark_dirty()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1572:9
     |
1570 |         self.pdf_gate.downloaded = True
1571 |         self.pdf_gate.merge_metadata(metadata)
1572 |         self.metadata.setdefault("pdf", {})["downloaded"] = True
     |         ^^^^
1573 |         self._mark_dirty()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1573:9
     |
1571 |         self.pdf_gate.merge_metadata(metadata)
1572 |         self.metadata.setdefault("pdf", {})["downloaded"] = True
1573 |         self._mark_dirty()
     |         ^^^^
1574 |
1575 |     def mark_pdf_ir_ready(self, *, metadata: Mapping[str, Any] | None = None) -> None:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1575:5
     |
1573 |         self._mark_dirty()
1574 |
1575 |     def mark_pdf_ir_ready(self, *, metadata: Mapping[str, Any] | None = None) -> None:
     |     ^^^
1576 |         """Flag the PDF gate as ready for IR stage and merge metadata."""
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1578:9
     |
1576 |         """Flag the PDF gate as ready for IR stage and merge metadata."""
1577 |
1578 |         self.pdf_gate.ir_ready = True
     |         ^^^^
1579 |         self.pdf_gate.merge_metadata(metadata)
1580 |         self.metadata.setdefault("pdf", {})["ir_ready"] = True
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1579:9
     |
1578 |         self.pdf_gate.ir_ready = True
1579 |         self.pdf_gate.merge_metadata(metadata)
     |         ^^^^
1580 |         self.metadata.setdefault("pdf", {})["ir_ready"] = True
1581 |         self._mark_dirty()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1580:9
     |
1578 |         self.pdf_gate.ir_ready = True
1579 |         self.pdf_gate.merge_metadata(metadata)
1580 |         self.metadata.setdefault("pdf", {})["ir_ready"] = True
     |         ^^^^
1581 |         self._mark_dirty()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1581:9
     |
1579 |         self.pdf_gate.merge_metadata(metadata)
1580 |         self.metadata.setdefault("pdf", {})["ir_ready"] = True
1581 |         self._mark_dirty()
     |         ^^^^
1582 |
1583 |     def reset_pdf_gate(self) -> None:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1583:5
     |
1581 |         self._mark_dirty()
1582 |
1583 |     def reset_pdf_gate(self) -> None:
     |     ^^^
1584 |         """Reset the PDF gate state."""
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1586:9
     |
1584 |         """Reset the PDF gate state."""
1585 |
1586 |         self.pdf_gate = PdfGateState()
     |         ^^^^
1587 |         if "pdf" in self.metadata:
1588 |             self.metadata.pop("pdf", None)
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1587:34
     |
1586 |         self.pdf_gate = PdfGateState()
1587 |         if "pdf" in self.metadata:
     |                                  ^
1588 |             self.metadata.pop("pdf", None)
1589 |         self._mark_dirty()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1589:9
     |
1587 |         if "pdf" in self.metadata:
1588 |             self.metadata.pop("pdf", None)
1589 |         self._mark_dirty()
     |         ^^^^
1590 |
1591 |     # ------------------------------------------------------------------
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1594:5
     |
1592 |     # Snapshot & rollback helpers
1593 |     # ------------------------------------------------------------------
1594 |     def snapshot(self, *, include_stage_results: bool = True) -> PipelineStateSnapshot:
     |     ^^^
1595 |         """Capture an immutable snapshot for later rollback or diagnostics."""
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1597:9
     |
1595 |         """Capture an immutable snapshot for later rollback or diagnostics."""
1596 |
1597 |         stage_payload: dict[str, StageResultSnapshot] = {}
     |         ^^^^^^^^^^^^^
1598 |         if include_stage_results:
1599 |             stage_payload = {
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1598:33
     |
1597 |         stage_payload: dict[str, StageResultSnapshot] = {}
1598 |         if include_stage_results:
     |                                 ^
1599 |             stage_payload = {
1600 |                 name: copy.deepcopy(result)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1603:9
     |
1601 |                 for name, result in self.stage_results.items()
1602 |             }
1603 |         return PipelineStateSnapshot(
     |         ^^^^^^
1604 |             payloads=tuple(copy.deepcopy(self.payloads)),
1605 |             document=copy.deepcopy(self.document),
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1629:5
     |
1627 |         )
1628 |
1629 |     def restore(
     |     ^^^
1630 |         self,
1631 |         snapshot: PipelineStateSnapshot,
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1637:9
     |
1635 |         """Restore the state from a previously captured snapshot."""
1636 |
1637 |         self.payloads = tuple(copy.deepcopy(snapshot.payloads))
     |         ^^^^
1638 |         self.document = copy.deepcopy(snapshot.document)
1639 |         self.chunks = tuple(copy.deepcopy(snapshot.chunks))
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1638:9
     |
1637 |         self.payloads = tuple(copy.deepcopy(snapshot.payloads))
1638 |         self.document = copy.deepcopy(snapshot.document)
     |         ^^^^
1639 |         self.chunks = tuple(copy.deepcopy(snapshot.chunks))
1640 |         self.embedding_batch = copy.deepcopy(snapshot.embedding_batch)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1639:9
     |
1637 |         self.payloads = tuple(copy.deepcopy(snapshot.payloads))
1638 |         self.document = copy.deepcopy(snapshot.document)
1639 |         self.chunks = tuple(copy.deepcopy(snapshot.chunks))
     |         ^^^^
1640 |         self.embedding_batch = copy.deepcopy(snapshot.embedding_batch)
1641 |         self.entities = tuple(copy.deepcopy(snapshot.entities))
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1640:9
     |
1638 |         self.document = copy.deepcopy(snapshot.document)
1639 |         self.chunks = tuple(copy.deepcopy(snapshot.chunks))
1640 |         self.embedding_batch = copy.deepcopy(snapshot.embedding_batch)
     |         ^^^^
1641 |         self.entities = tuple(copy.deepcopy(snapshot.entities))
1642 |         self.claims = tuple(copy.deepcopy(snapshot.claims))
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1641:9
     |
1639 |         self.chunks = tuple(copy.deepcopy(snapshot.chunks))
1640 |         self.embedding_batch = copy.deepcopy(snapshot.embedding_batch)
1641 |         self.entities = tuple(copy.deepcopy(snapshot.entities))
     |         ^^^^
1642 |         self.claims = tuple(copy.deepcopy(snapshot.claims))
1643 |         self.index_receipt = copy.deepcopy(snapshot.index_receipt)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1642:9
     |
1640 |         self.embedding_batch = copy.deepcopy(snapshot.embedding_batch)
1641 |         self.entities = tuple(copy.deepcopy(snapshot.entities))
1642 |         self.claims = tuple(copy.deepcopy(snapshot.claims))
     |         ^^^^
1643 |         self.index_receipt = copy.deepcopy(snapshot.index_receipt)
1644 |         self.graph_receipt = copy.deepcopy(snapshot.graph_receipt)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1643:9
     |
1641 |         self.entities = tuple(copy.deepcopy(snapshot.entities))
1642 |         self.claims = tuple(copy.deepcopy(snapshot.claims))
1643 |         self.index_receipt = copy.deepcopy(snapshot.index_receipt)
     |         ^^^^
1644 |         self.graph_receipt = copy.deepcopy(snapshot.graph_receipt)
1645 |         self.downloads = tuple(copy.deepcopy(snapshot.downloads))
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1644:9
     |
1642 |         self.claims = tuple(copy.deepcopy(snapshot.claims))
1643 |         self.index_receipt = copy.deepcopy(snapshot.index_receipt)
1644 |         self.graph_receipt = copy.deepcopy(snapshot.graph_receipt)
     |         ^^^^
1645 |         self.downloads = tuple(copy.deepcopy(snapshot.downloads))
1646 |         self.gate_decisions = {
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1645:9
     |
1643 |         self.index_receipt = copy.deepcopy(snapshot.index_receipt)
1644 |         self.graph_receipt = copy.deepcopy(snapshot.graph_receipt)
1645 |         self.downloads = tuple(copy.deepcopy(snapshot.downloads))
     |         ^^^^
1646 |         self.gate_decisions = {
1647 |             name: copy.deepcopy(decision) for name, decision in snapshot.gate_decisions.items()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1646:9
     |
1644 |         self.graph_receipt = copy.deepcopy(snapshot.graph_receipt)
1645 |         self.downloads = tuple(copy.deepcopy(snapshot.downloads))
1646 |         self.gate_decisions = {
     |         ^^^^
1647 |             name: copy.deepcopy(decision) for name, decision in snapshot.gate_decisions.items()
1648 |         }
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1649:9
     |
1647 |             name: copy.deepcopy(decision) for name, decision in snapshot.gate_decisions.items()
1648 |         }
1649 |         self.pdf_assets = tuple(copy.deepcopy(snapshot.pdf_assets))
     |         ^^^^
1650 |         self.gate_status = dict(snapshot.gate_status)
1651 |         self.metadata = copy.deepcopy(snapshot.metadata)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1650:9
     |
1648 |         }
1649 |         self.pdf_assets = tuple(copy.deepcopy(snapshot.pdf_assets))
1650 |         self.gate_status = dict(snapshot.gate_status)
     |         ^^^^
1651 |         self.metadata = copy.deepcopy(snapshot.metadata)
1652 |         if restore_stage_results:
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1651:9
     |
1649 |         self.pdf_assets = tuple(copy.deepcopy(snapshot.pdf_assets))
1650 |         self.gate_status = dict(snapshot.gate_status)
1651 |         self.metadata = copy.deepcopy(snapshot.metadata)
     |         ^^^^
1652 |         if restore_stage_results:
1653 |             self.stage_results = {
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1652:33
     |
1650 |         self.gate_status = dict(snapshot.gate_status)
1651 |         self.metadata = copy.deepcopy(snapshot.metadata)
1652 |         if restore_stage_results:
     |                                 ^
1653 |             self.stage_results = {
1654 |                 name: copy.deepcopy(result) for name, result in snapshot.stage_results.items()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1656:9
     |
1654 |                 name: copy.deepcopy(result) for name, result in snapshot.stage_results.items()
1655 |             }
1656 |         self.job_id = snapshot.job_id
     |         ^^^^
1657 |         self.pdf_tracker = copy.deepcopy(snapshot.pdf_tracker)
1658 |         self.pdf_gate = PdfGateState(
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1657:9
     |
1655 |             }
1656 |         self.job_id = snapshot.job_id
1657 |         self.pdf_tracker = copy.deepcopy(snapshot.pdf_tracker)
     |         ^^^^
1658 |         self.pdf_gate = PdfGateState(
1659 |             downloaded=snapshot.pdf_gate.downloaded,
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1658:9
     |
1656 |         self.job_id = snapshot.job_id
1657 |         self.pdf_tracker = copy.deepcopy(snapshot.pdf_tracker)
1658 |         self.pdf_gate = PdfGateState(
     |         ^^^^
1659 |             downloaded=snapshot.pdf_gate.downloaded,
1660 |             ir_ready=snapshot.pdf_gate.ir_ready,
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1663:9
     |
1661 |             metadata=copy.deepcopy(snapshot.pdf_gate.metadata),
1662 |         )
1663 |         self._mark_dirty()
     |         ^^^^
1664 |
1665 |     def rollback(self, snapshot: PipelineStateSnapshot) -> None:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1665:5
     |
1663 |         self._mark_dirty()
1664 |
1665 |     def rollback(self, snapshot: PipelineStateSnapshot) -> None:
     |     ^^^
1666 |         """Alias for :meth:`restore` to emphasise rollback semantics."""
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1668:9
     |
1666 |         """Alias for :meth:`restore` to emphasise rollback semantics."""
1667 |
1668 |         self.restore(snapshot)
     |         ^^^^
1669 |
1670 |     # ------------------------------------------------------------------
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1673:5
     |
1671 |     # Serialisation helpers
1672 |     # ------------------------------------------------------------------
1673 |     def serialise(
     |     ^^^
1674 |         self,
1675 |         *,
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1679:9
     |
1677 |           use_cache: bool = True,
1678 |       ) -> dict[str, Any]:
1679 | /         """Return a metadata snapshot suitable for logging or Kafka payloads."""
1680 | |
1681 | |         if use_cache and not self._dirty and self._serialised_cache is not None:
     | |_______________________________________________________________________________^
1682 |               _STATE_SERIALISATION_LATENCY.labels(format="dict").observe(0.0)
1683 |               return copy.deepcopy(self._serialised_cache)
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1681:80
     |
1679 |         """Return a metadata snapshot suitable for logging or Kafka payloads."""
1680 |
1681 |         if use_cache and not self._dirty and self._serialised_cache is not None:
     |                                                                                ^
1682 |             _STATE_SERIALISATION_LATENCY.labels(format="dict").observe(0.0)
1683 |             return copy.deepcopy(self._serialised_cache)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1683:13
     |
1681 |         if use_cache and not self._dirty and self._serialised_cache is not None:
1682 |             _STATE_SERIALISATION_LATENCY.labels(format="dict").observe(0.0)
1683 |             return copy.deepcopy(self._serialised_cache)
     |             ^^^^^^
1684 |         if use_cache and not self._dirty and self._cache.payload is not None:
1685 |             return copy.deepcopy(self._cache.payload)
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1684:77
     |
1682 |             _STATE_SERIALISATION_LATENCY.labels(format="dict").observe(0.0)
1683 |             return copy.deepcopy(self._serialised_cache)
1684 |         if use_cache and not self._dirty and self._cache.payload is not None:
     |                                                                             ^
1685 |             return copy.deepcopy(self._cache.payload)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1687:9
     |
1685 |             return copy.deepcopy(self._cache.payload)
1686 |
1687 |         start = time.perf_counter()
     |         ^^^^^
1688 |         snapshot: dict[str, Any] = {
1689 |             "version": self.schema_version,
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1688:9
     |
1687 |         start = time.perf_counter()
1688 |         snapshot: dict[str, Any] = {
     |         ^^^^^^^^
1689 |             "version": self.schema_version,
1690 |             "job_id": self.job_id,
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1710:27
     |
1708 |             "gate_status": dict(self.gate_status),
1709 |         }
1710 |         if self.pdf_assets:
     |                           ^
1711 |             snapshot["pdf_assets"] = [
1712 |                 {
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1719:13
     |
1717 |                 for asset in self.pdf_assets
1718 |             ]
1719 |             snapshot["pdf_asset_count"] = len(self.pdf_assets)
     |             ^^^^^^^^
1720 |         if include_stage_results:
1721 |             snapshot["stage_results"] = {
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1720:33
     |
1718 |             ]
1719 |             snapshot["pdf_asset_count"] = len(self.pdf_assets)
1720 |         if include_stage_results:
     |                                 ^
1721 |             snapshot["stage_results"] = {
1722 |                 name: result.as_dict() for name, result in self.stage_results.items()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1724:9
     |
1722 |                 name: result.as_dict() for name, result in self.stage_results.items()
1723 |             }
1724 |         elapsed = time.perf_counter() - start
     |         ^^^^^^^
1725 |         _STATE_SERIALISATION_LATENCY.labels(format="dict").observe(elapsed)
1726 |         if self.pdf_gate:
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1725:9
     |
1723 |             }
1724 |         elapsed = time.perf_counter() - start
1725 |         _STATE_SERIALISATION_LATENCY.labels(format="dict").observe(elapsed)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1726 |         if self.pdf_gate:
1727 |             snapshot["pdf_gate"] = self.pdf_gate.as_dict()
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1725:9
     |
1723 |               }
1724 |           elapsed = time.perf_counter() - start
1725 | /         _STATE_SERIALISATION_LATENCY.labels(format="dict").observe(elapsed)
1726 | |         if self.pdf_gate:
     | |________________________^
1727 |               snapshot["pdf_gate"] = self.pdf_gate.as_dict()
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1726:25
     |
1724 |         elapsed = time.perf_counter() - start
1725 |         _STATE_SERIALISATION_LATENCY.labels(format="dict").observe(elapsed)
1726 |         if self.pdf_gate:
     |                         ^
1727 |             snapshot["pdf_gate"] = self.pdf_gate.as_dict()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1729:9
     |
1727 |             snapshot["pdf_gate"] = self.pdf_gate.as_dict()
1728 |
1729 |         model = serialise_payload(snapshot)
     |         ^^^^^
1730 |         payload = model.model_dump(mode="json")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1730:9
     |
1729 |         model = serialise_payload(snapshot)
1730 |         payload = model.model_dump(mode="json")
     |         ^^^^^^^
1731 |
1732 |         if use_cache:
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1732:21
     |
1730 |         payload = model.model_dump(mode="json")
1731 |
1732 |         if use_cache:
     |                     ^
1733 |             self._cache.payload = copy.deepcopy(snapshot)
1734 |             self._serialised_cache = copy.deepcopy(payload)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1734:13
     |
1732 |         if use_cache:
1733 |             self._cache.payload = copy.deepcopy(snapshot)
1734 |             self._serialised_cache = copy.deepcopy(payload)
     |             ^^^^
1735 |             self._dirty = False
1736 |         serialised = copy.deepcopy(snapshot)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1735:13
     |
1733 |             self._cache.payload = copy.deepcopy(snapshot)
1734 |             self._serialised_cache = copy.deepcopy(payload)
1735 |             self._dirty = False
     |             ^^^^
1736 |         serialised = copy.deepcopy(snapshot)
1737 |         PIPELINE_STATE_SERIALISATIONS.inc()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1736:9
     |
1734 |             self._serialised_cache = copy.deepcopy(payload)
1735 |             self._dirty = False
1736 |         serialised = copy.deepcopy(snapshot)
     |         ^^^^^^^^^^
1737 |         PIPELINE_STATE_SERIALISATIONS.inc()
1738 |         logger.debug(
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1737:9
     |
1735 |             self._dirty = False
1736 |         serialised = copy.deepcopy(snapshot)
1737 |         PIPELINE_STATE_SERIALISATIONS.inc()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1738 |         logger.debug(
1739 |             "pipeline_state.serialised",
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1738:9
     |
1736 |         serialised = copy.deepcopy(snapshot)
1737 |         PIPELINE_STATE_SERIALISATIONS.inc()
1738 |         logger.debug(
     |         ^^^^^^
1739 |             "pipeline_state.serialised",
1740 |             tenant_id=self._tenant_id,
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1744:9
     |
1742 |             stage_count=len(self.stage_results),
1743 |         )
1744 |         return serialised
     |         ^^^^^^
1745 |         else:
1746 |             self._serialised_cache = None
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1745:9
     |
1743 |         )
1744 |         return serialised
1745 |         else:
     |         ^^^^
1746 |             self._serialised_cache = None
1747 |             self._cache.payload = copy.deepcopy(snapshot)
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1745:13
     |
1743 |         )
1744 |         return serialised
1745 |         else:
     |             ^
1746 |             self._serialised_cache = None
1747 |             self._cache.payload = copy.deepcopy(snapshot)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1747:13
     |
1745 |         else:
1746 |             self._serialised_cache = None
1747 |             self._cache.payload = copy.deepcopy(snapshot)
     |             ^^^^
1748 |             self._dirty = False
1749 |         return copy.deepcopy(payload)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1748:13
     |
1746 |             self._serialised_cache = None
1747 |             self._cache.payload = copy.deepcopy(snapshot)
1748 |             self._dirty = False
     |             ^^^^
1749 |         return copy.deepcopy(payload)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1749:9
     |
1747 |             self._cache.payload = copy.deepcopy(snapshot)
1748 |             self._dirty = False
1749 |         return copy.deepcopy(payload)
     |         ^^^^^^
1750 |
1751 |     def to_legacy_dict(self) -> dict[str, Any]:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1751:5
     |
1749 |         return copy.deepcopy(payload)
1750 |
1751 |     def to_legacy_dict(self) -> dict[str, Any]:
     |     ^^^
1752 |         """Return a dictionary compatible with legacy dict-based state consumers."""
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1754:9
     |
1752 |         """Return a dictionary compatible with legacy dict-based state consumers."""
1753 |
1754 |         payload: dict[str, Any] = {
     |         ^^^^^^^
1755 |             "version": self.schema_version,
1756 |             "job_id": self.job_id,
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1766:37
     |
1764 |             },
1765 |         }
1766 |         if self.document is not None:
     |                                     ^
1767 |             payload["document"] = self.document.model_dump(mode="json")
1768 |         if self.chunks:
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1768:23
     |
1766 |         if self.document is not None:
1767 |             payload["document"] = self.document.model_dump(mode="json")
1768 |         if self.chunks:
     |                       ^
1769 |             payload["chunks"] = [chunk.model_dump(mode="json") for chunk in self.chunks]
1770 |         if self.embedding_batch is not None:
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1770:44
     |
1768 |         if self.chunks:
1769 |             payload["chunks"] = [chunk.model_dump(mode="json") for chunk in self.chunks]
1770 |         if self.embedding_batch is not None:
     |                                            ^
1771 |             payload["embedding_batch"] = {
1772 |                 "vectors": [
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1783:25
     |
1781 |                 "tenant_id": self.embedding_batch.tenant_id,
1782 |             }
1783 |         if self.entities:
     |                         ^
1784 |             payload["entities"] = [entity.model_dump(mode="json") for entity in self.entities]
1785 |         if self.claims:
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1785:23
     |
1783 |         if self.entities:
1784 |             payload["entities"] = [entity.model_dump(mode="json") for entity in self.entities]
1785 |         if self.claims:
     |                       ^
1786 |             payload["claims"] = [claim.model_dump(mode="json") for claim in self.claims]
1787 |         if self.index_receipt is not None:
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1787:42
     |
1785 |         if self.claims:
1786 |             payload["claims"] = [claim.model_dump(mode="json") for claim in self.claims]
1787 |         if self.index_receipt is not None:
     |                                          ^
1788 |             payload["index_receipt"] = asdict(self.index_receipt)
1789 |         if self.graph_receipt is not None:
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1789:42
     |
1787 |         if self.index_receipt is not None:
1788 |             payload["index_receipt"] = asdict(self.index_receipt)
1789 |         if self.graph_receipt is not None:
     |                                          ^
1790 |             payload["graph_receipt"] = asdict(self.graph_receipt)
1791 |         payload["pdf"] = self.pdf_tracker.as_dict()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1791:9
     |
1789 |         if self.graph_receipt is not None:
1790 |             payload["graph_receipt"] = asdict(self.graph_receipt)
1791 |         payload["pdf"] = self.pdf_tracker.as_dict()
     |         ^^^^^^^
1792 |         payload["pdf_gate"] = self.pdf_gate.as_dict()
1793 |         if self.pdf_assets:
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1792:9
     |
1790 |             payload["graph_receipt"] = asdict(self.graph_receipt)
1791 |         payload["pdf"] = self.pdf_tracker.as_dict()
1792 |         payload["pdf_gate"] = self.pdf_gate.as_dict()
     |         ^^^^^^^
1793 |         if self.pdf_assets:
1794 |             payload["pdf_assets"] = [attr_asdict(asset) for asset in self.pdf_assets]
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1793:27
     |
1791 |         payload["pdf"] = self.pdf_tracker.as_dict()
1792 |         payload["pdf_gate"] = self.pdf_gate.as_dict()
1793 |         if self.pdf_assets:
     |                           ^
1794 |             payload["pdf_assets"] = [attr_asdict(asset) for asset in self.pdf_assets]
1795 |         if self.gate_status:
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1795:28
     |
1793 |         if self.pdf_assets:
1794 |             payload["pdf_assets"] = [attr_asdict(asset) for asset in self.pdf_assets]
1795 |         if self.gate_status:
     |                            ^
1796 |             payload["gate_status"] = dict(self.gate_status)
1797 |         return payload
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1797:9
     |
1795 |         if self.gate_status:
1796 |             payload["gate_status"] = dict(self.gate_status)
1797 |         return payload
     |         ^^^^^^
1798 |
1799 |     def _cache_key(self) -> str:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1799:5
     |
1797 |         return payload
1798 |
1799 |     def _cache_key(self) -> str:
     |     ^^^
1800 |         return (
1801 |             self.job_id
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1807:9
     |
1805 |         )
1806 |
1807 |         start = time.perf_counter()
     |         ^^^^^
1808 |         payload = self.serialise()
1809 |         encoded = orjson.dumps(payload).decode("utf-8")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1808:9
     |
1807 |         start = time.perf_counter()
1808 |         payload = self.serialise()
     |         ^^^^^^^
1809 |         encoded = orjson.dumps(payload).decode("utf-8")
1810 |         elapsed = time.perf_counter() - start
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1809:9
     |
1807 |         start = time.perf_counter()
1808 |         payload = self.serialise()
1809 |         encoded = orjson.dumps(payload).decode("utf-8")
     |         ^^^^^^^
1810 |         elapsed = time.perf_counter() - start
1811 |         _STATE_SERIALISATION_LATENCY.labels(format="json").observe(elapsed)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1810:9
     |
1808 |         payload = self.serialise()
1809 |         encoded = orjson.dumps(payload).decode("utf-8")
1810 |         elapsed = time.perf_counter() - start
     |         ^^^^^^^
1811 |         _STATE_SERIALISATION_LATENCY.labels(format="json").observe(elapsed)
1812 |         return encoded
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1811:9
     |
1809 |         encoded = orjson.dumps(payload).decode("utf-8")
1810 |         elapsed = time.perf_counter() - start
1811 |         _STATE_SERIALISATION_LATENCY.labels(format="json").observe(elapsed)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1812 |         return encoded
1813 |         return orjson.dumps(self.serialise()).decode("utf-8")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1812:9
     |
1810 |         elapsed = time.perf_counter() - start
1811 |         _STATE_SERIALISATION_LATENCY.labels(format="json").observe(elapsed)
1812 |         return encoded
     |         ^^^^^^
1813 |         return orjson.dumps(self.serialise()).decode("utf-8")
1814 |     def to_model(self) -> PipelineStateModel:
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1813:9
     |
1811 |         _STATE_SERIALISATION_LATENCY.labels(format="json").observe(elapsed)
1812 |         return encoded
1813 |         return orjson.dumps(self.serialise()).decode("utf-8")
     |         ^^^^^^
1814 |     def to_model(self) -> PipelineStateModel:
1815 |         """Return the Pydantic representation for the current state."""
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1814:5
     |
1812 |         return encoded
1813 |         return orjson.dumps(self.serialise()).decode("utf-8")
1814 |     def to_model(self) -> PipelineStateModel:
     |     ^^^
1815 |         """Return the Pydantic representation for the current state."""
1816 |         if not self._dirty and self._cache.json_bytes is not None:
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1815:9
     |
1813 |           return orjson.dumps(self.serialise()).decode("utf-8")
1814 |       def to_model(self) -> PipelineStateModel:
1815 | /         """Return the Pydantic representation for the current state."""
1816 | |         if not self._dirty and self._cache.json_bytes is not None:
     | |_________________________________________________________________^
1817 |               return self._cache.json_bytes.decode("utf-8")
1818 |           payload = self.serialise()
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1816:66
     |
1814 |     def to_model(self) -> PipelineStateModel:
1815 |         """Return the Pydantic representation for the current state."""
1816 |         if not self._dirty and self._cache.json_bytes is not None:
     |                                                                  ^
1817 |             return self._cache.json_bytes.decode("utf-8")
1818 |         payload = self.serialise()
     |

invalid-syntax: Expected an identifier, but found a keyword 'return' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1817:13
     |
1815 |         """Return the Pydantic representation for the current state."""
1816 |         if not self._dirty and self._cache.json_bytes is not None:
1817 |             return self._cache.json_bytes.decode("utf-8")
     |             ^^^^^^
1818 |         payload = self.serialise()
1819 |         start = time.perf_counter()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1817:20
     |
1815 |         """Return the Pydantic representation for the current state."""
1816 |         if not self._dirty and self._cache.json_bytes is not None:
1817 |             return self._cache.json_bytes.decode("utf-8")
     |                    ^^^^
1818 |         payload = self.serialise()
1819 |         start = time.perf_counter()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1818:9
     |
1816 |         if not self._dirty and self._cache.json_bytes is not None:
1817 |             return self._cache.json_bytes.decode("utf-8")
1818 |         payload = self.serialise()
     |         ^^^^^^^
1819 |         start = time.perf_counter()
1820 |         json_bytes = orjson.dumps(payload)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1819:9
     |
1817 |             return self._cache.json_bytes.decode("utf-8")
1818 |         payload = self.serialise()
1819 |         start = time.perf_counter()
     |         ^^^^^
1820 |         json_bytes = orjson.dumps(payload)
1821 |         duration = time.perf_counter() - start
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1820:9
     |
1818 |         payload = self.serialise()
1819 |         start = time.perf_counter()
1820 |         json_bytes = orjson.dumps(payload)
     |         ^^^^^^^^^^
1821 |         duration = time.perf_counter() - start
1822 |         _STATE_SERIALISE_COUNTER.labels(format="json").inc()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1821:9
     |
1819 |         start = time.perf_counter()
1820 |         json_bytes = orjson.dumps(payload)
1821 |         duration = time.perf_counter() - start
     |         ^^^^^^^^
1822 |         _STATE_SERIALISE_COUNTER.labels(format="json").inc()
1823 |         _STATE_SERIALISE_LATENCY.labels(format="json").observe(duration)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1822:9
     |
1820 |         json_bytes = orjson.dumps(payload)
1821 |         duration = time.perf_counter() - start
1822 |         _STATE_SERIALISE_COUNTER.labels(format="json").inc()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^
1823 |         _STATE_SERIALISE_LATENCY.labels(format="json").observe(duration)
1824 |         self._cache.json_bytes = json_bytes
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1823:9
     |
1821 |         duration = time.perf_counter() - start
1822 |         _STATE_SERIALISE_COUNTER.labels(format="json").inc()
1823 |         _STATE_SERIALISE_LATENCY.labels(format="json").observe(duration)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^
1824 |         self._cache.json_bytes = json_bytes
1825 |         return json_bytes.decode("utf-8")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1824:9
     |
1822 |         _STATE_SERIALISE_COUNTER.labels(format="json").inc()
1823 |         _STATE_SERIALISE_LATENCY.labels(format="json").observe(duration)
1824 |         self._cache.json_bytes = json_bytes
     |         ^^^^
1825 |         return json_bytes.decode("utf-8")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1825:9
     |
1823 |         _STATE_SERIALISE_LATENCY.labels(format="json").observe(duration)
1824 |         self._cache.json_bytes = json_bytes
1825 |         return json_bytes.decode("utf-8")
     |         ^^^^^^
1826 |
1827 |         payload = self.serialise()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1827:9
     |
1825 |         return json_bytes.decode("utf-8")
1826 |
1827 |         payload = self.serialise()
     |         ^^^^^^^
1828 |         return PipelineStateModel.model_validate(payload)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1828:9
     |
1827 |         payload = self.serialise()
1828 |         return PipelineStateModel.model_validate(payload)
     |         ^^^^^^
1829 |
1830 |     def serialise_json(self, *, use_cache: bool = True) -> str:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1830:5
     |
1828 |         return PipelineStateModel.model_validate(payload)
1829 |
1830 |     def serialise_json(self, *, use_cache: bool = True) -> str:
     |     ^^^
1831 |         """Return a JSON encoded snapshot of the state."""
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1833:9
     |
1831 |         """Return a JSON encoded snapshot of the state."""
1832 |
1833 |         payload = self.serialise(use_cache=use_cache)
     |         ^^^^^^^
1834 |         if use_cache and not self._dirty:
1835 |             cached = self._SERIALISATION_CACHE.get(self._cache_key())
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1834:41
     |
1833 |         payload = self.serialise(use_cache=use_cache)
1834 |         if use_cache and not self._dirty:
     |                                         ^
1835 |             cached = self._SERIALISATION_CACHE.get(self._cache_key())
1836 |             if cached is not None:
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1836:34
     |
1834 |         if use_cache and not self._dirty:
1835 |             cached = self._SERIALISATION_CACHE.get(self._cache_key())
1836 |             if cached is not None:
     |                                  ^
1837 |                 return cached.decode("utf-8")
1838 |             blob = dumps_orjson(payload)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1838:13
     |
1836 |             if cached is not None:
1837 |                 return cached.decode("utf-8")
1838 |             blob = dumps_orjson(payload)
     |             ^^^^
1839 |             self._SERIALISATION_CACHE.set(self._cache_key(), blob)
1840 |             return blob.decode("utf-8")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1839:13
     |
1837 |                 return cached.decode("utf-8")
1838 |             blob = dumps_orjson(payload)
1839 |             self._SERIALISATION_CACHE.set(self._cache_key(), blob)
     |             ^^^^
1840 |             return blob.decode("utf-8")
1841 |         return dumps_json(payload)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1840:13
     |
1838 |             blob = dumps_orjson(payload)
1839 |             self._SERIALISATION_CACHE.set(self._cache_key(), blob)
1840 |             return blob.decode("utf-8")
     |             ^^^^^^
1841 |         return dumps_json(payload)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1841:9
     |
1839 |             self._SERIALISATION_CACHE.set(self._cache_key(), blob)
1840 |             return blob.decode("utf-8")
1841 |         return dumps_json(payload)
     |         ^^^^^^
1842 |
1843 |     def serialise_compressed(self, *, use_cache: bool = True) -> bytes:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1843:5
     |
1841 |         return dumps_json(payload)
1842 |
1843 |     def serialise_compressed(self, *, use_cache: bool = True) -> bytes:
     |     ^^^
1844 |         """Compress the JSON snapshot for efficient transport."""
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1844:9
     |
1843 |       def serialise_compressed(self, *, use_cache: bool = True) -> bytes:
1844 | /         """Compress the JSON snapshot for efficient transport."""
1845 | |
1846 | |         if not self._dirty and self._cache.compressed is not None:
     | |_________________________________________________________________^
1847 |               return self._cache.compressed
1848 |           json_bytes = self._cache.json_bytes
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1846:66
     |
1844 |         """Compress the JSON snapshot for efficient transport."""
1845 |
1846 |         if not self._dirty and self._cache.compressed is not None:
     |                                                                  ^
1847 |             return self._cache.compressed
1848 |         json_bytes = self._cache.json_bytes
     |

invalid-syntax: Expected an identifier, but found a keyword 'return' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1847:13
     |
1846 |         if not self._dirty and self._cache.compressed is not None:
1847 |             return self._cache.compressed
     |             ^^^^^^
1848 |         json_bytes = self._cache.json_bytes
1849 |         if json_bytes is None or self._dirty:
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1847:20
     |
1846 |         if not self._dirty and self._cache.compressed is not None:
1847 |             return self._cache.compressed
     |                    ^^^^
1848 |         json_bytes = self._cache.json_bytes
1849 |         if json_bytes is None or self._dirty:
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1848:9
     |
1846 |         if not self._dirty and self._cache.compressed is not None:
1847 |             return self._cache.compressed
1848 |         json_bytes = self._cache.json_bytes
     |         ^^^^^^^^^^
1849 |         if json_bytes is None or self._dirty:
1850 |             json_bytes = orjson.dumps(self.serialise())
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1849:45
     |
1847 |             return self._cache.compressed
1848 |         json_bytes = self._cache.json_bytes
1849 |         if json_bytes is None or self._dirty:
     |                                             ^
1850 |             json_bytes = orjson.dumps(self.serialise())
1851 |             self._cache.json_bytes = json_bytes
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1851:13
     |
1849 |         if json_bytes is None or self._dirty:
1850 |             json_bytes = orjson.dumps(self.serialise())
1851 |             self._cache.json_bytes = json_bytes
     |             ^^^^
1852 |         start = time.perf_counter()
1853 |         compressed = zlib.compress(json_bytes)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1852:9
     |
1850 |             json_bytes = orjson.dumps(self.serialise())
1851 |             self._cache.json_bytes = json_bytes
1852 |         start = time.perf_counter()
     |         ^^^^^
1853 |         compressed = zlib.compress(json_bytes)
1854 |         duration = time.perf_counter() - start
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1853:9
     |
1851 |             self._cache.json_bytes = json_bytes
1852 |         start = time.perf_counter()
1853 |         compressed = zlib.compress(json_bytes)
     |         ^^^^^^^^^^
1854 |         duration = time.perf_counter() - start
1855 |         _STATE_SERIALISE_COUNTER.labels(format="compressed").inc()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1854:9
     |
1852 |         start = time.perf_counter()
1853 |         compressed = zlib.compress(json_bytes)
1854 |         duration = time.perf_counter() - start
     |         ^^^^^^^^
1855 |         _STATE_SERIALISE_COUNTER.labels(format="compressed").inc()
1856 |         _STATE_SERIALISE_LATENCY.labels(format="compressed").observe(duration)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1855:9
     |
1853 |         compressed = zlib.compress(json_bytes)
1854 |         duration = time.perf_counter() - start
1855 |         _STATE_SERIALISE_COUNTER.labels(format="compressed").inc()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^
1856 |         _STATE_SERIALISE_LATENCY.labels(format="compressed").observe(duration)
1857 |         self._cache.compressed = compressed
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1856:9
     |
1854 |         duration = time.perf_counter() - start
1855 |         _STATE_SERIALISE_COUNTER.labels(format="compressed").inc()
1856 |         _STATE_SERIALISE_LATENCY.labels(format="compressed").observe(duration)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^
1857 |         self._cache.compressed = compressed
1858 |         start = time.perf_counter()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1857:9
     |
1855 |         _STATE_SERIALISE_COUNTER.labels(format="compressed").inc()
1856 |         _STATE_SERIALISE_LATENCY.labels(format="compressed").observe(duration)
1857 |         self._cache.compressed = compressed
     |         ^^^^
1858 |         start = time.perf_counter()
1859 |         encoded = self.serialise_json().encode("utf-8")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1858:9
     |
1856 |         _STATE_SERIALISE_LATENCY.labels(format="compressed").observe(duration)
1857 |         self._cache.compressed = compressed
1858 |         start = time.perf_counter()
     |         ^^^^^
1859 |         encoded = self.serialise_json().encode("utf-8")
1860 |         compressed = zlib.compress(encoded)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1859:9
     |
1857 |         self._cache.compressed = compressed
1858 |         start = time.perf_counter()
1859 |         encoded = self.serialise_json().encode("utf-8")
     |         ^^^^^^^
1860 |         compressed = zlib.compress(encoded)
1861 |         elapsed = time.perf_counter() - start
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1860:9
     |
1858 |         start = time.perf_counter()
1859 |         encoded = self.serialise_json().encode("utf-8")
1860 |         compressed = zlib.compress(encoded)
     |         ^^^^^^^^^^
1861 |         elapsed = time.perf_counter() - start
1862 |         _STATE_SERIALISATION_LATENCY.labels(format="compressed").observe(elapsed)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1861:9
     |
1859 |         encoded = self.serialise_json().encode("utf-8")
1860 |         compressed = zlib.compress(encoded)
1861 |         elapsed = time.perf_counter() - start
     |         ^^^^^^^
1862 |         _STATE_SERIALISATION_LATENCY.labels(format="compressed").observe(elapsed)
1863 |         return compressed
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1862:9
     |
1860 |         compressed = zlib.compress(encoded)
1861 |         elapsed = time.perf_counter() - start
1862 |         _STATE_SERIALISATION_LATENCY.labels(format="compressed").observe(elapsed)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1863 |         return compressed
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1863:9
     |
1861 |         elapsed = time.perf_counter() - start
1862 |         _STATE_SERIALISATION_LATENCY.labels(format="compressed").observe(elapsed)
1863 |         return compressed
     |         ^^^^^^
1864 |
1865 |     def serialise_base64(self) -> str:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1865:5
     |
1863 |         return compressed
1864 |
1865 |     def serialise_base64(self) -> str:
     |     ^^^
1866 |         """Return a base64 encoded compressed snapshot."""
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1868:9
     |
1866 |         """Return a base64 encoded compressed snapshot."""
1867 |
1868 |         start = time.perf_counter()
     |         ^^^^^
1869 |         compressed = self.serialise_compressed()
1870 |         encoded = base64.b64encode(compressed).decode("ascii")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1869:9
     |
1868 |         start = time.perf_counter()
1869 |         compressed = self.serialise_compressed()
     |         ^^^^^^^^^^
1870 |         encoded = base64.b64encode(compressed).decode("ascii")
1871 |         elapsed = time.perf_counter() - start
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1870:9
     |
1868 |         start = time.perf_counter()
1869 |         compressed = self.serialise_compressed()
1870 |         encoded = base64.b64encode(compressed).decode("ascii")
     |         ^^^^^^^
1871 |         elapsed = time.perf_counter() - start
1872 |         _STATE_SERIALISATION_LATENCY.labels(format="base64").observe(elapsed)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1871:9
     |
1869 |         compressed = self.serialise_compressed()
1870 |         encoded = base64.b64encode(compressed).decode("ascii")
1871 |         elapsed = time.perf_counter() - start
     |         ^^^^^^^
1872 |         _STATE_SERIALISATION_LATENCY.labels(format="base64").observe(elapsed)
1873 |         return encoded
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1872:9
     |
1870 |         encoded = base64.b64encode(compressed).decode("ascii")
1871 |         elapsed = time.perf_counter() - start
1872 |         _STATE_SERIALISATION_LATENCY.labels(format="base64").observe(elapsed)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1873 |         return encoded
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1873:9
     |
1871 |         elapsed = time.perf_counter() - start
1872 |         _STATE_SERIALISATION_LATENCY.labels(format="base64").observe(elapsed)
1873 |         return encoded
     |         ^^^^^^
1874 |
1875 |     def persist_with_retry(self, persist: Callable[[dict[str, Any]], None]) -> None:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1875:5
     |
1873 |         return encoded
1874 |
1875 |     def persist_with_retry(self, persist: Callable[[dict[str, Any]], None]) -> None:
     |     ^^^
1876 |         """Persist the current snapshot using tenacity-backed retries."""
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1878:9
     |
1876 |         """Persist the current snapshot using tenacity-backed retries."""
1877 |
1878 |         snapshot = self.serialise()
     |         ^^^^^^^^
1879 |
1880 |         @retry(
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1886:9
     |
1884 |             retry=retry_if_exception_type(Exception),
1885 |         )
1886 |         def _attempt(payload: dict[str, Any]) -> None:
     |         ^^^
1887 |             persist(payload)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1889:9
     |
1887 |             persist(payload)
1888 |
1889 |         _attempt(snapshot)
     |         ^^^^^^^^
1890 |         _STATE_MUTATIONS.labels(operation="persist").inc()
1891 |         _state_logger.debug(
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1890:9
     |
1889 |         _attempt(snapshot)
1890 |         _STATE_MUTATIONS.labels(operation="persist").inc()
     |         ^^^^^^^^^^^^^^^^
1891 |         _state_logger.debug(
1892 |             "pipeline_state.persisted",
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1891:9
     |
1889 |         _attempt(snapshot)
1890 |         _STATE_MUTATIONS.labels(operation="persist").inc()
1891 |         _state_logger.debug(
     |         ^^^^^^^^^^^^^
1892 |             "pipeline_state.persisted",
1893 |             tenant_id=self._tenant_id,
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1891:9
     |
1889 |           _attempt(snapshot)
1890 |           _STATE_MUTATIONS.labels(operation="persist").inc()
1891 | /         _state_logger.debug(
1892 | |             "pipeline_state.persisted",
1893 | |             tenant_id=self._tenant_id,
1894 | |             job_id=self.job_id,
1895 | |         )
1896 | |         if not self._dirty and self._cache.compressed is not None:
     | |_________________________________________________________________^
1897 |               return self._cache.compressed
1898 |           json_bytes = self._cache.json_bytes
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1896:66
     |
1894 |             job_id=self.job_id,
1895 |         )
1896 |         if not self._dirty and self._cache.compressed is not None:
     |                                                                  ^
1897 |             return self._cache.compressed
1898 |         json_bytes = self._cache.json_bytes
     |

invalid-syntax: Expected an identifier, but found a keyword 'return' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1897:13
     |
1895 |         )
1896 |         if not self._dirty and self._cache.compressed is not None:
1897 |             return self._cache.compressed
     |             ^^^^^^
1898 |         json_bytes = self._cache.json_bytes
1899 |         if json_bytes is None or self._dirty:
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1897:20
     |
1895 |         )
1896 |         if not self._dirty and self._cache.compressed is not None:
1897 |             return self._cache.compressed
     |                    ^^^^
1898 |         json_bytes = self._cache.json_bytes
1899 |         if json_bytes is None or self._dirty:
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1898:9
     |
1896 |         if not self._dirty and self._cache.compressed is not None:
1897 |             return self._cache.compressed
1898 |         json_bytes = self._cache.json_bytes
     |         ^^^^^^^^^^
1899 |         if json_bytes is None or self._dirty:
1900 |             json_bytes = orjson.dumps(self.serialise())
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1899:45
     |
1897 |             return self._cache.compressed
1898 |         json_bytes = self._cache.json_bytes
1899 |         if json_bytes is None or self._dirty:
     |                                             ^
1900 |             json_bytes = orjson.dumps(self.serialise())
1901 |             self._cache.json_bytes = json_bytes
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1901:13
     |
1899 |         if json_bytes is None or self._dirty:
1900 |             json_bytes = orjson.dumps(self.serialise())
1901 |             self._cache.json_bytes = json_bytes
     |             ^^^^
1902 |         start = time.perf_counter()
1903 |         compressed = zlib.compress(json_bytes)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1902:9
     |
1900 |             json_bytes = orjson.dumps(self.serialise())
1901 |             self._cache.json_bytes = json_bytes
1902 |         start = time.perf_counter()
     |         ^^^^^
1903 |         compressed = zlib.compress(json_bytes)
1904 |         duration = time.perf_counter() - start
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1903:9
     |
1901 |             self._cache.json_bytes = json_bytes
1902 |         start = time.perf_counter()
1903 |         compressed = zlib.compress(json_bytes)
     |         ^^^^^^^^^^
1904 |         duration = time.perf_counter() - start
1905 |         _STATE_SERIALISE_COUNTER.labels(format="compressed").inc()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1904:9
     |
1902 |         start = time.perf_counter()
1903 |         compressed = zlib.compress(json_bytes)
1904 |         duration = time.perf_counter() - start
     |         ^^^^^^^^
1905 |         _STATE_SERIALISE_COUNTER.labels(format="compressed").inc()
1906 |         _STATE_SERIALISE_LATENCY.labels(format="compressed").observe(duration)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1905:9
     |
1903 |         compressed = zlib.compress(json_bytes)
1904 |         duration = time.perf_counter() - start
1905 |         _STATE_SERIALISE_COUNTER.labels(format="compressed").inc()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^
1906 |         _STATE_SERIALISE_LATENCY.labels(format="compressed").observe(duration)
1907 |         self._cache.compressed = compressed
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1906:9
     |
1904 |         duration = time.perf_counter() - start
1905 |         _STATE_SERIALISE_COUNTER.labels(format="compressed").inc()
1906 |         _STATE_SERIALISE_LATENCY.labels(format="compressed").observe(duration)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^
1907 |         self._cache.compressed = compressed
1908 |         return compressed
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1907:9
     |
1905 |         _STATE_SERIALISE_COUNTER.labels(format="compressed").inc()
1906 |         _STATE_SERIALISE_LATENCY.labels(format="compressed").observe(duration)
1907 |         self._cache.compressed = compressed
     |         ^^^^
1908 |         return compressed
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1908:9
     |
1906 |         _STATE_SERIALISE_LATENCY.labels(format="compressed").observe(duration)
1907 |         self._cache.compressed = compressed
1908 |         return compressed
     |         ^^^^^^
1909 |
1910 |         payload = self.serialise(use_cache=use_cache)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1910:9
     |
1908 |         return compressed
1909 |
1910 |         payload = self.serialise(use_cache=use_cache)
     |         ^^^^^^^
1911 |         if use_cache and not self._dirty:
1912 |             cached = self._SERIALISATION_CACHE.get(self._cache_key())
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1911:41
     |
1910 |         payload = self.serialise(use_cache=use_cache)
1911 |         if use_cache and not self._dirty:
     |                                         ^
1912 |             cached = self._SERIALISATION_CACHE.get(self._cache_key())
1913 |             if cached is not None:
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1913:34
     |
1911 |         if use_cache and not self._dirty:
1912 |             cached = self._SERIALISATION_CACHE.get(self._cache_key())
1913 |             if cached is not None:
     |                                  ^
1914 |                 return zlib.compress(cached)
1915 |         blob = dumps_orjson(payload)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1915:9
     |
1913 |             if cached is not None:
1914 |                 return zlib.compress(cached)
1915 |         blob = dumps_orjson(payload)
     |         ^^^^
1916 |         if use_cache and not self._dirty:
1917 |             self._SERIALISATION_CACHE.set(self._cache_key(), blob)
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1916:41
     |
1914 |                 return zlib.compress(cached)
1915 |         blob = dumps_orjson(payload)
1916 |         if use_cache and not self._dirty:
     |                                         ^
1917 |             self._SERIALISATION_CACHE.set(self._cache_key(), blob)
1918 |         return zlib.compress(blob)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1918:9
     |
1916 |         if use_cache and not self._dirty:
1917 |             self._SERIALISATION_CACHE.set(self._cache_key(), blob)
1918 |         return zlib.compress(blob)
     |         ^^^^^^
1919 |
1920 |     def serialise_base64(self, *, use_cache: bool = True) -> str:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1920:5
     |
1918 |         return zlib.compress(blob)
1919 |
1920 |     def serialise_base64(self, *, use_cache: bool = True) -> str:
     |     ^^^
1921 |         """Return a base64 encoded compressed snapshot."""
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1923:9
     |
1921 |         """Return a base64 encoded compressed snapshot."""
1922 |
1923 |         payload = self.serialise(use_cache=use_cache)
     |         ^^^^^^^
1924 |         blob = dumps_orjson(payload)
1925 |         if use_cache and not self._dirty:
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1924:9
     |
1923 |         payload = self.serialise(use_cache=use_cache)
1924 |         blob = dumps_orjson(payload)
     |         ^^^^
1925 |         if use_cache and not self._dirty:
1926 |             self._SERIALISATION_CACHE.set(self._cache_key(), blob)
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1925:41
     |
1923 |         payload = self.serialise(use_cache=use_cache)
1924 |         blob = dumps_orjson(payload)
1925 |         if use_cache and not self._dirty:
     |                                         ^
1926 |             self._SERIALISATION_CACHE.set(self._cache_key(), blob)
1927 |         return encode_base64(blob)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1927:9
     |
1925 |         if use_cache and not self._dirty:
1926 |             self._SERIALISATION_CACHE.set(self._cache_key(), blob)
1927 |         return encode_base64(blob)
     |         ^^^^^^
1928 |         if not self._dirty and self._cache.base64_payload is not None:
1929 |             return self._cache.base64_payload
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1928:70
     |
1926 |             self._SERIALISATION_CACHE.set(self._cache_key(), blob)
1927 |         return encode_base64(blob)
1928 |         if not self._dirty and self._cache.base64_payload is not None:
     |                                                                      ^
1929 |             return self._cache.base64_payload
1930 |         compressed = self.serialise_compressed()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1930:9
     |
1928 |         if not self._dirty and self._cache.base64_payload is not None:
1929 |             return self._cache.base64_payload
1930 |         compressed = self.serialise_compressed()
     |         ^^^^^^^^^^
1931 |         encoded = base64.b64encode(compressed).decode("ascii")
1932 |         self._cache.base64_payload = encoded
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1931:9
     |
1929 |             return self._cache.base64_payload
1930 |         compressed = self.serialise_compressed()
1931 |         encoded = base64.b64encode(compressed).decode("ascii")
     |         ^^^^^^^
1932 |         self._cache.base64_payload = encoded
1933 |         return encoded
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1932:9
     |
1930 |         compressed = self.serialise_compressed()
1931 |         encoded = base64.b64encode(compressed).decode("ascii")
1932 |         self._cache.base64_payload = encoded
     |         ^^^^
1933 |         return encoded
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1933:9
     |
1931 |         encoded = base64.b64encode(compressed).decode("ascii")
1932 |         self._cache.base64_payload = encoded
1933 |         return encoded
     |         ^^^^^^
1934 |
1935 |     @retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=0.2, max=2.0))
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1936:5
     |
1935 |     @retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=0.2, max=2.0))
1936 |     def persist_with_retry(
     |     ^^^
1937 |         self,
1938 |         writer: Callable[[bytes], Any],
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1942:9
     |
1940 |           format: str = "json",
1941 |       ) -> Any:
1942 | /         """Persist the state payload using the supplied writer with retries."""
1943 | |
1944 | |         if format == "json":
     | |___________________________^
1945 |               payload = self.serialise_json().encode("utf-8")
1946 |           elif format == "compressed":
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1944:28
     |
1942 |         """Persist the state payload using the supplied writer with retries."""
1943 |
1944 |         if format == "json":
     |                            ^
1945 |             payload = self.serialise_json().encode("utf-8")
1946 |         elif format == "compressed":
     |

invalid-syntax: Expected newline, found 'elif'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1946:9
     |
1944 |         if format == "json":
1945 |             payload = self.serialise_json().encode("utf-8")
1946 |         elif format == "compressed":
     |         ^^^^
1947 |             payload = self.serialise_compressed()
1948 |         else:
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1946:14
     |
1944 |         if format == "json":
1945 |             payload = self.serialise_json().encode("utf-8")
1946 |         elif format == "compressed":
     |              ^^^^^^^^^^^^^^^^^^^^^^
1947 |             payload = self.serialise_compressed()
1948 |         else:
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1948:9
     |
1946 |         elif format == "compressed":
1947 |             payload = self.serialise_compressed()
1948 |         else:
     |         ^^^^
1949 |             raise ValueError(f"Unsupported persistence format '{format}'")
1950 |         try:
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1948:13
     |
1946 |         elif format == "compressed":
1947 |             payload = self.serialise_compressed()
1948 |         else:
     |             ^
1949 |             raise ValueError(f"Unsupported persistence format '{format}'")
1950 |         try:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1950:9
     |
1948 |         else:
1949 |             raise ValueError(f"Unsupported persistence format '{format}'")
1950 |         try:
     |         ^^^
1951 |             result = writer(payload)
1952 |         except Exception as exc:
     |

invalid-syntax: Expected newline, found 'except'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1952:9
     |
1950 |         try:
1951 |             result = writer(payload)
1952 |         except Exception as exc:
     |         ^^^^^^
1953 |             _STATE_PERSIST_COUNTER.labels(format=format, status="error").inc()
1954 |             _state_logger.error(
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1954:13
     |
1952 |         except Exception as exc:
1953 |             _STATE_PERSIST_COUNTER.labels(format=format, status="error").inc()
1954 |             _state_logger.error(
     |             ^^^^^^^^^^^^^
1955 |                 "pipeline_state.persist.failure",
1956 |                 format=format,
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1959:13
     |
1957 |                 error=str(exc),
1958 |             )
1959 |             raise
     |             ^^^^^
1960 |         _STATE_PERSIST_COUNTER.labels(format=format, status="success").inc()
1961 |         _state_logger.debug(
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1961:9
     |
1959 |             raise
1960 |         _STATE_PERSIST_COUNTER.labels(format=format, status="success").inc()
1961 |         _state_logger.debug(
     |         ^^^^^^^^^^^^^
1962 |             "pipeline_state.persist.success",
1963 |             format=format,
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1966:9
     |
1964 |             size=len(payload),
1965 |         )
1966 |         return result
     |         ^^^^^^
1967 |
1968 |     def diff(self, other: PipelineState) -> dict[str, tuple[Any, Any]]:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1968:5
     |
1966 |         return result
1967 |
1968 |     def diff(self, other: PipelineState) -> dict[str, tuple[Any, Any]]:
     |     ^^^
1969 |         """Produce a minimal diff between two states."""
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1971:9
     |
1969 |         """Produce a minimal diff between two states."""
1970 |
1971 |         entries: dict[str, tuple[Any, Any]] = {}
     |         ^^^^^^^
1972 |         if len(self.payloads) != len(other.payloads):
1973 |             entries["payload_count"] = (len(self.payloads), len(other.payloads))
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1972:53
     |
1971 |         entries: dict[str, tuple[Any, Any]] = {}
1972 |         if len(self.payloads) != len(other.payloads):
     |                                                     ^
1973 |             entries["payload_count"] = (len(self.payloads), len(other.payloads))
1974 |         if len(self.chunks) != len(other.chunks):
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1974:49
     |
1972 |         if len(self.payloads) != len(other.payloads):
1973 |             entries["payload_count"] = (len(self.payloads), len(other.payloads))
1974 |         if len(self.chunks) != len(other.chunks):
     |                                                 ^
1975 |             entries["chunk_count"] = (len(self.chunks), len(other.chunks))
1976 |         self_embeddings = (
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1976:9
     |
1974 |         if len(self.chunks) != len(other.chunks):
1975 |             entries["chunk_count"] = (len(self.chunks), len(other.chunks))
1976 |         self_embeddings = (
     |         ^^^^^^^^^^^^^^^
1977 |             len(self.embedding_batch.vectors) if self.embedding_batch else 0
1978 |         )
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1979:9
     |
1977 |             len(self.embedding_batch.vectors) if self.embedding_batch else 0
1978 |         )
1979 |         other_embeddings = (
     |         ^^^^^^^^^^^^^^^^
1980 |             len(other.embedding_batch.vectors) if other.embedding_batch else 0
1981 |         )
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1982:47
     |
1980 |             len(other.embedding_batch.vectors) if other.embedding_batch else 0
1981 |         )
1982 |         if self_embeddings != other_embeddings:
     |                                               ^
1983 |             entries["embedding_count"] = (self_embeddings, other_embeddings)
1984 |         if len(self.entities) != len(other.entities):
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1984:53
     |
1982 |         if self_embeddings != other_embeddings:
1983 |             entries["embedding_count"] = (self_embeddings, other_embeddings)
1984 |         if len(self.entities) != len(other.entities):
     |                                                     ^
1985 |             entries["entity_count"] = (len(self.entities), len(other.entities))
1986 |         if len(self.claims) != len(other.claims):
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1986:49
     |
1984 |         if len(self.entities) != len(other.entities):
1985 |             entries["entity_count"] = (len(self.entities), len(other.entities))
1986 |         if len(self.claims) != len(other.claims):
     |                                                 ^
1987 |             entries["claim_count"] = (len(self.claims), len(other.claims))
1988 |         if len(self.downloads) != len(other.downloads):
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1988:55
     |
1986 |         if len(self.claims) != len(other.claims):
1987 |             entries["claim_count"] = (len(self.claims), len(other.claims))
1988 |         if len(self.downloads) != len(other.downloads):
     |                                                       ^
1989 |             entries["download_count"] = (len(self.downloads), len(other.downloads))
1990 |         self_gates = {name: decision.ready for name, decision in self.gate_decisions.items()}
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1990:9
     |
1988 |         if len(self.downloads) != len(other.downloads):
1989 |             entries["download_count"] = (len(self.downloads), len(other.downloads))
1990 |         self_gates = {name: decision.ready for name, decision in self.gate_decisions.items()}
     |         ^^^^^^^^^^
1991 |         other_gates = {name: decision.ready for name, decision in other.gate_decisions.items()}
1992 |         if self_gates != other_gates:
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1991:9
     |
1989 |             entries["download_count"] = (len(self.downloads), len(other.downloads))
1990 |         self_gates = {name: decision.ready for name, decision in self.gate_decisions.items()}
1991 |         other_gates = {name: decision.ready for name, decision in other.gate_decisions.items()}
     |         ^^^^^^^^^^^
1992 |         if self_gates != other_gates:
1993 |             entries["gate_status"] = (self_gates, other_gates)
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1992:37
     |
1990 |         self_gates = {name: decision.ready for name, decision in self.gate_decisions.items()}
1991 |         other_gates = {name: decision.ready for name, decision in other.gate_decisions.items()}
1992 |         if self_gates != other_gates:
     |                                     ^
1993 |             entries["gate_status"] = (self_gates, other_gates)
1994 |         if len(self.pdf_assets) != len(other.pdf_assets):
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1994:57
     |
1992 |         if self_gates != other_gates:
1993 |             entries["gate_status"] = (self_gates, other_gates)
1994 |         if len(self.pdf_assets) != len(other.pdf_assets):
     |                                                         ^
1995 |             entries["pdf_asset_count"] = (len(self.pdf_assets), len(other.pdf_assets))
1996 |         if self.gate_status != other.gate_status:
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1996:49
     |
1994 |         if len(self.pdf_assets) != len(other.pdf_assets):
1995 |             entries["pdf_asset_count"] = (len(self.pdf_assets), len(other.pdf_assets))
1996 |         if self.gate_status != other.gate_status:
     |                                                 ^
1997 |             entries["gate_status"] = (dict(self.gate_status), dict(other.gate_status))
1998 |         if self.context.pipeline_version != other.context.pipeline_version:
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:1998:75
     |
1996 |         if self.gate_status != other.gate_status:
1997 |             entries["gate_status"] = (dict(self.gate_status), dict(other.gate_status))
1998 |         if self.context.pipeline_version != other.context.pipeline_version:
     |                                                                           ^
1999 |             entries["pipeline_version"] = (
2000 |                 self.context.pipeline_version,
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2003:39
     |
2001 |                 other.context.pipeline_version,
2002 |             )
2003 |         if self.job_id != other.job_id:
     |                                       ^
2004 |             entries["job_id"] = (self.job_id, other.job_id)
2005 |         return entries
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2005:9
     |
2003 |         if self.job_id != other.job_id:
2004 |             entries["job_id"] = (self.job_id, other.job_id)
2005 |         return entries
     |         ^^^^^^
2006 |
2007 |     @classmethod
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2008:5
     |
2007 |     @classmethod
2008 |     def recover(
     |     ^^^
2009 |         cls,
2010 |         payload: Mapping[str, Any] | bytes | str,
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2015:9
     |
2013 |           adapter_request: AdapterRequest,
2014 |       ) -> PipelineState:
2015 | /         """Best-effort recovery for pipeline state snapshots."""
2016 | |
2017 | |         if isinstance(payload, (bytes, bytearray)):
     | |__________________________________________________^
2018 |               decoded = zlib.decompress(bytes(payload)).decode("utf-8")
2019 |               decoded = zlib.decompress(bytes(payload))
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2017:51
     |
2015 |         """Best-effort recovery for pipeline state snapshots."""
2016 |
2017 |         if isinstance(payload, (bytes, bytearray)):
     |                                                   ^
2018 |             decoded = zlib.decompress(bytes(payload)).decode("utf-8")
2019 |             decoded = zlib.decompress(bytes(payload))
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2019:13
     |
2017 |         if isinstance(payload, (bytes, bytearray)):
2018 |             decoded = zlib.decompress(bytes(payload)).decode("utf-8")
2019 |             decoded = zlib.decompress(bytes(payload))
     |             ^^^^^^^
2020 |             recovered = orjson.loads(decoded)
2021 |         elif isinstance(payload, str):
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2020:13
     |
2018 |             decoded = zlib.decompress(bytes(payload)).decode("utf-8")
2019 |             decoded = zlib.decompress(bytes(payload))
2020 |             recovered = orjson.loads(decoded)
     |             ^^^^^^^^^
2021 |         elif isinstance(payload, str):
2022 |             try:
     |

invalid-syntax: Expected newline, found 'elif'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2021:9
     |
2019 |             decoded = zlib.decompress(bytes(payload))
2020 |             recovered = orjson.loads(decoded)
2021 |         elif isinstance(payload, str):
     |         ^^^^
2022 |             try:
2023 |                 compressed = base64.b64decode(payload)
     |

invalid-syntax: Invalid annotated assignment target
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2021:14
     |
2019 |             decoded = zlib.decompress(bytes(payload))
2020 |             recovered = orjson.loads(decoded)
2021 |         elif isinstance(payload, str):
     |              ^^^^^^^^^^^^^^^^^^^^^^^^
2022 |             try:
2023 |                 compressed = base64.b64decode(payload)
     |

invalid-syntax: Expected an identifier, but found a keyword 'try' that cannot be used here
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2022:13
     |
2020 |             recovered = orjson.loads(decoded)
2021 |         elif isinstance(payload, str):
2022 |             try:
     |             ^^^
2023 |                 compressed = base64.b64decode(payload)
2024 |             except (ValueError, TypeError):
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2022:16
     |
2020 |             recovered = orjson.loads(decoded)
2021 |         elif isinstance(payload, str):
2022 |             try:
     |                ^
2023 |                 compressed = base64.b64decode(payload)
2024 |             except (ValueError, TypeError):
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2024:13
     |
2022 |             try:
2023 |                 compressed = base64.b64decode(payload)
2024 |             except (ValueError, TypeError):
     |             ^^^^^^
2025 |                 recovered = orjson.loads(payload)
2026 |             else:
     |

invalid-syntax: Only single target (not tuple) can be annotated
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2024:20
     |
2022 |             try:
2023 |                 compressed = base64.b64decode(payload)
2024 |             except (ValueError, TypeError):
     |                    ^^^^^^^^^^^^^^^^^^^^^^^
2025 |                 recovered = orjson.loads(payload)
2026 |             else:
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2026:13
     |
2024 |             except (ValueError, TypeError):
2025 |                 recovered = orjson.loads(payload)
2026 |             else:
     |             ^^^^
2027 |                 decoded = zlib.decompress(compressed).decode("utf-8")
2028 |                 decoded = zlib.decompress(compressed)
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2026:17
     |
2024 |             except (ValueError, TypeError):
2025 |                 recovered = orjson.loads(payload)
2026 |             else:
     |                 ^
2027 |                 decoded = zlib.decompress(compressed).decode("utf-8")
2028 |                 decoded = zlib.decompress(compressed)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2028:17
     |
2026 |             else:
2027 |                 decoded = zlib.decompress(compressed).decode("utf-8")
2028 |                 decoded = zlib.decompress(compressed)
     |                 ^^^^^^^
2029 |                 recovered = orjson.loads(decoded)
2030 |         else:
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2029:17
     |
2027 |                 decoded = zlib.decompress(compressed).decode("utf-8")
2028 |                 decoded = zlib.decompress(compressed)
2029 |                 recovered = orjson.loads(decoded)
     |                 ^^^^^^^^^
2030 |         else:
2031 |             recovered = payload
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2030:9
     |
2028 |                 decoded = zlib.decompress(compressed)
2029 |                 recovered = orjson.loads(decoded)
2030 |         else:
     |         ^^^^
2031 |             recovered = payload
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2030:13
     |
2028 |                 decoded = zlib.decompress(compressed)
2029 |                 recovered = orjson.loads(decoded)
2030 |         else:
     |             ^
2031 |             recovered = payload
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2033:46
     |
2031 |             recovered = payload
2032 |
2033 |         if not isinstance(recovered, Mapping):
     |                                              ^
2034 |             recovered = {}
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2036:9
     |
2034 |             recovered = {}
2035 |
2036 |         state = cls.initialise(
     |         ^^^^^
2037 |             context=context,
2038 |             adapter_request=adapter_request,
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2041:9
     |
2039 |             payload=recovered.get("payload"),
2040 |         )
2041 |         state.schema_version = str(recovered.get("version", "v1"))
     |         ^^^^^
2042 |         state.job_id = recovered.get("job_id") or context.job_id
2043 |         state.metadata.update(dict(recovered.get("metadata", {})))
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2042:9
     |
2040 |         )
2041 |         state.schema_version = str(recovered.get("version", "v1"))
2042 |         state.job_id = recovered.get("job_id") or context.job_id
     |         ^^^^^
2043 |         state.metadata.update(dict(recovered.get("metadata", {})))
2044 |         pdf_payload = recovered.get("pdf")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2043:9
     |
2041 |         state.schema_version = str(recovered.get("version", "v1"))
2042 |         state.job_id = recovered.get("job_id") or context.job_id
2043 |         state.metadata.update(dict(recovered.get("metadata", {})))
     |         ^^^^^
2044 |         pdf_payload = recovered.get("pdf")
2045 |         if isinstance(pdf_payload, Mapping):
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2044:9
     |
2042 |         state.job_id = recovered.get("job_id") or context.job_id
2043 |         state.metadata.update(dict(recovered.get("metadata", {})))
2044 |         pdf_payload = recovered.get("pdf")
     |         ^^^^^^^^^^^
2045 |         if isinstance(pdf_payload, Mapping):
2046 |             state.pdf_tracker.downloads = tuple(str(item) for item in pdf_payload.get("downloads", ()))
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2045:44
     |
2043 |         state.metadata.update(dict(recovered.get("metadata", {})))
2044 |         pdf_payload = recovered.get("pdf")
2045 |         if isinstance(pdf_payload, Mapping):
     |                                            ^
2046 |             state.pdf_tracker.downloads = tuple(str(item) for item in pdf_payload.get("downloads", ()))
2047 |             state.pdf_tracker.last_attempt_ms = pdf_payload.get("last_attempt_ms")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2047:13
     |
2045 |         if isinstance(pdf_payload, Mapping):
2046 |             state.pdf_tracker.downloads = tuple(str(item) for item in pdf_payload.get("downloads", ()))
2047 |             state.pdf_tracker.last_attempt_ms = pdf_payload.get("last_attempt_ms")
     |             ^^^^^
2048 |             state.pdf_tracker.gate_open = bool(pdf_payload.get("gate_open", False))
2049 |             state.pdf_tracker.gate_reason = pdf_payload.get("gate_reason")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2048:13
     |
2046 |             state.pdf_tracker.downloads = tuple(str(item) for item in pdf_payload.get("downloads", ()))
2047 |             state.pdf_tracker.last_attempt_ms = pdf_payload.get("last_attempt_ms")
2048 |             state.pdf_tracker.gate_open = bool(pdf_payload.get("gate_open", False))
     |             ^^^^^
2049 |             state.pdf_tracker.gate_reason = pdf_payload.get("gate_reason")
2050 |             state.pdf_tracker.ledger_reference = pdf_payload.get("ledger_reference")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2049:13
     |
2047 |             state.pdf_tracker.last_attempt_ms = pdf_payload.get("last_attempt_ms")
2048 |             state.pdf_tracker.gate_open = bool(pdf_payload.get("gate_open", False))
2049 |             state.pdf_tracker.gate_reason = pdf_payload.get("gate_reason")
     |             ^^^^^
2050 |             state.pdf_tracker.ledger_reference = pdf_payload.get("ledger_reference")
2051 |         stage_payload = recovered.get("stage_results")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2050:13
     |
2048 |             state.pdf_tracker.gate_open = bool(pdf_payload.get("gate_open", False))
2049 |             state.pdf_tracker.gate_reason = pdf_payload.get("gate_reason")
2050 |             state.pdf_tracker.ledger_reference = pdf_payload.get("ledger_reference")
     |             ^^^^^
2051 |         stage_payload = recovered.get("stage_results")
2052 |         if isinstance(stage_payload, Mapping):
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2051:9
     |
2049 |             state.pdf_tracker.gate_reason = pdf_payload.get("gate_reason")
2050 |             state.pdf_tracker.ledger_reference = pdf_payload.get("ledger_reference")
2051 |         stage_payload = recovered.get("stage_results")
     |         ^^^^^^^^^^^^^
2052 |         if isinstance(stage_payload, Mapping):
2053 |             for name, payload_data in stage_payload.items():
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2052:46
     |
2050 |             state.pdf_tracker.ledger_reference = pdf_payload.get("ledger_reference")
2051 |         stage_payload = recovered.get("stage_results")
2052 |         if isinstance(stage_payload, Mapping):
     |                                              ^
2053 |             for name, payload_data in stage_payload.items():
2054 |                 if isinstance(payload_data, Mapping):
     |

invalid-syntax: Expected a simple statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2054:17
     |
2052 |         if isinstance(stage_payload, Mapping):
2053 |             for name, payload_data in stage_payload.items():
2054 |                 if isinstance(payload_data, Mapping):
     |                 ^^
2055 |                     state.stage_results[name] = StageResultSnapshot(
2056 |                         stage=str(payload_data.get("stage", name)),
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2063:9
     |
2061 |                         error=payload_data.get("error"),
2062 |                     )
2063 |         gates = recovered.get("gate_status")
     |         ^^^^^
2064 |         if isinstance(gates, Mapping):
2065 |             for name, ready in gates.items():
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2064:38
     |
2062 |                     )
2063 |         gates = recovered.get("gate_status")
2064 |         if isinstance(gates, Mapping):
     |                                      ^
2065 |             for name, ready in gates.items():
2066 |                 state.gate_decisions[str(name)] = GateDecision(
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2069:9
     |
2067 |                     name=str(name), ready=bool(ready)
2068 |                 )
2069 |         pdf_payload = recovered.get("pdf_assets")
     |         ^^^^^^^^^^^
2070 |         if isinstance(pdf_payload, Sequence):
2071 |             state.set_pdf_assets(pdf_payload)
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2070:45
     |
2068 |                 )
2069 |         pdf_payload = recovered.get("pdf_assets")
2070 |         if isinstance(pdf_payload, Sequence):
     |                                             ^
2071 |             state.set_pdf_assets(pdf_payload)
2072 |         gate_payload = recovered.get("gate_status")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2072:9
     |
2070 |         if isinstance(pdf_payload, Sequence):
2071 |             state.set_pdf_assets(pdf_payload)
2072 |         gate_payload = recovered.get("gate_status")
     |         ^^^^^^^^^^^^
2073 |         if isinstance(gate_payload, Mapping):
2074 |             for stage_name, ready in gate_payload.items():
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2073:45
     |
2071 |             state.set_pdf_assets(pdf_payload)
2072 |         gate_payload = recovered.get("gate_status")
2073 |         if isinstance(gate_payload, Mapping):
     |                                             ^
2074 |             for stage_name, ready in gate_payload.items():
2075 |                 if isinstance(ready, bool):
     |

invalid-syntax: Expected a simple statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2075:17
     |
2073 |         if isinstance(gate_payload, Mapping):
2074 |             for stage_name, ready in gate_payload.items():
2075 |                 if isinstance(ready, bool):
     |                 ^^
2076 |                     state.gate_status[str(stage_name)] = ready
2077 |             state.metadata.setdefault("gates", {})
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2077:13
     |
2075 |                 if isinstance(ready, bool):
2076 |                     state.gate_status[str(stage_name)] = ready
2077 |             state.metadata.setdefault("gates", {})
     |             ^^^^^
2078 |             for name, ready in state.gate_status.items():
2079 |                 state.metadata["gates"][name] = {"ready": ready, "timestamp": time.time()}
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2078:13
     |
2076 |                     state.gate_status[str(stage_name)] = ready
2077 |             state.metadata.setdefault("gates", {})
2078 |             for name, ready in state.gate_status.items():
     |             ^^^
2079 |                 state.metadata["gates"][name] = {"ready": ready, "timestamp": time.time()}
2080 |         state._dirty = False
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2080:9
     |
2078 |             for name, ready in state.gate_status.items():
2079 |                 state.metadata["gates"][name] = {"ready": ready, "timestamp": time.time()}
2080 |         state._dirty = False
     |         ^^^^^
2081 |         recovered_dict = dict(recovered)
2082 |         state._cache.payload = copy.deepcopy(recovered_dict)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2081:9
     |
2079 |                 state.metadata["gates"][name] = {"ready": ready, "timestamp": time.time()}
2080 |         state._dirty = False
2081 |         recovered_dict = dict(recovered)
     |         ^^^^^^^^^^^^^^
2082 |         state._cache.payload = copy.deepcopy(recovered_dict)
2083 |         state._cache.json_bytes = orjson.dumps(recovered_dict)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2082:9
     |
2080 |         state._dirty = False
2081 |         recovered_dict = dict(recovered)
2082 |         state._cache.payload = copy.deepcopy(recovered_dict)
     |         ^^^^^
2083 |         state._cache.json_bytes = orjson.dumps(recovered_dict)
2084 |         state._cache.compressed = zlib.compress(state._cache.json_bytes)
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2083:9
     |
2081 |         recovered_dict = dict(recovered)
2082 |         state._cache.payload = copy.deepcopy(recovered_dict)
2083 |         state._cache.json_bytes = orjson.dumps(recovered_dict)
     |         ^^^^^
2084 |         state._cache.compressed = zlib.compress(state._cache.json_bytes)
2085 |         state._cache.base64_payload = base64.b64encode(state._cache.compressed).decode("ascii")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2084:9
     |
2082 |         state._cache.payload = copy.deepcopy(recovered_dict)
2083 |         state._cache.json_bytes = orjson.dumps(recovered_dict)
2084 |         state._cache.compressed = zlib.compress(state._cache.json_bytes)
     |         ^^^^^
2085 |         state._cache.base64_payload = base64.b64encode(state._cache.compressed).decode("ascii")
2086 |         return state
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2085:9
     |
2083 |         state._cache.json_bytes = orjson.dumps(recovered_dict)
2084 |         state._cache.compressed = zlib.compress(state._cache.json_bytes)
2085 |         state._cache.base64_payload = base64.b64encode(state._cache.compressed).decode("ascii")
     |         ^^^^^
2086 |         return state
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2086:9
     |
2084 |         state._cache.compressed = zlib.compress(state._cache.json_bytes)
2085 |         state._cache.base64_payload = base64.b64encode(state._cache.compressed).decode("ascii")
2086 |         return state
     |         ^^^^^^
2087 |
2088 |     def hydrate_legacy(self, payload: Mapping[str, Any]) -> None:
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2088:5
     |
2086 |         return state
2087 |
2088 |     def hydrate_legacy(self, payload: Mapping[str, Any]) -> None:
     |     ^^^
2089 |         """Populate the state using a legacy dictionary payload."""
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2091:9
     |
2089 |         """Populate the state using a legacy dictionary payload."""
2090 |
2091 |         self.payload = dict(payload.get("payload", {}))
     |         ^^^^
2092 |         raw_payloads = payload.get("payloads")
2093 |         if isinstance(raw_payloads, Sequence):
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2092:9
     |
2091 |         self.payload = dict(payload.get("payload", {}))
2092 |         raw_payloads = payload.get("payloads")
     |         ^^^^^^^^^^^^
2093 |         if isinstance(raw_payloads, Sequence):
2094 |             self.payloads = tuple(copy.deepcopy(list(raw_payloads)))
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2093:46
     |
2091 |         self.payload = dict(payload.get("payload", {}))
2092 |         raw_payloads = payload.get("payloads")
2093 |         if isinstance(raw_payloads, Sequence):
     |                                              ^
2094 |             self.payloads = tuple(copy.deepcopy(list(raw_payloads)))
2095 |         document_payload = payload.get("document")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2095:9
     |
2093 |         if isinstance(raw_payloads, Sequence):
2094 |             self.payloads = tuple(copy.deepcopy(list(raw_payloads)))
2095 |         document_payload = payload.get("document")
     |         ^^^^^^^^^^^^^^^^
2096 |         if document_payload:
2097 |             self.document = Document.model_validate(document_payload)
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2096:28
     |
2094 |             self.payloads = tuple(copy.deepcopy(list(raw_payloads)))
2095 |         document_payload = payload.get("document")
2096 |         if document_payload:
     |                            ^
2097 |             self.document = Document.model_validate(document_payload)
2098 |         else:
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2098:9
     |
2096 |         if document_payload:
2097 |             self.document = Document.model_validate(document_payload)
2098 |         else:
     |         ^^^^
2099 |             self.document = None
2100 |         chunk_payload = payload.get("chunks")
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2098:13
     |
2096 |         if document_payload:
2097 |             self.document = Document.model_validate(document_payload)
2098 |         else:
     |             ^
2099 |             self.document = None
2100 |         chunk_payload = payload.get("chunks")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2100:9
     |
2098 |         else:
2099 |             self.document = None
2100 |         chunk_payload = payload.get("chunks")
     |         ^^^^^^^^^^^^^
2101 |         if isinstance(chunk_payload, Sequence):
2102 |             self.chunks = tuple(Chunk.model_validate(item) for item in chunk_payload)
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2101:47
     |
2099 |             self.document = None
2100 |         chunk_payload = payload.get("chunks")
2101 |         if isinstance(chunk_payload, Sequence):
     |                                               ^
2102 |             self.chunks = tuple(Chunk.model_validate(item) for item in chunk_payload)
2103 |         else:
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2103:9
     |
2101 |         if isinstance(chunk_payload, Sequence):
2102 |             self.chunks = tuple(Chunk.model_validate(item) for item in chunk_payload)
2103 |         else:
     |         ^^^^
2104 |             self.chunks = ()
2105 |         embedding_payload = payload.get("embedding_batch")
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2103:13
     |
2101 |         if isinstance(chunk_payload, Sequence):
2102 |             self.chunks = tuple(Chunk.model_validate(item) for item in chunk_payload)
2103 |         else:
     |             ^
2104 |             self.chunks = ()
2105 |         embedding_payload = payload.get("embedding_batch")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2105:9
     |
2103 |         else:
2104 |             self.chunks = ()
2105 |         embedding_payload = payload.get("embedding_batch")
     |         ^^^^^^^^^^^^^^^^^
2106 |         if isinstance(embedding_payload, Mapping):
2107 |             vectors = []
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2106:50
     |
2104 |             self.chunks = ()
2105 |         embedding_payload = payload.get("embedding_batch")
2106 |         if isinstance(embedding_payload, Mapping):
     |                                                  ^
2107 |             vectors = []
2108 |             for vector in embedding_payload.get("vectors", []):
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2108:13
     |
2106 |         if isinstance(embedding_payload, Mapping):
2107 |             vectors = []
2108 |             for vector in embedding_payload.get("vectors", []):
     |             ^^^
2109 |                 if isinstance(vector, Mapping):
2110 |                     values = tuple(float(v) for v in vector.get("values", ()))
     |

invalid-syntax: Expected a simple statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2109:17
     |
2107 |             vectors = []
2108 |             for vector in embedding_payload.get("vectors", []):
2109 |                 if isinstance(vector, Mapping):
     |                 ^^
2110 |                     values = tuple(float(v) for v in vector.get("values", ()))
2111 |                     vectors.append(
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2111:21
     |
2109 |                 if isinstance(vector, Mapping):
2110 |                     values = tuple(float(v) for v in vector.get("values", ()))
2111 |                     vectors.append(
     |                     ^^^^^^^
2112 |                         EmbeddingVector(
2113 |                             id=str(vector.get("id")),
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2118:13
     |
2116 |                         )
2117 |                     )
2118 |             self.embedding_batch = EmbeddingBatch(
     |             ^^^^
2119 |                 vectors=tuple(vectors),
2120 |                 model=str(embedding_payload.get("model", "")),
     |

invalid-syntax: Expected newline, found 'else'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2123:9
     |
2121 |                 tenant_id=str(embedding_payload.get("tenant_id", self.context.tenant_id)),
2122 |             )
2123 |         else:
     |         ^^^^
2124 |             self.embedding_batch = None
2125 |         entities_payload = payload.get("entities")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2125:9
     |
2123 |         else:
2124 |             self.embedding_batch = None
2125 |         entities_payload = payload.get("entities")
     |         ^^^^^^^^^^^^^^^^
2126 |         if isinstance(entities_payload, Sequence):
2127 |             self.entities = tuple(Entity.model_validate(item) for item in entities_payload)
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2126:50
     |
2124 |             self.embedding_batch = None
2125 |         entities_payload = payload.get("entities")
2126 |         if isinstance(entities_payload, Sequence):
     |                                                  ^
2127 |             self.entities = tuple(Entity.model_validate(item) for item in entities_payload)
2128 |         else:
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2128:9
     |
2126 |         if isinstance(entities_payload, Sequence):
2127 |             self.entities = tuple(Entity.model_validate(item) for item in entities_payload)
2128 |         else:
     |         ^^^^
2129 |             self.entities = ()
2130 |         claims_payload = payload.get("claims")
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2128:13
     |
2126 |         if isinstance(entities_payload, Sequence):
2127 |             self.entities = tuple(Entity.model_validate(item) for item in entities_payload)
2128 |         else:
     |             ^
2129 |             self.entities = ()
2130 |         claims_payload = payload.get("claims")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2130:9
     |
2128 |         else:
2129 |             self.entities = ()
2130 |         claims_payload = payload.get("claims")
     |         ^^^^^^^^^^^^^^
2131 |         if isinstance(claims_payload, Sequence):
2132 |             self.claims = tuple(Claim.model_validate(item) for item in claims_payload)
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2131:48
     |
2129 |             self.entities = ()
2130 |         claims_payload = payload.get("claims")
2131 |         if isinstance(claims_payload, Sequence):
     |                                                ^
2132 |             self.claims = tuple(Claim.model_validate(item) for item in claims_payload)
2133 |         else:
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2133:9
     |
2131 |         if isinstance(claims_payload, Sequence):
2132 |             self.claims = tuple(Claim.model_validate(item) for item in claims_payload)
2133 |         else:
     |         ^^^^
2134 |             self.claims = ()
2135 |         index_payload = payload.get("index_receipt")
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2133:13
     |
2131 |         if isinstance(claims_payload, Sequence):
2132 |             self.claims = tuple(Claim.model_validate(item) for item in claims_payload)
2133 |         else:
     |             ^
2134 |             self.claims = ()
2135 |         index_payload = payload.get("index_receipt")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2135:9
     |
2133 |         else:
2134 |             self.claims = ()
2135 |         index_payload = payload.get("index_receipt")
     |         ^^^^^^^^^^^^^
2136 |         if isinstance(index_payload, Mapping):
2137 |             self.index_receipt = IndexReceipt(
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2136:46
     |
2134 |             self.claims = ()
2135 |         index_payload = payload.get("index_receipt")
2136 |         if isinstance(index_payload, Mapping):
     |                                              ^
2137 |             self.index_receipt = IndexReceipt(
2138 |                 chunks_indexed=int(index_payload.get("chunks_indexed", 0)),
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2143:9
     |
2141 |                 metadata=dict(index_payload.get("metadata", {})),
2142 |             )
2143 |         else:
     |         ^^^^
2144 |             self.index_receipt = None
2145 |         graph_payload = payload.get("graph_receipt")
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2143:13
     |
2141 |                 metadata=dict(index_payload.get("metadata", {})),
2142 |             )
2143 |         else:
     |             ^
2144 |             self.index_receipt = None
2145 |         graph_payload = payload.get("graph_receipt")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2145:9
     |
2143 |         else:
2144 |             self.index_receipt = None
2145 |         graph_payload = payload.get("graph_receipt")
     |         ^^^^^^^^^^^^^
2146 |         if isinstance(graph_payload, Mapping):
2147 |             self.graph_receipt = GraphWriteReceipt(
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2146:46
     |
2144 |             self.index_receipt = None
2145 |         graph_payload = payload.get("graph_receipt")
2146 |         if isinstance(graph_payload, Mapping):
     |                                              ^
2147 |             self.graph_receipt = GraphWriteReceipt(
2148 |                 nodes_written=int(graph_payload.get("nodes_written", 0)),
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2153:9
     |
2151 |                 metadata=dict(graph_payload.get("metadata", {})),
2152 |             )
2153 |         else:
     |         ^^^^
2154 |             self.graph_receipt = None
2155 |         self.metadata = copy.deepcopy(payload.get("metadata", {}))
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2153:13
     |
2151 |                 metadata=dict(graph_payload.get("metadata", {})),
2152 |             )
2153 |         else:
     |             ^
2154 |             self.graph_receipt = None
2155 |         self.metadata = copy.deepcopy(payload.get("metadata", {}))
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2155:9
     |
2153 |         else:
2154 |             self.graph_receipt = None
2155 |         self.metadata = copy.deepcopy(payload.get("metadata", {}))
     |         ^^^^
2156 |         pdf_payload = payload.get("pdf_gate") or payload.get("pdf")
2157 |         if isinstance(pdf_payload, Mapping):
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2156:9
     |
2154 |             self.graph_receipt = None
2155 |         self.metadata = copy.deepcopy(payload.get("metadata", {}))
2156 |         pdf_payload = payload.get("pdf_gate") or payload.get("pdf")
     |         ^^^^^^^^^^^
2157 |         if isinstance(pdf_payload, Mapping):
2158 |             self.pdf_gate = PdfGateState(
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2157:44
     |
2155 |         self.metadata = copy.deepcopy(payload.get("metadata", {}))
2156 |         pdf_payload = payload.get("pdf_gate") or payload.get("pdf")
2157 |         if isinstance(pdf_payload, Mapping):
     |                                            ^
2158 |             self.pdf_gate = PdfGateState(
2159 |                 downloaded=bool(pdf_payload.get("downloaded", False)),
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2163:9
     |
2161 |                 metadata=dict(pdf_payload.get("metadata", {})),
2162 |             )
2163 |         else:
     |         ^^^^
2164 |             self.pdf_gate = PdfGateState()
2165 |         pdf_payload = payload.get("pdf_assets")
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2163:13
     |
2161 |                 metadata=dict(pdf_payload.get("metadata", {})),
2162 |             )
2163 |         else:
     |             ^
2164 |             self.pdf_gate = PdfGateState()
2165 |         pdf_payload = payload.get("pdf_assets")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2165:9
     |
2163 |         else:
2164 |             self.pdf_gate = PdfGateState()
2165 |         pdf_payload = payload.get("pdf_assets")
     |         ^^^^^^^^^^^
2166 |         if isinstance(pdf_payload, Sequence):
2167 |             self.set_pdf_assets(pdf_payload)
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2166:45
     |
2164 |             self.pdf_gate = PdfGateState()
2165 |         pdf_payload = payload.get("pdf_assets")
2166 |         if isinstance(pdf_payload, Sequence):
     |                                             ^
2167 |             self.set_pdf_assets(pdf_payload)
2168 |         else:
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2168:9
     |
2166 |         if isinstance(pdf_payload, Sequence):
2167 |             self.set_pdf_assets(pdf_payload)
2168 |         else:
     |         ^^^^
2169 |             self.pdf_assets = ()
2170 |         gate_payload = payload.get("gate_status")
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2168:13
     |
2166 |         if isinstance(pdf_payload, Sequence):
2167 |             self.set_pdf_assets(pdf_payload)
2168 |         else:
     |             ^
2169 |             self.pdf_assets = ()
2170 |         gate_payload = payload.get("gate_status")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2170:9
     |
2168 |         else:
2169 |             self.pdf_assets = ()
2170 |         gate_payload = payload.get("gate_status")
     |         ^^^^^^^^^^^^
2171 |         if isinstance(gate_payload, Mapping):
2172 |             self.gate_status = {str(name): bool(value) for name, value in gate_payload.items()}
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2171:45
     |
2169 |             self.pdf_assets = ()
2170 |         gate_payload = payload.get("gate_status")
2171 |         if isinstance(gate_payload, Mapping):
     |                                             ^
2172 |             self.gate_status = {str(name): bool(value) for name, value in gate_payload.items()}
2173 |         else:
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2173:9
     |
2171 |         if isinstance(gate_payload, Mapping):
2172 |             self.gate_status = {str(name): bool(value) for name, value in gate_payload.items()}
2173 |         else:
     |         ^^^^
2174 |             self.gate_status = {}
2175 |         self.metadata.setdefault("gates", {})
     |

invalid-syntax: Expected a statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2173:13
     |
2171 |         if isinstance(gate_payload, Mapping):
2172 |             self.gate_status = {str(name): bool(value) for name, value in gate_payload.items()}
2173 |         else:
     |             ^
2174 |             self.gate_status = {}
2175 |         self.metadata.setdefault("gates", {})
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2175:9
     |
2173 |         else:
2174 |             self.gate_status = {}
2175 |         self.metadata.setdefault("gates", {})
     |         ^^^^
2176 |         for name, ready in self.gate_status.items():
2177 |             self.metadata["gates"][name] = {"ready": ready, "timestamp": time.time()}
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2176:9
     |
2174 |             self.gate_status = {}
2175 |         self.metadata.setdefault("gates", {})
2176 |         for name, ready in self.gate_status.items():
     |         ^^^
2177 |             self.metadata["gates"][name] = {"ready": ready, "timestamp": time.time()}
2178 |         stage_payload = payload.get("stage_results")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2178:9
     |
2176 |         for name, ready in self.gate_status.items():
2177 |             self.metadata["gates"][name] = {"ready": ready, "timestamp": time.time()}
2178 |         stage_payload = payload.get("stage_results")
     |         ^^^^^^^^^^^^^
2179 |         if isinstance(stage_payload, Mapping):
2180 |             self.stage_results = {}
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2179:46
     |
2177 |             self.metadata["gates"][name] = {"ready": ready, "timestamp": time.time()}
2178 |         stage_payload = payload.get("stage_results")
2179 |         if isinstance(stage_payload, Mapping):
     |                                              ^
2180 |             self.stage_results = {}
2181 |             for name, payload_data in stage_payload.items():
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2181:13
     |
2179 |         if isinstance(stage_payload, Mapping):
2180 |             self.stage_results = {}
2181 |             for name, payload_data in stage_payload.items():
     |             ^^^
2182 |                 if isinstance(payload_data, Mapping):
2183 |                     self.stage_results[str(name)] = StageResultSnapshot(
     |

invalid-syntax: Expected a simple statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2182:17
     |
2180 |             self.stage_results = {}
2181 |             for name, payload_data in stage_payload.items():
2182 |                 if isinstance(payload_data, Mapping):
     |                 ^^
2183 |                     self.stage_results[str(name)] = StageResultSnapshot(
2184 |                         stage=str(payload_data.get("stage", name)),
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2191:9
     |
2189 |                         error=payload_data.get("error"),
2190 |                     )
2191 |         self.job_id = payload.get("job_id") or self.context.job_id
     |         ^^^^
2192 |         self.schema_version = str(payload.get("version", self.schema_version))
2193 |         pdf_payload = payload.get("pdf")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2192:9
     |
2190 |                     )
2191 |         self.job_id = payload.get("job_id") or self.context.job_id
2192 |         self.schema_version = str(payload.get("version", self.schema_version))
     |         ^^^^
2193 |         pdf_payload = payload.get("pdf")
2194 |         if isinstance(pdf_payload, Mapping):
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2193:9
     |
2191 |         self.job_id = payload.get("job_id") or self.context.job_id
2192 |         self.schema_version = str(payload.get("version", self.schema_version))
2193 |         pdf_payload = payload.get("pdf")
     |         ^^^^^^^^^^^
2194 |         if isinstance(pdf_payload, Mapping):
2195 |             self.pdf_tracker.downloads = tuple(str(item) for item in pdf_payload.get("downloads", ()))
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2194:44
     |
2192 |         self.schema_version = str(payload.get("version", self.schema_version))
2193 |         pdf_payload = payload.get("pdf")
2194 |         if isinstance(pdf_payload, Mapping):
     |                                            ^
2195 |             self.pdf_tracker.downloads = tuple(str(item) for item in pdf_payload.get("downloads", ()))
2196 |             self.pdf_tracker.last_attempt_ms = pdf_payload.get("last_attempt_ms")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2196:13
     |
2194 |         if isinstance(pdf_payload, Mapping):
2195 |             self.pdf_tracker.downloads = tuple(str(item) for item in pdf_payload.get("downloads", ()))
2196 |             self.pdf_tracker.last_attempt_ms = pdf_payload.get("last_attempt_ms")
     |             ^^^^
2197 |             self.pdf_tracker.gate_open = bool(pdf_payload.get("gate_open", False))
2198 |             self.pdf_tracker.gate_reason = pdf_payload.get("gate_reason")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2197:13
     |
2195 |             self.pdf_tracker.downloads = tuple(str(item) for item in pdf_payload.get("downloads", ()))
2196 |             self.pdf_tracker.last_attempt_ms = pdf_payload.get("last_attempt_ms")
2197 |             self.pdf_tracker.gate_open = bool(pdf_payload.get("gate_open", False))
     |             ^^^^
2198 |             self.pdf_tracker.gate_reason = pdf_payload.get("gate_reason")
2199 |             self.pdf_tracker.ledger_reference = pdf_payload.get("ledger_reference")
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2198:13
     |
2196 |             self.pdf_tracker.last_attempt_ms = pdf_payload.get("last_attempt_ms")
2197 |             self.pdf_tracker.gate_open = bool(pdf_payload.get("gate_open", False))
2198 |             self.pdf_tracker.gate_reason = pdf_payload.get("gate_reason")
     |             ^^^^
2199 |             self.pdf_tracker.ledger_reference = pdf_payload.get("ledger_reference")
2200 |         self._dirty = True
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2199:13
     |
2197 |             self.pdf_tracker.gate_open = bool(pdf_payload.get("gate_open", False))
2198 |             self.pdf_tracker.gate_reason = pdf_payload.get("gate_reason")
2199 |             self.pdf_tracker.ledger_reference = pdf_payload.get("ledger_reference")
     |             ^^^^
2200 |         self._dirty = True
2201 |         self._cache = _StateCache()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2200:9
     |
2198 |             self.pdf_tracker.gate_reason = pdf_payload.get("gate_reason")
2199 |             self.pdf_tracker.ledger_reference = pdf_payload.get("ledger_reference")
2200 |         self._dirty = True
     |         ^^^^
2201 |         self._cache = _StateCache()
2202 |         self.clear_checkpoints()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2201:9
     |
2199 |             self.pdf_tracker.ledger_reference = pdf_payload.get("ledger_reference")
2200 |         self._dirty = True
2201 |         self._cache = _StateCache()
     |         ^^^^
2202 |         self.clear_checkpoints()
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2202:9
     |
2200 |         self._dirty = True
2201 |         self._cache = _StateCache()
2202 |         self.clear_checkpoints()
     |         ^^^^
2203 |
2204 |     @classmethod
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2205:5
     |
2204 |     @classmethod
2205 |     def from_legacy(
     |     ^^^
2206 |         cls,
2207 |         payload: Mapping[str, Any],
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2214:9
     |
2212 |         """Rehydrate a typed state from a legacy dictionary payload."""
2213 |
2214 |         state = cls.initialise(
     |         ^^^^^
2215 |             context=context,
2216 |             adapter_request=adapter_request,
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2219:9
     |
2217 |             payload=payload.get("payload"),
2218 |         )
2219 |         state.hydrate_legacy(payload)
     |         ^^^^^
2220 |         return state
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2220:9
     |
2218 |         )
2219 |         state.hydrate_legacy(payload)
2220 |         return state
     |         ^^^^^^
2221 |
2222 |     # ------------------------------------------------------------------
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2226:5
     |
2224 |     # ------------------------------------------------------------------
2225 |     @classmethod
2226 |     def register_validator(
     |     ^^^
2227 |         cls,
2228 |         validator: Callable[["PipelineState"], None],
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2235:5
     |
2234 |     @classmethod
2235 |     def clear_validators(cls) -> None:
     |     ^^^
2236 |         cls._VALIDATORS.clear()
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2238:5
     |
2236 |         cls._VALIDATORS.clear()
2237 |
2238 |     def validate(
     |     ^^^
2239 |         self,
2240 |         *,
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2245:9
     |
2243 |         """Run registered validators against the state."""
2244 |
2245 |         for name, validator in self._VALIDATORS:
     |         ^^^
2246 |             try:
2247 |                 validator(self)
     |

invalid-syntax: Expected a simple statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2246:13
     |
2245 |         for name, validator in self._VALIDATORS:
2246 |             try:
     |             ^^^
2247 |                 validator(self)
2248 |             except Exception as exc:  # pragma: no cover - defensive guard
     |

invalid-syntax: Expected newline, found 'except'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2248:13
     |
2246 |             try:
2247 |                 validator(self)
2248 |             except Exception as exc:  # pragma: no cover - defensive guard
     |             ^^^^^^
2249 |                 raise PipelineStateValidationError(str(exc), rule=name) from exc
2250 |         if extra_rules:
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2250:23
     |
2248 |             except Exception as exc:  # pragma: no cover - defensive guard
2249 |                 raise PipelineStateValidationError(str(exc), rule=name) from exc
2250 |         if extra_rules:
     |                       ^
2251 |             for rule in extra_rules:
2252 |                 try:
     |

invalid-syntax: Expected a simple statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2252:17
     |
2250 |         if extra_rules:
2251 |             for rule in extra_rules:
2252 |                 try:
     |                 ^^^
2253 |                     rule(self)
2254 |                 except Exception as exc:  # pragma: no cover - defensive guard
     |

invalid-syntax: Expected newline, found 'except'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2254:17
     |
2252 |                 try:
2253 |                     rule(self)
2254 |                 except Exception as exc:  # pragma: no cover - defensive guard
     |                 ^^^^^^
2255 |                     raise PipelineStateValidationError(str(exc)) from exc
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2257:5
     |
2255 |                     raise PipelineStateValidationError(str(exc)) from exc
2256 |
2257 |     def validate_transition(self, stage_type: str) -> None:
     |     ^^^
2258 |         """Ensure the state is ready for the requested stage transition."""
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2260:9
     |
2258 |         """Ensure the state is ready for the requested stage transition."""
2259 |
2260 |         for dependency, satisfied in self._dependency_status(stage_type).items():
     |         ^^^
2261 |             if not satisfied:
2262 |                 _STATE_DEPENDENCY_FAILURES.labels(stage_type=stage_type).inc()
     |

invalid-syntax: Expected a simple statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2261:13
     |
2260 |         for dependency, satisfied in self._dependency_status(stage_type).items():
2261 |             if not satisfied:
     |             ^^
2262 |                 _STATE_DEPENDENCY_FAILURES.labels(stage_type=stage_type).inc()
2263 |                 raise PipelineStateValidationError(
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2263:17
     |
2261 |             if not satisfied:
2262 |                 _STATE_DEPENDENCY_FAILURES.labels(stage_type=stage_type).inc()
2263 |                 raise PipelineStateValidationError(
     |                 ^^^^^
2264 |                     f"Stage '{stage_type}' requires '{dependency}' to complete before execution"
2265 |                 )
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2266:9
     |
2264 |                     f"Stage '{stage_type}' requires '{dependency}' to complete before execution"
2265 |                 )
2266 |         try:
     |         ^^^
2267 |             self.ensure_ready_for(stage_type)
2268 |         except ValueError as exc:
     |

invalid-syntax: Expected newline, found 'except'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2268:9
     |
2266 |         try:
2267 |             self.ensure_ready_for(stage_type)
2268 |         except ValueError as exc:
     |         ^^^^^^
2269 |             raise PipelineStateValidationError(
2270 |                 f"State missing prerequisites for stage '{stage_type}': {exc}"
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2273:5
     |
2271 |             ) from exc
2272 |
2273 |     def _dependency_status(self, stage_type: str) -> dict[str, bool]:
     |     ^^^
2274 |         requirements = self._DEPENDENCIES.get(stage_type, ())
2275 |         if not requirements:
     |

invalid-syntax: Expected 'else', found ':'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2275:28
     |
2273 |     def _dependency_status(self, stage_type: str) -> dict[str, bool]:
2274 |         requirements = self._DEPENDENCIES.get(stage_type, ())
2275 |         if not requirements:
     |                            ^
2276 |             return {}
2277 |         statuses: dict[str, bool] = {}
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2277:9
     |
2275 |         if not requirements:
2276 |             return {}
2277 |         statuses: dict[str, bool] = {}
     |         ^^^^^^^^
2278 |         known_stage_types = {result.stage_type for result in self.stage_results.values()}
2279 |         for requirement in requirements:
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2278:9
     |
2276 |             return {}
2277 |         statuses: dict[str, bool] = {}
2278 |         known_stage_types = {result.stage_type for result in self.stage_results.values()}
     |         ^^^^^^^^^^^^^^^^^
2279 |         for requirement in requirements:
2280 |             if requirement == "ingest":
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2279:9
     |
2277 |         statuses: dict[str, bool] = {}
2278 |         known_stage_types = {result.stage_type for result in self.stage_results.values()}
2279 |         for requirement in requirements:
     |         ^^^
2280 |             if requirement == "ingest":
2281 |                 statuses[requirement] = bool(self.payloads)
     |

invalid-syntax: Expected a simple statement
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2280:13
     |
2278 |         known_stage_types = {result.stage_type for result in self.stage_results.values()}
2279 |         for requirement in requirements:
2280 |             if requirement == "ingest":
     |             ^^
2281 |                 statuses[requirement] = bool(self.payloads)
2282 |             elif requirement == "parse":
     |

invalid-syntax: Expected newline, found 'elif'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2282:13
     |
2280 |             if requirement == "ingest":
2281 |                 statuses[requirement] = bool(self.payloads)
2282 |             elif requirement == "parse":
     |             ^^^^
2283 |                 statuses[requirement] = self.document is not None
2284 |             elif requirement == "chunk":
     |

invalid-syntax: Expected newline, found 'elif'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2284:13
     |
2282 |             elif requirement == "parse":
2283 |                 statuses[requirement] = self.document is not None
2284 |             elif requirement == "chunk":
     |             ^^^^
2285 |                 statuses[requirement] = bool(self.chunks)
2286 |             elif requirement == "embed":
     |

invalid-syntax: Expected newline, found 'elif'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2286:13
     |
2284 |             elif requirement == "chunk":
2285 |                 statuses[requirement] = bool(self.chunks)
2286 |             elif requirement == "embed":
     |             ^^^^
2287 |                 statuses[requirement] = self.embedding_batch is not None
2288 |             elif requirement == "extract":
     |

invalid-syntax: Expected newline, found 'elif'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2288:13
     |
2286 |             elif requirement == "embed":
2287 |                 statuses[requirement] = self.embedding_batch is not None
2288 |             elif requirement == "extract":
     |             ^^^^
2289 |                 statuses[requirement] = bool(self.entities or self.claims)
2290 |             elif requirement == "pdf-download":
     |

invalid-syntax: Expected newline, found 'elif'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2290:13
     |
2288 |             elif requirement == "extract":
2289 |                 statuses[requirement] = bool(self.entities or self.claims)
2290 |             elif requirement == "pdf-download":
     |             ^^^^
2291 |                 statuses[requirement] = bool(self.pdf_tracker.downloads)
2292 |             else:
     |

invalid-syntax: Expected newline, found 'else'
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2292:13
     |
2290 |             elif requirement == "pdf-download":
2291 |                 statuses[requirement] = bool(self.pdf_tracker.downloads)
2292 |             else:
     |             ^^^^
2293 |                 statuses[requirement] = requirement in known_stage_types
2294 |         return statuses
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2294:9
     |
2292 |             else:
2293 |                 statuses[requirement] = requirement in known_stage_types
2294 |         return statuses
     |         ^^^^^^
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2298:1
     |
2297 | @runtime_checkable
2298 | class IngestStage(Protocol):
     | ^^^^^
2299 |     """Fetch raw payloads from the configured adapter."""
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2301:5
     |
2299 |     """Fetch raw payloads from the configured adapter."""
2300 |
2301 |     def execute(self, ctx: StageContext, state: PipelineState) -> list[RawPayload]: ...
     |     ^^^
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2305:1
     |
2304 | @runtime_checkable
2305 | class ParseStage(Protocol):
     | ^^^^^
2306 |     """Transform raw payloads into the canonical IR document."""
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2308:5
     |
2306 |     """Transform raw payloads into the canonical IR document."""
2307 |
2308 |     def execute(self, ctx: StageContext, state: PipelineState) -> Document: ...
     |     ^^^
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2312:1
     |
2311 | @runtime_checkable
2312 | class ChunkStage(Protocol):
     | ^^^^^
2313 |     """Split an IR document into retrieval-ready chunks."""
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2315:5
     |
2313 |     """Split an IR document into retrieval-ready chunks."""
2314 |
2315 |     def execute(self, ctx: StageContext, state: PipelineState) -> list[Chunk]: ...
     |     ^^^
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2319:1
     |
2318 | @runtime_checkable
2319 | class EmbedStage(Protocol):
     | ^^^^^
2320 |     """Generate dense and/or sparse embeddings for a batch of chunks."""
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2322:5
     |
2320 |     """Generate dense and/or sparse embeddings for a batch of chunks."""
2321 |
2322 |     def execute(self, ctx: StageContext, state: PipelineState) -> EmbeddingBatch: ...
     |     ^^^
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2326:1
     |
2325 | @runtime_checkable
2326 | class IndexStage(Protocol):
     | ^^^^^
2327 |     """Persist embeddings into the vector and lexical indices."""
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2329:5
     |
2327 |     """Persist embeddings into the vector and lexical indices."""
2328 |
2329 |     def execute(self, ctx: StageContext, state: PipelineState) -> IndexReceipt: ...
     |     ^^^
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2333:1
     |
2332 | @runtime_checkable
2333 | class ExtractStage(Protocol):
     | ^^^^^
2334 |     """Run extraction models over the IR document."""
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2336:5
     |
2334 |     """Run extraction models over the IR document."""
2335 |
2336 |     def execute(self, ctx: StageContext, state: PipelineState) -> tuple[list[Entity], list[Claim]]: ...
     |     ^^^
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2340:1
     |
2339 | @runtime_checkable
2340 | class KGStage(Protocol):
     | ^^^^^
2341 |     """Write extracted entities and claims into the knowledge graph."""
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2343:5
     |
2341 |     """Write extracted entities and claims into the knowledge graph."""
2342 |
2343 |     def execute(self, ctx: StageContext, state: PipelineState) -> GraphWriteReceipt: ...
     |     ^^^
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2347:1
     |
2346 | @runtime_checkable
2347 | class DownloadStage(Protocol):
     | ^^^^^
2348 |     """Download raw assets required for downstream processing."""
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2350:5
     |
2348 |     """Download raw assets required for downstream processing."""
2349 |
2350 |     def execute(self, ctx: StageContext, state: PipelineState) -> list[DownloadArtifact]: ...
     |     ^^^
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2354:1
     |
2353 | @runtime_checkable
2354 | class GateStage(Protocol):
     | ^^^^^
2355 |     """Enforce conditional progression based on external readiness signals."""
     |

invalid-syntax: Compound statements are not allowed on the same line as simple statements
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2357:5
     |
2355 |     """Enforce conditional progression based on external readiness signals."""
2356 |
2357 |     def execute(self, ctx: StageContext, state: PipelineState) -> GateDecision: ...
     |     ^^^
     |

invalid-syntax: Simple statements must be separated by newlines or semicolons
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2360:1
     |
2360 | __all__ = [
     | ^^^^^^^
2361 |     "ChunkStage",
2362 |     "EmbedStage",
     |

invalid-syntax: unexpected EOF while parsing
    --> src/Medical_KG_rev/orchestration/stages/contracts.py:2384:1
     |
2382 |     "StageContext",
2383 | ]
     |  ^
     |

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/orchestration/stages/pdf_download.py:41:9
   |
39 |     """PDF download stage that stores files in S3 and caches metadata in Redis."""
40 |
41 |     def __init__(self, config: PdfDownloadConfig | None = None) -> None:
   |         ^^^^^^^^
42 |         self._config = config or PdfDownloadConfig()
43 |         self._pdf_storage: PdfStorageClient | None = None
   |

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/orchestration/stages/pdf_gate.py:23:9
   |
21 |     """Gate stage that controls PDF pipeline progression based on ledger state."""
22 |
23 |     def __init__(self, gate_name: str = "pdf-ir-gate") -> None:
   |         ^^^^^^^^
24 |         self._gate_name = gate_name
25 |         self._ledger: Any = None
   |

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/orchestration/stages/pdf_gate.py:156:9
    |
154 |     """Simplified gate stage that only checks for PDF downloads."""
155 |
156 |     def __init__(self, gate_name: str = "pdf-gate") -> None:
    |         ^^^^^^^^
157 |         self._gate_name = gate_name
    |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/orchestration/stages/plugin_manager.py:68:9
   |
66 |     resources: Mapping[str, Any]
67 |
68 |     def require(self, key: str) -> Any:
   |         ^^^^^^^
69 |         try:
70 |             return self.resources[key]
   |

D401 First line of docstring should be in imperative mood: "Called once when the plugin is registered."
  --> src/Medical_KG_rev/orchestration/stages/plugin_manager.py:86:9
   |
85 |     def initialise(self, context: StagePluginContext) -> None:
86 |         """Called once when the plugin is registered."""
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
87 |
88 |     def health_check(self, context: StagePluginContext) -> None:
   |

D105 Missing docstring in magic method
   --> src/Medical_KG_rev/orchestration/stages/plugin_manager.py:120:9
    |
118 |     _loaded: bool = field(default=False, init=False)
119 |
120 |     def __attrs_post_init__(self) -> None:
    |         ^^^^^^^^^^^^^^^^^^^
121 |         self._plugin_manager.add_hookspecs(StagePluginSpec)
    |

D202 [*] No blank lines allowed after function docstring (found 1)
   --> src/Medical_KG_rev/orchestration/stages/plugin_manager.py:124:9
    |
123 |     def load_entrypoints(self) -> None:
124 |         """Discover and register plugins declared via entry points."""
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
125 |
126 |         if self._loaded:
    |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
   --> src/Medical_KG_rev/orchestration/stages/plugin_manager.py:142:9
    |
141 |     def register(self, plugin: StagePlugin) -> None:
142 |         """Register a StagePlugin instance and index stage types."""
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
143 |
144 |         metadata = plugin.metadata
    |
help: Remove blank line(s) after function docstring

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/stages/plugin_manager.py:183:9
    |
181 |             STAGE_PLUGIN_HEALTH.labels(plugin=plugin.metadata.name).set(1)
182 |
183 |     def available_stage_types(self) -> list[str]:
    |         ^^^^^^^^^^^^^^^^^^^^^
184 |         return sorted(self._stage_index)
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/stages/plugin_manager.py:186:9
    |
184 |         return sorted(self._stage_index)
185 |
186 |     def iter_plugins(self) -> Iterable[StagePlugin]:
    |         ^^^^^^^^^^^^
187 |         return self._registry.values()
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/stages/plugin_manager.py:189:9
    |
187 |         return self._registry.values()
188 |
189 |     def get(self, name: str) -> StagePlugin | None:
    |         ^^^
190 |         return self._registry.get(name)
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/stages/plugin_manager.py:192:9
    |
190 |         return self._registry.get(name)
191 |
192 |     def shutdown(self) -> None:
    |         ^^^^^^^^
193 |         for plugin in list(self._registry.values()):
194 |             try:
    |

D202 [*] No blank lines allowed after function docstring (found 1)
   --> src/Medical_KG_rev/orchestration/stages/plugin_manager.py:210:9
    |
208 |     )
209 |     def create_stage(self, definition: Any) -> object:
210 |         """Instantiate a stage for the given definition using registered plugins."""
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
211 |
212 |         stage_type = str(getattr(definition, "stage_type", "")).lower()
    |
help: Remove blank line(s) after function docstring

invalid-syntax: Unexpected indentation
   --> src/Medical_KG_rev/orchestration/stages/plugins.py:489:1
    |
487 |         self._states = states
488 |         self._stage_index = {name: state.stage_types for name, state in states.items()}
489 |                 aggregated[entry.metadata.stage_type].append(entry)
    | ^^^^^^^^^^^^^^^^
490 |         self._registry = aggregated
491 |         self._logger.debug(
    |

invalid-syntax: Expected a statement
   --> src/Medical_KG_rev/orchestration/stages/plugins.py:547:1
    |
547 | @define(slots=True)
    | ^
548 | class _StageRegistrationState:
549 |     """Internal bookkeeping for individual stage registrations."""
    |

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/orchestration/stages/plugins/builtin.py:45:9
   |
43 |     """Provides the default ingest→KG stage implementations."""
44 |
45 |     def __init__(self) -> None:
   |         ^^^^^^^^
46 |         super().__init__(
47 |             StagePluginMetadata(
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/orchestration/stages/plugins/builtin.py:68:9
   |
66 |         self._pipeline_resource: HaystackPipelineResource | None = None
67 |
68 |     def initialise(self, context: StagePluginContext) -> None:
   |         ^^^^^^^^^^
69 |         self._adapter_manager = context.require("adapter_manager")
70 |         self._pipeline_resource = context.require("haystack_pipeline")
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/orchestration/stages/plugins/builtin.py:72:9
   |
70 |         self._pipeline_resource = context.require("haystack_pipeline")
71 |
72 |     def health_check(self, context: StagePluginContext) -> None:
   |         ^^^^^^^^^^^^
73 |         if not isinstance(self._adapter_manager, AdapterPluginManager):
74 |             raise RuntimeError("Adapter manager not available for core stage plugin")
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/orchestration/stages/plugins/builtin.py:78:9
   |
76 |             raise RuntimeError("Haystack pipeline resource not available")
77 |
78 |     def create_stage(self, definition: StageDefinition, context: StagePluginContext) -> object:
   |         ^^^^^^^^^^^^
79 |         assert self._adapter_manager is not None
80 |         assert self._pipeline_resource is not None
   |

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/orchestration/stages/plugins/builtin.py:127:9
    |
125 |     """Plugin providing download and gate stages for the pdf-two-phase pipeline."""
126 |
127 |     def __init__(self) -> None:
    |         ^^^^^^^^
128 |         super().__init__(
129 |             StagePluginMetadata(
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/stages/plugins/builtin.py:138:9
    |
136 |         self._ledger: JobLedger | None = None
137 |
138 |     def initialise(self, context: StagePluginContext) -> None:
    |         ^^^^^^^^^^
139 |         self._ledger = context.require("job_ledger")
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/stages/plugins/builtin.py:141:9
    |
139 |         self._ledger = context.require("job_ledger")
140 |
141 |     def health_check(self, context: StagePluginContext) -> None:
    |         ^^^^^^^^^^^^
142 |         if not isinstance(self._ledger, JobLedger):
143 |             raise RuntimeError("Job ledger unavailable for PDF plugin")
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/stages/plugins/builtin.py:145:9
    |
143 |             raise RuntimeError("Job ledger unavailable for PDF plugin")
144 |
145 |     def create_stage(self, definition: StageDefinition, context: StagePluginContext) -> object:
    |         ^^^^^^^^^^^^
146 |         assert self._ledger is not None
147 |         if definition.stage_type == "download":
    |

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/orchestration/state/cache.py:32:9
   |
31 |     def store(self, key: str, snapshot: PipelineStateSnapshot) -> None:
32 |         """Store a snapshot for the provided key."""
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
33 |
34 |         self._entries[key] = snapshot
   |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/orchestration/state/cache.py:41:9
   |
40 |     def get(self, key: str) -> PipelineStateSnapshot | None:
41 |         """Return a cached snapshot if available and not expired."""
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
42 |
43 |         snapshot = self._entries.get(key)
   |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/orchestration/state/cache.py:62:9
   |
61 |     def clear(self) -> None:
62 |         """Evict all cached entries."""
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
63 |
64 |         self._entries.clear()
   |
help: Remove blank line(s) after function docstring

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/orchestration/state/cache.py:94:9
   |
92 |     """Time-based cache used to store serialised pipeline state blobs."""
93 |
94 |     def __init__(self, ttl_seconds: float = 30.0) -> None:
   |         ^^^^^^^^
95 |         if ttl_seconds <= 0:
96 |             raise ValueError("ttl_seconds must be positive")
   |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/state/cache.py:100:9
    |
 98 |         self._entries: dict[str, _CacheEntry] = {}
 99 |
100 |     def set(self, key: str, payload: bytes) -> None:
    |         ^^^
101 |         self._entries[key] = _CacheEntry(payload)
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/state/cache.py:103:9
    |
101 |         self._entries[key] = _CacheEntry(payload)
102 |
103 |     def get(self, key: str) -> bytes | None:
    |         ^^^
104 |         entry = self._entries.get(key)
105 |         if not entry:
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/orchestration/state/cache.py:114:9
    |
112 |         return entry.payload
113 |
114 |     def purge(self) -> None:
    |         ^^^^^
115 |         now = time.time()
116 |         expired = [key for key, entry in self._entries.items() if now - entry.created_at > self._ttl]
    |

D105 Missing docstring in magic method
   --> src/Medical_KG_rev/orchestration/state/cache.py:120:9
    |
118 |             self._entries.pop(key, None)
119 |
120 |     def __len__(self) -> int:  # pragma: no cover - trivial
    |         ^^^^^^^
121 |         return len(self._entries)
    |

D202 [*] No blank lines allowed after function docstring (found 1)
   --> src/Medical_KG_rev/orchestration/state/cache.py:124:9
    |
123 |     def snapshot(self) -> dict[str, Any]:
124 |         """Return diagnostic information about the cache contents."""
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
125 |
126 |         return {
    |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/orchestration/state/metrics.py:33:5
   |
31 |     error: str | None,
32 | ) -> None:
33 |     """Push orchestration metrics into Prometheus registries."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
34 |
35 |     pipeline_label = pipeline or "unknown"
   |
help: Remove blank line(s) after function docstring

D101 Missing docstring in public class
  --> src/Medical_KG_rev/orchestration/state/models.py:10:7
   |
10 | class StageContextModel(BaseModel):
   |       ^^^^^^^^^^^^^^^^^
11 |     model_config = ConfigDict(extra="forbid")
   |

D101 Missing docstring in public class
  --> src/Medical_KG_rev/orchestration/state/models.py:22:7
   |
22 | class StageResultModel(BaseModel):
   |       ^^^^^^^^^^^^^^^^
23 |     model_config = ConfigDict(extra="forbid")
   |

D101 Missing docstring in public class
  --> src/Medical_KG_rev/orchestration/state/persistence.py:15:7
   |
15 | class SupportsMetadataUpdate(Protocol):
   |       ^^^^^^^^^^^^^^^^^^^^^^
16 |     def update_metadata(self, job_id: str, payload: dict[str, Any]) -> None: ...
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/orchestration/state/persistence.py:16:9
   |
15 | class SupportsMetadataUpdate(Protocol):
16 |     def update_metadata(self, job_id: str, payload: dict[str, Any]) -> None: ...
   |         ^^^^^^^^^^^^^^^
   |

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/orchestration/state/persistence.py:26:9
   |
24 |     """Persist pipeline state snapshots to a metadata store with retries."""
25 |
26 |     def __init__(
   |         ^^^^^^^^
27 |         self,
28 |         *,
   |

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/orchestration/state/persistence.py:42:9
   |
41 |     def persist(self, job_id: str, *, stage: str, payload: dict[str, Any]) -> str:
42 |         """Persist the serialised payload and return the encoded snapshot."""
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
43 |
44 |         snapshot = encode_base64(dumps_orjson(payload))
   |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/orchestration/state/persistence.py:74:9
   |
73 |     def persist_state(self, job_id: str, *, stage: str, state: Any) -> str:
74 |         """Helper to persist using a PipelineState instance."""
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
75 |
76 |         payload = getattr(state, "serialise", lambda: state)()
   |
help: Remove blank line(s) after function docstring

D401 First line of docstring should be in imperative mood: "Helper to persist using a PipelineState instance."
  --> src/Medical_KG_rev/orchestration/state/persistence.py:74:9
   |
73 |     def persist_state(self, job_id: str, *, stage: str, state: Any) -> str:
74 |         """Helper to persist using a PipelineState instance."""
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
75 |
76 |         payload = getattr(state, "serialise", lambda: state)()
   |

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/orchestration/state/serialization.py:15:5
   |
14 | def serialise_payload(payload: dict[str, Any]) -> PipelineStateModel:
15 |     """Validate and normalise a PipelineState payload."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
16 |
17 |     return PipelineStateModel.model_validate(payload)
   |
help: Remove blank line(s) after function docstring

D103 Missing docstring in public function
  --> src/Medical_KG_rev/orchestration/state/serialization.py:20:5
   |
20 | def dumps_orjson(payload: dict[str, Any]) -> bytes:
   |     ^^^^^^^^^^^^
21 |     model = serialise_payload(payload)
22 |     return orjson.dumps(model.model_dump(mode="json"))
   |

D103 Missing docstring in public function
  --> src/Medical_KG_rev/orchestration/state/serialization.py:25:5
   |
25 | def dumps_json(payload: dict[str, Any]) -> str:
   |     ^^^^^^^^^^
26 |     return dumps_orjson(payload).decode("utf-8")
   |

D103 Missing docstring in public function
  --> src/Medical_KG_rev/orchestration/state/serialization.py:29:5
   |
29 | def encode_base64(blob: bytes) -> str:
   |     ^^^^^^^^^^^^^
30 |     compressed = zlib.compress(blob)
31 |     return base64.b64encode(compressed).decode("ascii")
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/cache.py:48:9
   |
46 |     """Simple protocol describing cache operations."""
47 |
48 |     def get(self, namespace: str, embedding_id: str) -> EmbeddingRecord | None:
   |         ^^^
49 |         ...
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/cache.py:51:9
   |
49 |         ...
50 |
51 |     def set(self, record: EmbeddingRecord, *, ttl: int | None = None) -> None:
   |         ^^^
52 |         ...
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/cache.py:54:9
   |
52 |         ...
53 |
54 |     def invalidate_namespace(self, namespace: str) -> None:
   |         ^^^^^^^^^^^^^^^^^^^^
55 |         ...
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/cache.py:61:9
   |
59 |     """No-op cache implementation used when Redis is unavailable."""
60 |
61 |     def get(self, namespace: str, embedding_id: str) -> EmbeddingRecord | None:  # noqa: D401 - interface compliance
   |         ^^^
62 |         return None
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/cache.py:64:9
   |
62 |         return None
63 |
64 |     def set(self, record: EmbeddingRecord, *, ttl: int | None = None) -> None:  # noqa: D401 - interface compliance
   |         ^^^
65 |         return None
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/cache.py:67:9
   |
65 |         return None
66 |
67 |     def invalidate_namespace(self, namespace: str) -> None:  # noqa: D401 - interface compliance
   |         ^^^^^^^^^^^^^^^^^^^^
68 |         return None
   |

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/services/embedding/cache.py:74:9
   |
72 |     """In-process cache useful for tests and local development."""
73 |
74 |     def __init__(self) -> None:
   |         ^^^^^^^^
75 |         self._records: dict[tuple[str, str], EmbeddingRecord] = {}
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/cache.py:77:9
   |
75 |         self._records: dict[tuple[str, str], EmbeddingRecord] = {}
76 |
77 |     def get(self, namespace: str, embedding_id: str) -> EmbeddingRecord | None:
   |         ^^^
78 |         return self._records.get((namespace, embedding_id))
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/cache.py:80:9
   |
78 |         return self._records.get((namespace, embedding_id))
79 |
80 |     def set(self, record: EmbeddingRecord, *, ttl: int | None = None) -> None:  # noqa: D401 - TTL unused for in-memory cache
   |         ^^^
81 |         self._records[(record.namespace, record.id)] = record
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/cache.py:83:9
   |
81 |         self._records[(record.namespace, record.id)] = record
82 |
83 |     def invalidate_namespace(self, namespace: str) -> None:
   |         ^^^^^^^^^^^^^^^^^^^^
84 |         keys_to_delete = [key for key in self._records if key[0] == namespace]
85 |         for key in keys_to_delete:
   |

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/services/embedding/cache.py:92:9
   |
90 |     """Redis-backed cache compatible with the embedding worker."""
91 |
92 |     def __init__(self, *, url: str = "redis://localhost:6379/0", prefix: str = "embedding") -> None:
   |         ^^^^^^^^
93 |         if redis is None:  # pragma: no cover - exercised only when redis missing
94 |             raise RuntimeError("redis dependency is not installed")
   |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/cache.py:101:9
    |
 99 |         return f"{self._prefix}:{namespace}:{embedding_id}"
100 |
101 |     def get(self, namespace: str, embedding_id: str) -> EmbeddingRecord | None:
    |         ^^^
102 |         payload = self._client.get(self._key(namespace, embedding_id))
103 |         if not payload:
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/cache.py:107:9
    |
105 |         return _deserialize(payload.decode("utf-8"))
106 |
107 |     def set(self, record: EmbeddingRecord, *, ttl: int | None = None) -> None:
    |         ^^^
108 |         payload = _serialize(record)
109 |         key = self._key(record.namespace, record.id)
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/cache.py:115:9
    |
113 |             self._client.set(key, payload)
114 |
115 |     def invalidate_namespace(self, namespace: str) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^
116 |         pattern = f"{self._prefix}:{namespace}:*"
117 |         keys = list(self._client.scan_iter(pattern))
    |

D105 Missing docstring in magic method
  --> src/Medical_KG_rev/services/embedding/events.py:72:9
   |
70 |     topic: str = "embedding.events.v1"
71 |
72 |     def __post_init__(self) -> None:
   |         ^^^^^^^^^^^^^
73 |         self.kafka.create_topics([self.topic])
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/events.py:75:9
   |
73 |         self.kafka.create_topics([self.topic])
74 |
75 |     def emit_started(
   |         ^^^^^^^^^^^^
76 |         self,
77 |         *,
   |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/events.py:105:9
    |
103 |         return event
104 |
105 |     def emit_completed(
    |         ^^^^^^^^^^^^^^
106 |         self,
107 |         *,
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/events.py:141:9
    |
139 |         return event
140 |
141 |     def emit_failed(
    |         ^^^^^^^^^^^
142 |         self,
143 |         *,
    |

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/services/embedding/namespace/access.py:28:5
   |
26 |     required_scope: str,
27 | ) -> NamespaceAccessResult:
28 |     """Validate whether a tenant with a scope may access a namespace."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
29 |
30 |     try:
   |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/services/embedding/namespace/loader.py:54:5
   |
52 |     fallback_config: EmbeddingsConfiguration | None = None,
53 | ) -> dict[str, NamespaceConfig]:
54 |     """Load namespace configurations from YAML files or configuration fallback."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
55 |
56 |     namespace_dir = directory or Path(os.environ.get("MK_EMBEDDING_NAMESPACE_DIR", DEFAULT_NAMESPACE_DIR))
   |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/services/embedding/namespace/loader.py:88:5
   |
86 |     fallback_config: EmbeddingsConfiguration | None = None,
87 | ) -> EmbeddingNamespaceRegistry:
88 |     """Load namespaces into a runtime registry instance."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
89 |
90 |     registry = EmbeddingNamespaceRegistry()
   |
help: Remove blank line(s) after function docstring

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/namespace/registry.py:22:9
   |
20 |     _tokenizers: dict[str, object] = field(default_factory=dict, init=False, repr=False)
21 |
22 |     def register(self, namespace: str, config: NamespaceConfig) -> None:
   |         ^^^^^^^^
23 |         self._namespaces[namespace] = config
24 |         self._tokenizers.pop(namespace, None)
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/namespace/registry.py:26:9
   |
24 |         self._tokenizers.pop(namespace, None)
25 |
26 |     def bulk_register(self, configs: Mapping[str, NamespaceConfig]) -> None:
   |         ^^^^^^^^^^^^^
27 |         for namespace, config in configs.items():
28 |             self.register(namespace, config)
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/namespace/registry.py:30:9
   |
28 |             self.register(namespace, config)
29 |
30 |     def reset(self) -> None:
   |         ^^^^^
31 |         self._namespaces.clear()
32 |         self._tokenizers.clear()
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/namespace/registry.py:34:9
   |
32 |         self._tokenizers.clear()
33 |
34 |     def get(self, namespace: str) -> NamespaceConfig:
   |         ^^^
35 |         try:
36 |             return self._namespaces[namespace]
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/namespace/registry.py:43:9
   |
41 |             ) from exc
42 |
43 |     def list_namespaces(self) -> list[str]:
   |         ^^^^^^^^^^^^^^^
44 |         return sorted(self._namespaces)
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/namespace/registry.py:46:9
   |
44 |         return sorted(self._namespaces)
45 |
46 |     def list_by_kind(self, kind: EmbeddingKind) -> list[str]:
   |         ^^^^^^^^^^^^
47 |         return sorted(namespace for namespace, config in self._namespaces.items() if config.kind == kind)
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/namespace/registry.py:49:9
   |
47 |         return sorted(namespace for namespace, config in self._namespaces.items() if config.kind == kind)
48 |
49 |     def exists(self, namespace: str, *, include_disabled: bool = False) -> bool:
   |         ^^^^^^
50 |         config = self._namespaces.get(namespace)
51 |         if not config:
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/namespace/registry.py:55:9
   |
53 |         return bool(config.enabled or include_disabled)
54 |
55 |     def list_enabled(
   |         ^^^^^^^^^^^^
56 |         self,
57 |         *,
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/namespace/registry.py:73:9
   |
71 |         return sorted(configs, key=lambda item: item[0])
72 |
73 |     def get_provider(self, namespace: str) -> str:
   |         ^^^^^^^^^^^^
74 |         return self.get(namespace).provider
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/namespace/registry.py:76:9
   |
74 |         return self.get(namespace).provider
75 |
76 |     def get_dimension(self, namespace: str) -> int | None:
   |         ^^^^^^^^^^^^^
77 |         return self.get(namespace).dim
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/namespace/registry.py:79:9
   |
77 |         return self.get(namespace).dim
78 |
79 |     def get_max_tokens(self, namespace: str) -> int | None:
   |         ^^^^^^^^^^^^^^
80 |         return self.get(namespace).max_tokens
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/namespace/registry.py:82:9
   |
80 |         return self.get(namespace).max_tokens
81 |
82 |     def get_allowed_scopes(self, namespace: str) -> list[str]:
   |         ^^^^^^^^^^^^^^^^^^
83 |         return list(self.get(namespace).allowed_scopes)
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/namespace/registry.py:85:9
   |
83 |         return list(self.get(namespace).allowed_scopes)
84 |
85 |     def get_allowed_tenants(self, namespace: str) -> list[str]:
   |         ^^^^^^^^^^^^^^^^^^^
86 |         return list(self.get(namespace).allowed_tenants)
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/namespace/registry.py:88:9
   |
86 |         return list(self.get(namespace).allowed_tenants)
87 |
88 |     def get_tokenizer(self, namespace: str):  # pragma: no cover - exercised via validation tests
   |         ^^^^^^^^^^^^^
89 |         if namespace in self._tokenizers:
90 |             return self._tokenizers[namespace]
   |

D105 Missing docstring in magic method
   --> src/Medical_KG_rev/services/embedding/namespace/registry.py:107:9
    |
105 |         return tokenizer
106 |
107 |     def __contains__(self, namespace: str) -> bool:  # pragma: no cover - convenience
    |         ^^^^^^^^^^^^
108 |         return namespace in self._namespaces
    |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/namespace/schema.py:27:9
   |
26 |     @classmethod
27 |     def from_adapter(cls, value: AdapterEmbeddingKind) -> "EmbeddingKind":
   |         ^^^^^^^^^^^^
28 |         return cls(value)  # type: ignore[arg-type]
   |

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/services/embedding/namespace/schema.py:57:13
   |
56 |         def to_embedder_config(self, namespace: str) -> EmbedderConfig:
57 |             """Convert the namespace definition into an embedder adapter config."""
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
58 |
59 |             param_map = dict(self.parameters)
   |
help: Remove blank line(s) after function docstring

D101 Missing docstring in public class
  --> src/Medical_KG_rev/services/embedding/namespace/schema.py:77:11
   |
75 |             )
76 |
77 |     class NamespaceConfigFile(BaseModel):
   |           ^^^^^^^^^^^^^^^^^^^
78 |         namespaces: dict[str, NamespaceConfig] = Field(default_factory=dict)
   |

D105 Missing docstring in magic method
   --> src/Medical_KG_rev/services/embedding/namespace/schema.py:104:13
    |
102 |         allowed_tenants: list[str] = field(default_factory=lambda: ["all"])
103 |
104 |         def __post_init__(self) -> None:
    |             ^^^^^^^^^^^^^
105 |             value = self.kind.value if isinstance(self.kind, EmbeddingKind) else str(self.kind)
106 |             object.__setattr__(self, "kind", EmbeddingKind(value))
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/namespace/schema.py:109:13
    |
107 |             object.__setattr__(self, "parameters", dict(self.parameters))
108 |
109 |         def to_embedder_config(self, namespace: str) -> EmbedderConfig:
    |             ^^^^^^^^^^^^^^^^^^
110 |             param_map = dict(self.parameters)
111 |             if self.endpoint and "endpoint" not in param_map:
    |

D101 Missing docstring in public class
   --> src/Medical_KG_rev/services/embedding/namespace/schema.py:129:11
    |
128 |     @dataclass(slots=True)
129 |     class NamespaceConfigFile:  # type: ignore[no-redef]
    |           ^^^^^^^^^^^^^^^^^^^
130 |         namespaces: dict[str, NamespaceConfig] = field(default_factory=dict)
    |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/persister.py:43:9
   |
41 |     duration_ms: float = 0.0
42 |
43 |     def record_error(self, message: str) -> None:
   |         ^^^^^^^^^^^^
44 |         self.errors.append(message)
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/persister.py:56:9
   |
55 |     @classmethod
56 |     def from_mapping(cls, payload: Mapping[str, Any] | None) -> "PersisterRuntimeSettings":
   |         ^^^^^^^^^^^^
57 |         if not payload:
58 |             return cls()
   |

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/services/embedding/persister.py:73:9
   |
71 |     """Abstract base class describing the persister contract."""
72 |
73 |     def __init__(self, *, telemetry: EmbeddingTelemetry | None = None) -> None:
   |         ^^^^^^^^
74 |         self._telemetry = telemetry
75 |         self._logger = logger.bind(persister=self.__class__.__name__)
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/persister.py:84:9
   |
82 |         """Persist records to the backing store."""
83 |
84 |     def persist_batch(self, records: Sequence[EmbeddingRecord], context: PersistenceContext) -> PersistenceReport:
   |         ^^^^^^^^^^^^^
85 |         report = PersistenceReport()
86 |         started = perf_counter()
   |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/persister.py:109:9
    |
107 |             self._cache.pop(evicted, None)
108 |
109 |     def retrieve(self, *, ids: Sequence[str] | None = None) -> list[EmbeddingRecord]:
    |         ^^^^^^^^
110 |         if ids is None:
111 |             return list(self._cache.values())
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/persister.py:114:9
    |
112 |         return [self._cache[item] for item in ids if item in self._cache]
113 |
114 |     def delete(self, *, ids: Sequence[str]) -> int:
    |         ^^^^^^
115 |         removed = 0
116 |         for item_id in ids:
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/persister.py:121:9
    |
119 |         return removed
120 |
121 |     def search(self, *, metadata: Mapping[str, object] | None = None) -> list[EmbeddingRecord]:
    |         ^^^^^^
122 |         if not metadata:
123 |             return list(self._cache.values())
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/persister.py:130:9
    |
128 |         return results
129 |
130 |     def debug_snapshot(self) -> Mapping[str, object]:
    |         ^^^^^^^^^^^^^^
131 |         return {
132 |             "cached_records": len(self._cache),
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/persister.py:136:9
    |
134 |         }
135 |
136 |     def health_status(self) -> Mapping[str, object]:
    |         ^^^^^^^^^^^^^
137 |         return {
138 |             "persister": self.__class__.__name__,
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/persister.py:142:9
    |
140 |         }
141 |
142 |     def configure(self, **kwargs: object) -> None:
    |         ^^^^^^^^^
143 |         if "cache_limit" in kwargs:
144 |             limit = int(kwargs["cache_limit"])
    |

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/services/embedding/persister.py:158:9
    |
156 |     """Persister that writes embeddings via the shared storage router."""
157 |
158 |     def __init__(
    |         ^^^^^^^^
159 |         self,
160 |         storage_router: StorageRouter,
    |

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/services/embedding/persister.py:177:9
    |
175 |     """Persister that stores embeddings in an in-memory map for Neo4j compatibility."""
176 |
177 |     def __init__(self, *, telemetry: EmbeddingTelemetry | None = None) -> None:
    |         ^^^^^^^^
178 |         super().__init__(telemetry=telemetry)
179 |         self._store: Dict[str, EmbeddingRecord] = {}
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/persister.py:187:9
    |
185 |             report.persisted += 1
186 |
187 |     def retrieve(self, *, ids: Sequence[str] | None = None) -> list[EmbeddingRecord]:
    |         ^^^^^^^^
188 |         if ids is None:
189 |             return list(self._store.values())
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/persister.py:192:9
    |
190 |         return [self._store[item] for item in ids if item in self._store]
191 |
192 |     def delete(self, *, ids: Sequence[str]) -> int:
    |         ^^^^^^
193 |         removed = 0
194 |         for item_id in ids:
    |

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/services/embedding/persister.py:204:9
    |
202 |     """Persister that records operations without writing to storage."""
203 |
204 |     def __init__(self, *, telemetry: EmbeddingTelemetry | None = None) -> None:
    |         ^^^^^^^^
205 |         super().__init__(telemetry=telemetry)
206 |         self._operations: list[PersistenceContext] = []
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/persister.py:213:9
    |
212 |     @property
213 |     def operations(self) -> Sequence[PersistenceContext]:
    |         ^^^^^^^^^^
214 |         return tuple(self._operations)
    |

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/services/embedding/persister.py:220:9
    |
218 |     """Lightweight persister for unit tests."""
219 |
220 |     def __init__(self) -> None:
    |         ^^^^^^^^
221 |         super().__init__()
222 |         self.persisted_records: list[EmbeddingRecord] = []
    |

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/services/embedding/persister.py:234:9
    |
232 |     """Persister that delegates to other persisters based on embedding kind."""
233 |
234 |     def __init__(
    |         ^^^^^^^^
235 |         self,
236 |         persisters: Mapping[str, EmbeddingPersister],
    |

D202 [*] No blank lines allowed after function docstring (found 1)
   --> src/Medical_KG_rev/services/embedding/persister.py:282:5
    |
280 |     settings: PersisterRuntimeSettings | Mapping[str, Any] | None = None,
281 | ) -> EmbeddingPersister:
282 |     """Instantiate a persister based on runtime configuration."""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
283 |
284 |     resolved = (
    |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/services/embedding/policy.py:39:9
   |
38 |     def denied_due_to_tenant(self) -> bool:
39 |         """Return True if the denial was caused by tenant restrictions."""
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
40 |
41 |         if self.allowed:
   |
help: Remove blank line(s) after function docstring

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/services/embedding/policy.py:65:9
   |
63 |     """Abstract base class for namespace validation and routing policies."""
64 |
65 |     def __init__(
   |         ^^^^^^^^
66 |         self,
67 |         registry: EmbeddingNamespaceRegistry,
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/policy.py:82:9
   |
81 |     @property
82 |     def registry(self) -> EmbeddingNamespaceRegistry:
   |         ^^^^^^^^
83 |         return self._registry
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/policy.py:86:9
   |
85 |     @property
86 |     def settings(self) -> NamespacePolicySettings:
   |         ^^^^^^^^
87 |         return self._settings
   |

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/services/embedding/policy.py:90:9
   |
89 |     def update_settings(self, **kwargs: object) -> None:
90 |         """Hot-update policy configuration."""
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
91 |
92 |         new_values = asdict(self._settings) | kwargs
   |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/services/embedding/policy.py:97:9
   |
96 |     def evaluate(self, *, namespace: str, tenant_id: str, required_scope: str) -> NamespaceAccessDecision:
97 |         """Evaluate access for the supplied namespace/tenant/scope."""
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
98 |
99 |         cache_key = (namespace, tenant_id, required_scope)
   |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
   --> src/Medical_KG_rev/services/embedding/policy.py:127:9
    |
126 |     def invalidate(self, namespace: str | None = None) -> None:
127 |         """Invalidate cached policy decisions."""
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
128 |
129 |         if namespace is None:
    |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
   --> src/Medical_KG_rev/services/embedding/policy.py:137:9
    |
136 |     def health_status(self) -> Mapping[str, object]:
137 |         """Expose health diagnostics for monitoring/alerting."""
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
138 |
139 |         return {
    |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
   --> src/Medical_KG_rev/services/embedding/policy.py:147:9
    |
146 |     def debug_snapshot(self) -> Mapping[str, object]:
147 |         """Return an introspection snapshot useful during debugging."""
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
148 |
149 |         return {
    |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
   --> src/Medical_KG_rev/services/embedding/policy.py:156:9
    |
155 |     def stats(self) -> Mapping[str, object]:
156 |         """Return current policy statistics."""
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
157 |
158 |         return {
    |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
   --> src/Medical_KG_rev/services/embedding/policy.py:169:9
    |
168 |     def operational_metrics(self) -> Mapping[str, object]:
169 |         """Return metrics suitable for operational monitoring."""
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
170 |
171 |         return {
    |
help: Remove blank line(s) after function docstring

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/services/embedding/policy.py:223:9
    |
221 |     """Policy variant that records denials but never blocks callers."""
222 |
223 |     def __init__(
    |         ^^^^^^^^
224 |         self,
225 |         delegate: NamespaceAccessPolicy,
    |

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/services/embedding/policy.py:261:9
    |
259 |     """Testing policy that uses a predefined decision map."""
260 |
261 |     def __init__(
    |         ^^^^^^^^
262 |         self,
263 |         registry: EmbeddingNamespaceRegistry,
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/policy.py:269:9
    |
267 |         self._decisions = dict(decisions or {})
268 |
269 |     def register_decision(
    |         ^^^^^^^^^^^^^^^^^
270 |         self,
271 |         *,
    |

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/services/embedding/policy.py:304:9
    |
302 |     """Policy that delegates to a custom callable for organization rules."""
303 |
304 |     def __init__(
    |         ^^^^^^^^
305 |         self,
306 |         registry: EmbeddingNamespaceRegistry,
    |

D202 [*] No blank lines allowed after function docstring (found 1)
   --> src/Medical_KG_rev/services/embedding/policy.py:335:5
    |
333 |     extra_policies: Iterable[Callable[[NamespaceAccessPolicy], NamespaceAccessPolicy]] | None = None,
334 | ) -> NamespaceAccessPolicy:
335 |     """Build a composed namespace access policy."""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
336 |
337 |     policy: NamespaceAccessPolicy = StandardNamespacePolicy(registry, telemetry=telemetry, settings=settings)
    |
help: Remove blank line(s) after function docstring

D105 Missing docstring in magic method
  --> src/Medical_KG_rev/services/embedding/registry.py:88:9
   |
86 |     )
87 |
88 |     def __post_init__(self) -> None:
   |         ^^^^^^^^^^^^^
89 |         self.namespace_manager = self.namespace_manager or NamespaceManager()
90 |         self.storage_router = self.storage_router or StorageRouter()
   |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/registry.py:146:9
    |
145 |     @property
146 |     def factory(self) -> EmbedderFactory:
    |         ^^^^^^^
147 |         return self._factory
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/registry.py:150:9
    |
149 |     @property
150 |     def registry(self) -> EmbedderRegistry:
    |         ^^^^^^^^
151 |         return self._registry
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/registry.py:154:9
    |
153 |     @property
154 |     def configuration(self) -> EmbeddingsConfiguration:
    |         ^^^^^^^^^^^^^
155 |         return self._config
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/registry.py:157:9
    |
155 |         return self._config
156 |
157 |     def list_configs(self) -> list[EmbedderConfig]:
    |         ^^^^^^^^^^^^
158 |         return list(self._configs_by_namespace.values())
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/registry.py:160:9
    |
158 |         return list(self._configs_by_namespace.values())
159 |
160 |     def active_configs(self) -> list[EmbedderConfig]:
    |         ^^^^^^^^^^^^^^
161 |         actives = [
162 |             self._configs_by_namespace[ns]
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/registry.py:170:9
    |
168 |         return self.list_configs()
169 |
170 |     def resolve(
    |         ^^^^^^^
171 |         self,
172 |         *,
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/registry.py:194:9
    |
192 |         return self.active_configs()
193 |
194 |     def get(self, key: str | EmbedderConfig) -> BaseEmbedder:
    |         ^^^
195 |         config = self._resolve_config(key)
196 |         return self._factory.get(config)
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/registry.py:198:9
    |
196 |         return self._factory.get(config)
197 |
198 |     def config_for(self, key: str) -> EmbedderConfig:
    |         ^^^^^^^^^^
199 |         config = self._resolve_config(key)
200 |         return config
    |

D202 [*] No blank lines allowed after function docstring (found 1)
   --> src/Medical_KG_rev/services/embedding/registry.py:215:9
    |
214 |     def reload(self, *, config_path: str | Path | None = None) -> None:
215 |         """Reload embedding configurations and refresh namespace registrations."""
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
216 |
217 |         if config_path is not None:
    |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
  --> src/Medical_KG_rev/services/embedding/service.py:35:5
   |
34 | def _default_stage_factory() -> StageFactory:
35 |     """Instantiate the default stage factory using registered adapters."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
36 |
37 |     adapter_manager = get_plugin_manager()
   |
help: Remove blank line(s) after function docstring

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/service.py:71:9
   |
70 |     @property
71 |     def dimension(self) -> int:
   |         ^^^^^^^^^
72 |         return len(self.values)
   |

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/services/embedding/service.py:85:9
   |
83 |     """Thin wrapper that executes the embed stage via Dagster components."""
84 |
85 |     def __init__(
   |         ^^^^^^^^
86 |         self,
87 |         registry: EmbeddingModelRegistry | None = None,  # noqa: ARG002 - retained for compatibility
   |

D202 [*] No blank lines allowed after function docstring (found 1)
   --> src/Medical_KG_rev/services/embedding/service.py:103:9
    |
101 |     # ------------------------------------------------------------------
102 |     def run(self, request: EmbeddingRequest) -> EmbeddingResponse:
103 |         """Execute the embed stage for the provided request."""
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
104 |
105 |         cleaned_texts = [
    |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
   --> src/Medical_KG_rev/services/embedding/service.py:149:9
    |
147 |     # ------------------------------------------------------------------
148 |     def encode_queries(self, request: EmbeddingRequest) -> EmbeddingResponse:
149 |         """Alias for :meth:`run` retained for compatibility with rerankers."""
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
150 |
151 |         return self.run(request)
    |
help: Remove blank line(s) after function docstring

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/service.py:245:15
    |
243 |     worker: EmbeddingWorker
244 |
245 |     async def EmbedChunks(self, request, context):  # type: ignore[override]
    |               ^^^^^^^^^^^
246 |         embed_request = EmbeddingRequest(
247 |             tenant_id=request.tenant_id,
    |

D107 Missing docstring in `__init__`
  --> src/Medical_KG_rev/services/embedding/telemetry.py:64:9
   |
62 |     """Abstract base class for telemetry providers."""
63 |
64 |     def __init__(self, settings: TelemetrySettings | None = None) -> None:
   |         ^^^^^^^^
65 |         self._settings = settings or TelemetrySettings()
66 |         self._snapshot = TelemetrySnapshot()
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/telemetry.py:70:9
   |
69 |     @property
70 |     def settings(self) -> TelemetrySettings:
   |         ^^^^^^^^
71 |         return self._settings
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/telemetry.py:73:9
   |
71 |         return self._settings
72 |
73 |     def update_settings(self, **kwargs: object) -> None:
   |         ^^^^^^^^^^^^^^^
74 |         values = asdict(self._settings) | kwargs
75 |         self._settings = TelemetrySettings(**values)
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/telemetry.py:77:9
   |
75 |         self._settings = TelemetrySettings(**values)
76 |
77 |     def snapshot(self) -> TelemetrySnapshot:
   |         ^^^^^^^^
78 |         return TelemetrySnapshot(**asdict(self._snapshot))
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/telemetry.py:83:9
   |
81 |         self._snapshot.last_duration_ms = duration_ms
82 |
83 |     def record_policy_evaluation(self, decision: "NamespaceAccessDecision") -> None:
   |         ^^^^^^^^^^^^^^^^^^^^^^^^
84 |         self._snapshot.policy_evaluations += 1
85 |         self._record_decision("evaluated", decision)
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/telemetry.py:87:9
   |
85 |         self._record_decision("evaluated", decision)
86 |
87 |     def record_policy_denied(self, decision: "NamespaceAccessDecision") -> None:
   |         ^^^^^^^^^^^^^^^^^^^^
88 |         self._snapshot.policy_denials += 1
89 |         self._record_decision("denied", decision)
   |

D102 Missing docstring in public method
  --> src/Medical_KG_rev/services/embedding/telemetry.py:91:9
   |
89 |         self._record_decision("denied", decision)
90 |
91 |     def record_embedding_started(self, *, namespace: str, tenant_id: str, model: str | None = None) -> None:
   |         ^^^^^^^^^^^^^^^^^^^^^^^^
92 |         if self._settings.enable_logging:
93 |             self._logger.info(
   |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/telemetry.py:100:9
    |
 98 |             )
 99 |
100 |     def record_embedding_completed(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
101 |         self,
102 |         *,
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/telemetry.py:127:9
    |
125 |             )
126 |
127 |     def record_embedding_failure(self, *, namespace: str, tenant_id: str, error: Exception) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
128 |         self._snapshot.embedding_failures += 1
129 |         if self._settings.enable_logging:
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/telemetry.py:137:9
    |
135 |             )
136 |
137 |     def record_persistence(
    |         ^^^^^^^^^^^^^^^^^^
138 |         self,
139 |         report: "PersistenceReport",
    |

D107 Missing docstring in `__init__`
   --> src/Medical_KG_rev/services/embedding/telemetry.py:158:9
    |
156 |     """Telemetry implementation backed by Prometheus metrics and structured logs."""
157 |
158 |     def __init__(
    |         ^^^^^^^^
159 |         self,
160 |         settings: TelemetrySettings | None = None,
    |

D102 Missing docstring in public method
   --> src/Medical_KG_rev/services/embedding/telemetry.py:194:9
    |
192 |                 )
193 |
194 |     def operational_metrics(self) -> Mapping[str, object]:
    |         ^^^^^^^^^^^^^^^^^^^
195 |         return {
196 |             "denials_by_namespace": dict(self._denials_by_namespace),
    |

invalid-syntax: Unexpected indentation
   --> src/Medical_KG_rev/services/retrieval/chunking.py:178:1
    |
176 |             strategy=command.strategy,
177 |         )
178 |             metadata=self._context_metadata(chunk_options, command),
    | ^^^^^^^^^^^^
179 |             pipeline_name=self._DEFAULT_PIPELINE,
180 |             pipeline_version=self._DEFAULT_VERSION,
    |

invalid-syntax: Expected a statement
   --> src/Medical_KG_rev/services/retrieval/chunking.py:181:9
    |
179 |             pipeline_name=self._DEFAULT_PIPELINE,
180 |             pipeline_version=self._DEFAULT_VERSION,
181 |         )
    |         ^
182 |         document = self._build_document(command.document_id, command.text, command.metadata)
183 |         logger.bind(**command.log_context()).debug("gateway.chunking.execute")
    |

invalid-syntax: Expected a statement
   --> src/Medical_KG_rev/services/retrieval/chunking.py:181:10
    |
179 |             pipeline_name=self._DEFAULT_PIPELINE,
180 |             pipeline_version=self._DEFAULT_VERSION,
181 |         )
    |          ^
182 |         document = self._build_document(command.document_id, command.text, command.metadata)
183 |         logger.bind(**command.log_context()).debug("gateway.chunking.execute")
    |

invalid-syntax: Expected an indented block after function definition
   --> src/Medical_KG_rev/services/retrieval/chunking.py:211:5
    |
210 |     def _context_metadata(self, options: ChunkingOptions) -> dict[str, Any]:
211 |     def _build_document(self, document_id: str, text: str, metadata: Mapping[str, Any]) -> Document:
    |     ^^^
212 |         paragraphs = [segment.strip() for segment in text.split("\n\n") if segment.strip()]
213 |         if not paragraphs:
    |

invalid-syntax: Expected a statement
   --> src/Medical_KG_rev/services/retrieval/chunking.py:254:1
    |
254 | __all__ = ["Chunk", "ChunkCommand", "ChunkingOptions", "ChunkingService"]
    | ^
    |

Found 1212 errors.
[*] 47 fixable with the `--fix` option.
