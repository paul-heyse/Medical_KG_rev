diff a/src/Medical_KG_rev/orchestration/dagster/configuration.py b/src/Medical_KG_rev/orchestration/dagster/configuration.py	(rejected hunks)
@@ -1,134 +1,183 @@
 """Configuration models and loaders for Dagster-based orchestration."""

 from __future__ import annotations

 import asyncio
 import json
 import threading
 import time
 from collections.abc import Callable, Iterable
 from dataclasses import dataclass
 from enum import Enum
 from pathlib import Path
 from typing import TYPE_CHECKING, Any, Callable, Mapping

 import yaml
 from pydantic import (
+    AliasChoices,
     BaseModel,
     ConfigDict,
     Field,
     PrivateAttr,
     ValidationError,
     field_validator,
     model_validator,
 )

 from Medical_KG_rev.observability.metrics import (
     record_resilience_circuit_state,
     record_resilience_rate_limit_wait,
     record_resilience_retry,
 )
 from Medical_KG_rev.utils.logging import get_logger

 logger = get_logger(__name__)

 if TYPE_CHECKING:  # pragma: no cover - hints only
     from aiolimiter import AsyncLimiter
     from pybreaker import CircuitBreaker


 class BackoffStrategy(str, Enum):
     EXPONENTIAL = "exponential"
     LINEAR = "linear"
     NONE = "none"


 class GateCondition(BaseModel):
     """Predicate evaluated against Job Ledger entries to resume a pipeline."""

     model_config = ConfigDict(extra="forbid")

     field: str = Field(pattern=r"^[A-Za-z0-9_.-]+$")
     equals: Any
     timeout_seconds: int | None = Field(default=None, ge=1, le=3600)
     poll_interval_seconds: float = Field(default=5.0, ge=0.5, le=60.0)


 class GateDefinition(BaseModel):
     """Declarative definition for a pipeline gate."""

     model_config = ConfigDict(extra="forbid")

     name: str = Field(pattern=r"^[A-Za-z0-9_-]+$")
     condition: GateCondition
     resume_stage: str = Field(pattern=r"^[A-Za-z0-9_-]+$")


+class StageMetadataOverrides(BaseModel):
+    """Optional overrides that adjust stage metadata at pipeline scope."""
+
+    model_config = ConfigDict(extra="forbid")
+
+    state_key: str | list[str] | None = None
+    description: str | None = None
+    dependencies: list[str] | None = None
+
+
+class StagePluginImport(BaseModel):
+    """Declarative reference to a stage plugin registration callable."""
+
+    model_config = ConfigDict(extra="forbid")
+
+    target: str = Field(alias="callable", pattern=r"^[A-Za-z0-9_.:]+$")
+    replace: bool = Field(default=False)
+
+    @model_validator(mode="after")
+    def _validate_target(self) -> StagePluginImport:
+        if ":" not in self.target:
+            raise ValueError("stage plugin callable must be in 'module:function' format")
+        module, _, attribute = self.target.partition(":")
+        if not module or not attribute:
+            raise ValueError("stage plugin callable must include module and attribute name")
+        return self
+
+    @property
+    def identifier(self) -> str:
+        return self.target
+
+
+class PipelinePluginConfig(BaseModel):
+    """Plugin declarations scoped to an individual pipeline topology."""
+
+    model_config = ConfigDict(extra="forbid")
+
+    stage_plugins: list[StagePluginImport] = Field(
+        default_factory=list,
+        alias=AliasChoices("stage_plugins", "stages"),
+    )
+
+
 class StageDefinition(BaseModel):
     """Declarative stage specification for topology YAML files."""

     model_config = ConfigDict(extra="forbid", populate_by_name=True)

     name: str = Field(pattern=r"^[A-Za-z0-9_-]+$")
     stage_type: str = Field(alias="type", pattern=r"^[A-Za-z0-9_-]+$")
     policy: str | None = Field(default=None, alias="policy")
     depends_on: list[str] = Field(default_factory=list, alias="depends_on")
     config: dict[str, Any] = Field(default_factory=dict)
+    metadata_overrides: StageMetadataOverrides | None = Field(
+        default=None,
+        alias=AliasChoices("metadata_overrides", "metadata"),
+    )

     @field_validator("depends_on")
     @classmethod
     def _unique_dependencies(cls, value: Iterable[str]) -> list[str]:
         seen: set[str] = set()
         result: list[str] = []
         for item in value:
             if item in seen:
                 raise ValueError(f"duplicate dependency '{item}' declared for stage")
             seen.add(item)
             result.append(item)
         return result


 class PipelineMetadata(BaseModel):
     """Optional metadata about the pipeline."""

     owner: str | None = None
     description: str | None = None
     tags: list[str] = Field(default_factory=list)


 class PipelineTopologyConfig(BaseModel):
     """Complete topology definition for a pipeline."""

     model_config = ConfigDict(extra="forbid")

     name: str = Field(pattern=r"^[A-Za-z0-9_-]+$")
     version: str = Field(pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}(-[A-Za-z0-9]+)?$")
     applicable_sources: list[str] = Field(default_factory=list)
     stages: list[StageDefinition]
     gates: list[GateDefinition] = Field(default_factory=list)
     metadata: PipelineMetadata | None = None
+    plugins: PipelinePluginConfig = Field(default_factory=PipelinePluginConfig)

     @model_validator(mode="after")
     def _validate_dependencies(self) -> PipelineTopologyConfig:
         stage_names = [stage.name for stage in self.stages]
         if len(stage_names) != len(set(stage_names)):
             duplicates = {name for name in stage_names if stage_names.count(name) > 1}
             raise ValueError(f"duplicate stage names detected: {sorted(duplicates)}")

         stage_set = set(stage_names)
         for stage in self.stages:
             missing = [dep for dep in stage.depends_on if dep not in stage_set]
             if missing:
                 raise ValueError(
                     f"stage '{stage.name}' declares unknown dependencies: {', '.join(sorted(missing))}"
                 )

         order = _topological_sort({stage.name: stage.depends_on for stage in self.stages})
         if order is None:
             raise ValueError("cycle detected in pipeline dependencies")

         gate_stage_set = {stage.name for stage in self.stages}
         for gate in self.gates:
             if gate.resume_stage not in gate_stage_set:
                 raise ValueError(
                     f"gate '{gate.name}' references unknown resume_stage '{gate.resume_stage}'"
