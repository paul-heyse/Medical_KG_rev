diff a/src/Medical_KG_rev/orchestration/dagster/stages.py b/src/Medical_KG_rev/orchestration/dagster/stages.py	(rejected hunks)
@@ -1,42 +1,46 @@
 """Default stage implementations and builder helpers for Dagster pipelines."""

 from __future__ import annotations

 import json
 from dataclasses import dataclass
 from typing import Any, Callable, Mapping, Sequence
 from uuid import uuid4

 import structlog

 from Medical_KG_rev.adapters import AdapterPluginError
 from Medical_KG_rev.adapters.plugins.manager import AdapterPluginManager
 from Medical_KG_rev.adapters.plugins.models import AdapterDomain, AdapterRequest
 from Medical_KG_rev.models.entities import Claim, Entity
 from Medical_KG_rev.models.ir import Block, BlockType, Document, Section
-from Medical_KG_rev.orchestration.dagster.configuration import StageDefinition
+from Medical_KG_rev.orchestration.dagster.configuration import (
+    PipelineTopologyConfig,
+    StageDefinition,
+)
+from Medical_KG_rev.orchestration.dagster.gates import GateStage
 from Medical_KG_rev.orchestration.haystack.components import (
     HaystackChunker,
     HaystackEmbedder,
     HaystackIndexWriter,
 )
 from Medical_KG_rev.orchestration.stages.contracts import (
     ChunkStage,
     EmbedStage,
     ExtractStage,
     GraphWriteReceipt,
     IngestStage,
     IndexStage,
     KGStage,
     ParseStage,
     StageContext,
 )
 from Medical_KG_rev.orchestration.stages.contracts import RawPayload

 logger = structlog.get_logger(__name__)


 class AdapterIngestStage(IngestStage):
     """Fetch raw payloads from a configured adapter using the plugin manager."""

     def __init__(
@@ -228,86 +232,97 @@ class NoOpDocumentWriter:
     def run(self, *, documents: Sequence[Any]) -> dict[str, Any]:  # pragma: no cover - trivial
         logger.debug("dagster.index.writer.noop", writer=self._name, documents=len(documents))
         return {"documents": list(documents)}


 @dataclass(slots=True)
 class HaystackPipelineResource:
     splitter: SimpleDocumentSplitter
     embedder: SimpleEmbedder
     dense_writer: NoOpDocumentWriter
     sparse_writer: NoOpDocumentWriter


 def create_default_pipeline_resource() -> HaystackPipelineResource:
     return HaystackPipelineResource(
         splitter=SimpleDocumentSplitter(),
         embedder=SimpleEmbedder(),
         dense_writer=NoOpDocumentWriter(name="faiss"),
         sparse_writer=NoOpDocumentWriter(name="opensearch"),
     )


 def build_default_stage_factory(
     manager: AdapterPluginManager,
     pipeline: HaystackPipelineResource | None = None,
-) -> dict[str, Callable[[StageDefinition], object]]:
+) -> dict[str, Callable[[PipelineTopologyConfig, StageDefinition], object]]:
     """Return builder mappings for standard Dagster stage types."""

     pipeline = pipeline or create_default_pipeline_resource()
     splitter = pipeline.splitter
     embedder = pipeline.embedder
     dense_writer = pipeline.dense_writer
     sparse_writer = pipeline.sparse_writer

-    def _ingest_builder(definition: StageDefinition) -> IngestStage:
+    def _ingest_builder(_: PipelineTopologyConfig, definition: StageDefinition) -> IngestStage:
         config = definition.config
         adapter_name = config.get("adapter")
         if not adapter_name:
             raise ValueError(f"Stage '{definition.name}' requires an adapter name")
         strict = bool(config.get("strict", False))
         domain_value = config.get("domain")
         try:
             domain = AdapterDomain(domain_value) if domain_value else AdapterDomain.BIOMEDICAL
         except Exception as exc:  # pragma: no cover - validation guard
             raise ValueError(f"Invalid adapter domain '{domain_value}'") from exc
         extra_parameters = config.get("parameters", {}) if isinstance(config, Mapping) else {}
         return AdapterIngestStage(
             manager,
             adapter_name=adapter_name,
             strict=strict,
             default_domain=domain,
             extra_parameters=extra_parameters if isinstance(extra_parameters, Mapping) else {},
         )

-    def _parse_builder(_: StageDefinition) -> ParseStage:
+    def _parse_builder(_: PipelineTopologyConfig, __: StageDefinition) -> ParseStage:
         return AdapterParseStage()

-    def _validation_builder(_: StageDefinition) -> ParseStage:
+    def _validation_builder(_: PipelineTopologyConfig, __: StageDefinition) -> ParseStage:
         return IRValidationStage()

-    def _chunk_builder(_: StageDefinition) -> ChunkStage:
+    def _chunk_builder(_: PipelineTopologyConfig, __: StageDefinition) -> ChunkStage:
         return HaystackChunker(splitter, chunker_name="haystack.semantic", granularity="paragraph")

-    def _embed_builder(_: StageDefinition) -> EmbedStage:
+    def _embed_builder(_: PipelineTopologyConfig, __: StageDefinition) -> EmbedStage:
         return HaystackEmbedder(embedder=embedder, require_gpu=False, sparse_expander=None)

-    def _index_builder(_: StageDefinition) -> IndexStage:
+    def _index_builder(_: PipelineTopologyConfig, __: StageDefinition) -> IndexStage:
         return HaystackIndexWriter(dense_writer=dense_writer, sparse_writer=sparse_writer)

-    def _extract_builder(_: StageDefinition) -> ExtractStage:
+    def _extract_builder(_: PipelineTopologyConfig, __: StageDefinition) -> ExtractStage:
         return NoOpExtractStage()

-    def _kg_builder(_: StageDefinition) -> KGStage:
+    def _kg_builder(_: PipelineTopologyConfig, __: StageDefinition) -> KGStage:
         return NoOpKnowledgeGraphStage()

+    def _gate_builder(topology: PipelineTopologyConfig, definition: StageDefinition) -> GateStage:
+        if not definition.gate:
+            raise ValueError(f"gate stage '{definition.name}' is missing a gate reference")
+        gate = next((candidate for candidate in topology.gates if candidate.name == definition.gate), None)
+        if gate is None:
+            raise ValueError(
+                f"gate stage '{definition.name}' references unknown gate '{definition.gate}'"
+            )
+        return GateStage(definition, gate)
+
     registry: dict[str, Callable[[StageDefinition], object]] = {
         "ingest": _ingest_builder,
         "parse": _parse_builder,
         "ir-validation": _validation_builder,
         "chunk": _chunk_builder,
         "embed": _embed_builder,
         "index": _index_builder,
         "extract": _extract_builder,
         "knowledge-graph": _kg_builder,
+        "gate": _gate_builder,
     }
     return registry
