schema {
  query: Query
  mutation: Mutation
}

type Query {
  document(id: ID!): Document!
  organization(id: ID!): Organization!
  search(arguments: SearchInput!): RetrievalResult!
  namespaces(tenantId: String!): [NamespaceInfo!]!
  namespace(id: String!, tenantId: String!): NamespaceInfo
}

type Mutation {
  ingest(dataset: String!, input: IngestionInput!): BatchOperation!
  chunk(input: ChunkInput!): [DocumentChunk!]!
  embed(input: EmbedInput!): EmbeddingResult!
  retrieve(input: RetrieveInput!): RetrievalResult!
  entity_link(input: EntityLinkInput!): BatchOperation!
  extract(kind: String!, input: ExtractionInput!): ExtractionResult!
  write_kg(input: KnowledgeGraphWriteInput!): KnowledgeGraphWriteResult!
}

type BatchOperation {
  total: Int!
  operations: [OperationStatus!]!
}

type OperationStatus {
  job_id: ID!
  status: String!
  message: String
  metadata: JSON
}

type Document {
  id: ID!
  title: String!
  score: Float!
  summary: String
  source: String!
  metadata: JSON
  organization(id: ID): Organization!
  claims: [Claim!]!
}

type Claim {
  id: ID!
  predicate: String!
  object_id: ID!
}

type Organization {
  id: ID!
  name: String!
  country: String!
}

type RetrievalResult {
  query: String!
  total: Int!
  documents: [Document!]!
}

type EmbeddingVector {
  id: ID!
  model: String!
  namespace: String!
  kind: String!
  dimension: Int
  vector: [Float!]
  terms: JSON
  metadata: JSON
}

type EmbeddingMetadata {
  provider: String!
  dimension: Int
  duration_ms: Float
  model: String
}

type EmbeddingResult {
  namespace: String!
  embeddings: [EmbeddingVector!]!
  metadata: EmbeddingMetadata!
}

type NamespaceInfo {
  id: ID!
  provider: String!
  kind: String!
  dimension: Int
  max_tokens: Int
  enabled: Boolean!
  allowed_tenants: [String!]!
  allowed_scopes: [String!]!
}

type DocumentChunk {
  document_id: ID!
  chunk_index: Int!
  content: String!
  metadata: JSON
}

type ExtractionResult {
  kind: String!
  document_id: ID!
  results: JSON
}

type KnowledgeGraphWriteResult {
  nodes_written: Int!
  edges_written: Int!
  metadata: JSON
}

scalar JSON

input SearchInput {
  query: String!
  filters: JSON
  pagination: PaginationInput
}

input PaginationInput {
  after: String
  first: Int = 10
}

input IngestionInput {
  tenant_id: ID!
  items: JSON
  priority: String = "normal"
  metadata: JSON
}

input ChunkInput {
  tenant_id: ID!
  document_id: ID!
  strategy: String = "semantic"
  chunk_size: Int = 1024
}

input EmbedInput {
  tenant_id: ID
  namespace: String!
  texts: [String!]!
  options: EmbeddingOptionsInput
}

input EmbeddingOptionsInput {
  normalize: Boolean = true
  model: String
}

input RetrieveInput {
  tenant_id: ID!
  query: String!
  top_k: Int = 5
  filters: JSON
}

input EntityLinkInput {
  tenant_id: ID!
  mentions: [String!]!
  context: String
}

input ExtractionInput {
  tenant_id: ID!
  document_id: ID!
  options: JSON
}

input KnowledgeGraphWriteInput {
  tenant_id: ID!
  nodes: JSON
  edges: JSON
  transactional: Boolean = true
}

